{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Projectile motion provides a fundamental framework for understanding physics in two dimensions. This document derives the governing equations, analyzes the range as a function of the angle of projection, explores practical applications, and implements simulations to visualize key relationships. 1. Theoretical Foundation Derivation of Equations of Motion Consider a projectile launched with initial velocity \\(v_0\\) at angle \\(\\theta\\) from height \\(h\\) , under gravity \\(g\\) as the sole force. Using Newton\u2019s second law, \\(\\vec{F} = m \\vec{a}\\) , with \\(F_x = 0\\) and \\(F_y = -mg\\) : Horizontal: \\(\\frac{d^2x}{dt^2} = 0\\) . Vertical: \\(\\frac{d^2y}{dt^2} = -g\\) . Initial conditions are \\(x(0) = 0\\) , \\(y(0) = h\\) , \\(\\frac{dx}{dt}(0) = v_{0x} = v_0 \\cos\\theta\\) , \\(\\frac{dy}{dt}(0) = v_{0y} = v_0 \\sin\\theta\\) . Solving: \\[ x(t) = (v_0 \\cos\\theta) t, \\] \\[ y(t) = h + (v_0 \\sin\\theta) t - \\frac{1}{2} g t^2. \\] Trajectory Equation Eliminate \\(t\\) from \\(x(t)\\) : \\(t = \\frac{x}{v_0 \\cos\\theta}\\) . Substitute into \\(y(t)\\) : \\[ y = h + (v_0 \\sin\\theta) \\frac{x}{v_0 \\cos\\theta} - \\frac{1}{2} g \\left( \\frac{x}{v_0 \\cos\\theta} \\right)^2, \\] \\[ y = h + x \\tan\\theta - \\frac{g x^2}{2 v_0^2 \\cos^2\\theta}. \\] This parabolic form depends on \\(v_0\\) , \\(\\theta\\) , \\(h\\) , and \\(g\\) , defining a family of solutions. Family of Solutions For \\(h = 0\\) , the range \\(R\\) (where \\(y = 0\\) ) is: \\[ 0 = R \\tan\\theta - \\frac{g R^2}{2 v_0^2 \\cos^2\\theta}, \\] \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g}. \\] Varying \\(v_0\\) , \\(\\theta\\) , \\(h\\) , or \\(g\\) generates distinct trajectories, e.g., higher \\(v_0\\) flattens the curve, while \\(h \\neq 0\\) shifts the landing point. 2. Analysis of the Range Range Formula For \\(h = 0\\) : \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g}. \\] Key Parameters \\(v_0\\) : Range scales as \\(v_0^2\\) . \\(g\\) : Inversely proportional to \\(R\\) . \\(\\theta\\) : \\(\\sin 2\\theta\\) peaks at 1, affecting \\(R\\) symmetrically about 45\u00b0. Parameter Effects Increasing \\(v_0\\) : If \\(v_0\\) doubles, \\(R\\) quadruples (e.g., from 10 m/s to 20 m/s, \\(R\\) increases by 4\u00d7). Changing \\(g\\) : On the Moon ( \\(g = 1.62 \\, \\text{m/s}^2\\) ), \\(R\\) is \\(9.81 / 1.62 \\approx 6\\) times larger than on Earth. Varying \\(\\theta\\) : \\(R = 0\\) at \\(\\theta = 0^\\circ, 90^\\circ\\) ; peaks at \\(\\theta = 45^\\circ\\) . Optimal Angle Maximize \\(R = \\frac{v_0^2}{g} \\sin 2\\theta\\) : \\[ \\frac{dR}{d\\theta} = \\frac{v_0^2}{g} \\cdot 2 \\cos 2\\theta = 0, \\] \\[ \\theta = 45^\\circ, \\quad R_{\\text{max}} = \\frac{v_0^2}{g}. \\] 3. Practical Applications Scenarios Basketball : Shots follow \\(y = x \\tan\\theta - \\frac{g x^2}{2 v_0^2 \\cos^2\\theta}\\) . Artillery : Targets require adjusted \\(R\\) . Space Launches : Early trajectories approximate projectiles. Uneven Terrain For landing height \\(h_f\\) : \\[ h_f = h + R \\tan\\theta - \\frac{g R^2}{2 v_0^2 \\cos^2\\theta}, \\] solve the quadratic for \\(R\\) . For \\(h > h_f\\) , \\(R\\) increases. Additional Factors Air Resistance : \\(F_d = -k v^2\\) reduces \\(R\\) , solved numerically. Wind : Adds \\(w t\\) to \\(x(t)\\) , shifting \\(R\\) . Adaptations Use numerical methods (e.g., Runge-Kutta) for drag; adjust \\(x(t) = (v_0 \\cos\\theta + w) t\\) for wind. 4. Implementation Simulation Tool Below are Python scripts simulating projectile motion. Code 1: Plotting the Trajectory for a Single Set of Parameters import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 20.0 # Initial velocity (m/s) theta_deg = 45 # Angle in degrees g = 9.81 # Gravitational acceleration (m/s^2) h = 0.0 # Initial height (m) # Convert angle to radians theta = np.radians(theta_deg) # Time of flight (for h = 0, adjust if h != 0) t_flight = 2 * v0 * np.sin(theta) / g t = np.linspace(0, t_flight, 100) # Position equations x = v0 * np.cos(theta) * t y = h + v0 * np.sin(theta) * t - 0.5 * g * t**2 # Plot plt.figure(figsize=(8, 6)) plt.plot(x, y, label=f'\u03b8 = {theta_deg}\u00b0', color='blue') plt.title('Projectile Trajectory') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Height (m)') plt.grid(True) plt.legend() plt.axhline(0, color='black', linewidth=0.5) plt.show() Code 2: Range vs. Angle for Different Initial Velocities import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 # Gravitational acceleration (m/s^2) angles_deg = np.linspace(0, 90, 91) # Angles from 0\u00b0 to 90\u00b0 angles_rad = np.radians(angles_deg) v0_values = [10, 20, 30] # Different initial velocities (m/s) # Plot plt.figure(figsize=(8, 6)) for v0 in v0_values: R = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles_deg, R, label=f'v\u2080 = {v0} m/s') plt.title('Range vs. Angle of Projection') plt.xlabel('Angle \u03b8 (degrees)') plt.ylabel('Range R (m)') plt.grid(True) plt.legend() plt.show() Code 3: Range vs. Angle for Different Gravitational Accelerations import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 20.0 # Initial velocity (m/s) angles_deg = np.linspace(0, 90, 91) # Angles from 0\u00b0 to 90\u00b0 angles_rad = np.radians(angles_deg) g_values = {'Earth': 9.81, 'Moon': 1.62, 'Mars': 3.72} # Gravity (m/s^2) # Plot plt.figure(figsize=(8, 6)) for planet, g in g_values.items(): R = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles_deg, R, label=f'{planet} (g = {g} m/s\u00b2)') plt.title('Range vs. Angle for Different Gravities') plt.xlabel('Angle \u03b8 (degrees)') plt.ylabel('Range R (m)') plt.grid(True) plt.legend() plt.show() Code 4: Trajectory with Non-Zero Initial Height import matplotlib.pyplot as plt import numpy as np # Constants g = 9.81 # gravity (m/s^2) v0 = 25 # initial speed (m/s) angle_deg = 45 # launch angle (degrees) angle_rad = np.radians(angle_deg) # Initial heights to test initial_heights = [0, 10, 20] # in meters labels = [f\"h0 = {h} m\" for h in initial_heights] # Time array t = np.linspace(0, 5, num=500) # simulate for 5 seconds # Plotting plt.figure(figsize=(10, 6)) for h0, label in zip(initial_heights, labels): # Equations of motion x = v0 * np.cos(angle_rad) * t y = h0 + v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 # Only keep points where y >= 0 (above ground) mask = y >= 0 plt.plot(x[mask], y[mask], label=label) plt.title(\"Projectile Motion for Different Initial Heights\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.legend() plt.grid(True) plt.show() Deliverables Equations : Derived \\(x(t)\\) , \\(y(t)\\) , and \\(R\\) . Graphs : Trajectory and \\(R\\) vs. \\(\\theta\\) plots. Limitations : Ideal model ignores drag; extend with numerical solvers. Conclusion The range \\(R = \\frac{v_0^2 \\sin 2\\theta}{g}\\) peaks at 45\u00b0, scales with \\(v_0^2\\) , and adapts to real-world factors via modifications, demonstrated through simulations. Colab Souce Code","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"Investigating the Range as a Function of the Angle of Projection Projectile motion provides a fundamental framework for understanding physics in two dimensions. This document derives the governing equations, analyzes the range as a function of the angle of projection, explores practical applications, and implements simulations to visualize key relationships.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-equations-of-motion","text":"Consider a projectile launched with initial velocity \\(v_0\\) at angle \\(\\theta\\) from height \\(h\\) , under gravity \\(g\\) as the sole force. Using Newton\u2019s second law, \\(\\vec{F} = m \\vec{a}\\) , with \\(F_x = 0\\) and \\(F_y = -mg\\) : Horizontal: \\(\\frac{d^2x}{dt^2} = 0\\) . Vertical: \\(\\frac{d^2y}{dt^2} = -g\\) . Initial conditions are \\(x(0) = 0\\) , \\(y(0) = h\\) , \\(\\frac{dx}{dt}(0) = v_{0x} = v_0 \\cos\\theta\\) , \\(\\frac{dy}{dt}(0) = v_{0y} = v_0 \\sin\\theta\\) . Solving: \\[ x(t) = (v_0 \\cos\\theta) t, \\] \\[ y(t) = h + (v_0 \\sin\\theta) t - \\frac{1}{2} g t^2. \\]","title":"Derivation of Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#trajectory-equation","text":"Eliminate \\(t\\) from \\(x(t)\\) : \\(t = \\frac{x}{v_0 \\cos\\theta}\\) . Substitute into \\(y(t)\\) : \\[ y = h + (v_0 \\sin\\theta) \\frac{x}{v_0 \\cos\\theta} - \\frac{1}{2} g \\left( \\frac{x}{v_0 \\cos\\theta} \\right)^2, \\] \\[ y = h + x \\tan\\theta - \\frac{g x^2}{2 v_0^2 \\cos^2\\theta}. \\] This parabolic form depends on \\(v_0\\) , \\(\\theta\\) , \\(h\\) , and \\(g\\) , defining a family of solutions.","title":"Trajectory Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"For \\(h = 0\\) , the range \\(R\\) (where \\(y = 0\\) ) is: \\[ 0 = R \\tan\\theta - \\frac{g R^2}{2 v_0^2 \\cos^2\\theta}, \\] \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g}. \\] Varying \\(v_0\\) , \\(\\theta\\) , \\(h\\) , or \\(g\\) generates distinct trajectories, e.g., higher \\(v_0\\) flattens the curve, while \\(h \\neq 0\\) shifts the landing point.","title":"Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-formula","text":"For \\(h = 0\\) : \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g}. \\]","title":"Range Formula"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-parameters","text":"\\(v_0\\) : Range scales as \\(v_0^2\\) . \\(g\\) : Inversely proportional to \\(R\\) . \\(\\theta\\) : \\(\\sin 2\\theta\\) peaks at 1, affecting \\(R\\) symmetrically about 45\u00b0.","title":"Key Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#parameter-effects","text":"Increasing \\(v_0\\) : If \\(v_0\\) doubles, \\(R\\) quadruples (e.g., from 10 m/s to 20 m/s, \\(R\\) increases by 4\u00d7). Changing \\(g\\) : On the Moon ( \\(g = 1.62 \\, \\text{m/s}^2\\) ), \\(R\\) is \\(9.81 / 1.62 \\approx 6\\) times larger than on Earth. Varying \\(\\theta\\) : \\(R = 0\\) at \\(\\theta = 0^\\circ, 90^\\circ\\) ; peaks at \\(\\theta = 45^\\circ\\) .","title":"Parameter Effects"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#optimal-angle","text":"Maximize \\(R = \\frac{v_0^2}{g} \\sin 2\\theta\\) : \\[ \\frac{dR}{d\\theta} = \\frac{v_0^2}{g} \\cdot 2 \\cos 2\\theta = 0, \\] \\[ \\theta = 45^\\circ, \\quad R_{\\text{max}} = \\frac{v_0^2}{g}. \\]","title":"Optimal Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#scenarios","text":"Basketball : Shots follow \\(y = x \\tan\\theta - \\frac{g x^2}{2 v_0^2 \\cos^2\\theta}\\) . Artillery : Targets require adjusted \\(R\\) . Space Launches : Early trajectories approximate projectiles.","title":"Scenarios"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#uneven-terrain","text":"For landing height \\(h_f\\) : \\[ h_f = h + R \\tan\\theta - \\frac{g R^2}{2 v_0^2 \\cos^2\\theta}, \\] solve the quadratic for \\(R\\) . For \\(h > h_f\\) , \\(R\\) increases.","title":"Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#additional-factors","text":"Air Resistance : \\(F_d = -k v^2\\) reduces \\(R\\) , solved numerically. Wind : Adds \\(w t\\) to \\(x(t)\\) , shifting \\(R\\) .","title":"Additional Factors"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#adaptations","text":"Use numerical methods (e.g., Runge-Kutta) for drag; adjust \\(x(t) = (v_0 \\cos\\theta + w) t\\) for wind.","title":"Adaptations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#simulation-tool","text":"Below are Python scripts simulating projectile motion.","title":"Simulation Tool"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#code-1-plotting-the-trajectory-for-a-single-set-of-parameters","text":"import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 20.0 # Initial velocity (m/s) theta_deg = 45 # Angle in degrees g = 9.81 # Gravitational acceleration (m/s^2) h = 0.0 # Initial height (m) # Convert angle to radians theta = np.radians(theta_deg) # Time of flight (for h = 0, adjust if h != 0) t_flight = 2 * v0 * np.sin(theta) / g t = np.linspace(0, t_flight, 100) # Position equations x = v0 * np.cos(theta) * t y = h + v0 * np.sin(theta) * t - 0.5 * g * t**2 # Plot plt.figure(figsize=(8, 6)) plt.plot(x, y, label=f'\u03b8 = {theta_deg}\u00b0', color='blue') plt.title('Projectile Trajectory') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Height (m)') plt.grid(True) plt.legend() plt.axhline(0, color='black', linewidth=0.5) plt.show()","title":"Code 1: Plotting the Trajectory for a Single Set of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#code-2-range-vs-angle-for-different-initial-velocities","text":"import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 # Gravitational acceleration (m/s^2) angles_deg = np.linspace(0, 90, 91) # Angles from 0\u00b0 to 90\u00b0 angles_rad = np.radians(angles_deg) v0_values = [10, 20, 30] # Different initial velocities (m/s) # Plot plt.figure(figsize=(8, 6)) for v0 in v0_values: R = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles_deg, R, label=f'v\u2080 = {v0} m/s') plt.title('Range vs. Angle of Projection') plt.xlabel('Angle \u03b8 (degrees)') plt.ylabel('Range R (m)') plt.grid(True) plt.legend() plt.show()","title":"Code 2: Range vs. Angle for Different Initial Velocities"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#code-3-range-vs-angle-for-different-gravitational-accelerations","text":"import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 20.0 # Initial velocity (m/s) angles_deg = np.linspace(0, 90, 91) # Angles from 0\u00b0 to 90\u00b0 angles_rad = np.radians(angles_deg) g_values = {'Earth': 9.81, 'Moon': 1.62, 'Mars': 3.72} # Gravity (m/s^2) # Plot plt.figure(figsize=(8, 6)) for planet, g in g_values.items(): R = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles_deg, R, label=f'{planet} (g = {g} m/s\u00b2)') plt.title('Range vs. Angle for Different Gravities') plt.xlabel('Angle \u03b8 (degrees)') plt.ylabel('Range R (m)') plt.grid(True) plt.legend() plt.show()","title":"Code 3: Range vs. Angle for Different Gravitational Accelerations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#code-4-trajectory-with-non-zero-initial-height","text":"import matplotlib.pyplot as plt import numpy as np # Constants g = 9.81 # gravity (m/s^2) v0 = 25 # initial speed (m/s) angle_deg = 45 # launch angle (degrees) angle_rad = np.radians(angle_deg) # Initial heights to test initial_heights = [0, 10, 20] # in meters labels = [f\"h0 = {h} m\" for h in initial_heights] # Time array t = np.linspace(0, 5, num=500) # simulate for 5 seconds # Plotting plt.figure(figsize=(10, 6)) for h0, label in zip(initial_heights, labels): # Equations of motion x = v0 * np.cos(angle_rad) * t y = h0 + v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 # Only keep points where y >= 0 (above ground) mask = y >= 0 plt.plot(x[mask], y[mask], label=label) plt.title(\"Projectile Motion for Different Initial Heights\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.legend() plt.grid(True) plt.show()","title":"Code 4: Trajectory with Non-Zero Initial Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#deliverables","text":"Equations : Derived \\(x(t)\\) , \\(y(t)\\) , and \\(R\\) . Graphs : Trajectory and \\(R\\) vs. \\(\\theta\\) plots. Limitations : Ideal model ignores drag; extend with numerical solvers.","title":"Deliverables"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"The range \\(R = \\frac{v_0^2 \\sin 2\\theta}{g}\\) peaks at 45\u00b0, scales with \\(v_0^2\\) , and adapts to real-world factors via modifications, demonstrated through simulations.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#colab","text":"Souce Code","title":"Colab"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation The forced damped pendulum is a nonlinear system governed by: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) $$ For small angles, \\(\\sin\\theta \\approx \\theta\\) , yielding a linear equation: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) $$ where \\(\\omega_0 = \\sqrt{g/L}\\) . Solutions include transient decay and a steady-state response: $$ \\theta_p(t) = D \\cos(\\omega t - \\phi), \\quad D = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (b \\omega)^2}} $$ Resonance occurs when \\(\\omega \\approx \\omega_0\\) , maximizing amplitude. 2. System Dynamics Damping \\((b)\\) : Higher \\(b\\) reduces oscillation amplitude and shifts resonance. Driving Amplitude \\((A)\\) : Larger \\(A\\) increases response, introducing nonlinear effects. Driving Frequency \\((\\omega)\\) : Controls synchronization and energy transfer. Chaos : Increasing \\(A\\) can induce period doubling and chaotic behavior. 3. Applications Energy Harvesting : Piezoelectric devices optimize energy capture by tuning \\(\\omega_0\\) . Bridges : Wind-induced oscillations (e.g., Tacoma Narrows) align with resonance behavior. Oscillating Circuits : Analogous to RLC circuits with \\(\\omega_0\\) and damping. 4. Implementation of the Forced Damped Pendulum Simulation This section demonstrates three different pendulum scenarios: 1. Pure pendulum (no damping, no external force) 2. Damped pendulum 3. Forced pendulum without damping 4.1 Pure Pendulum (No Damping, No External Force) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def pure_pendulum(state, t): theta, v = state dtheta_dt = v dv_dt = -np.sin(theta) # No damping (b=0) and no external force (A=0) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 50, 1000) # Time array initial_conditions = [0.1, 0] # [theta0, v0] # Solve sol = odeint(pure_pendulum, initial_conditions, t) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Pure Pendulum: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Pure Pendulum: Phase Space') ax2.grid(True) plt.tight_layout() plt.show() Output : Two plots showing the pure pendulum motion: 1. Left: Time series of angular displacement \u03b8(t) 2. Right: Phase space trajectory showing the conservation of energy (closed orbit) 4.2 Damped Pendulum import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def damped_pendulum(state, t, b): theta, v = state dtheta_dt = v dv_dt = -b * v - np.sin(theta) # With damping (b\u22600) but no external force (A=0) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 50, 1000) b = 0.5 # Damping coefficient initial_conditions = [0.1, 0] # Solve sol = odeint(damped_pendulum, initial_conditions, t, args=(b,)) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Damped Pendulum: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Damped Pendulum: Phase Space') ax2.grid(True) plt.tight_layout() plt.show() Output : Two plots showing the damped pendulum motion: 1. Left: Time series showing the decaying oscillations 2. Right: Phase space trajectory showing the energy dissipation (spiral trajectory) 4.3 Forced Pendulum without Damping import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def forced_pendulum(state, t, A, omega): theta, v = state dtheta_dt = v dv_dt = -np.sin(theta) + A * np.cos(omega * t) # No damping (b=0) but with external force (A\u22600) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 50, 1000) A = 0.5 # External force amplitude omega = 2/3 # Driving frequency initial_conditions = [0.1, 0] # Solve sol = odeint(forced_pendulum, initial_conditions, t, args=(A, omega)) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Forced Pendulum: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Forced Pendulum: Phase Space') ax2.grid(True) plt.tight_layout() plt.show() Output : Two plots showing the forced pendulum motion: 1. Left: Time series showing the driven oscillations 2. Right: Phase space trajectory showing the complex dynamics due to the external force 5. Colab Souce Code 6. Forced Damped Pendulum: Chaos & Resonance 6.1 Chaotic Motion in the Forced Damped Pendulum For certain values of the damping coefficient $ b $, driving amplitude $ A $, and driving frequency $ \\omega $, the forced damped pendulum exhibits chaotic behavior. A common set of parameters leading to chaos is: - $ b = 0.5 $ (moderate damping) - $ A = 1.2 $ (strong forcing) - $ \\omega = \\frac{2}{3} $ (driving frequency) Let's simulate the chaotic motion: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def chaotic_pendulum(state, t, b, A, omega): theta, v = state dtheta_dt = v dv_dt = -b * v - np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 100, 5000) # Extended time for chaotic behavior b = 0.5 A = 1.2 omega = 2/3 initial_conditions = [0.1, 0] # Solve sol = odeint(chaotic_pendulum, initial_conditions, t, args=(b, A, omega)) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Chaotic Pendulum: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Chaotic Pendulum: Phase Space') ax2.grid(True) plt.tight_layout() plt.show() Expected Output: Time Series Plot : Irregular oscillations with no periodic pattern. Phase Space Plot : A strange attractor instead of a closed orbit, characteristic of chaotic dynamics. 6.2 Resonance in the Forced Damped Pendulum Resonance occurs when the driving frequency $ \\omega $ is close to the system\u2019s natural frequency $ \\omega_0 = \\sqrt{g/L} $. This results in large oscillations. Let\u2019s simulate resonance by setting: - $ b = 0.1 $ (low damping) - $ A = 0.5 $ (moderate forcing) - $ \\omega = \\omega_0 \\approx 1 $ (resonance condition) # Define the system def resonance_pendulum(state, t, b, A, omega): theta, v = state dtheta_dt = v dv_dt = -b * v - np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 100, 5000) # Long simulation to see resonance effects b = 0.1 A = 0.5 omega = 1 # Resonance condition initial_conditions = [0.1, 0] # Solve sol = odeint(resonance_pendulum, initial_conditions, t, args=(b, A, omega)) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Resonance: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Resonance: Phase Space') ax2.grid(True) plt.tight_layout() plt.show() Expected Output: Time Series Plot : Oscillations with increasing amplitude over time. Phase Space Plot : Large periodic orbits, showing energy accumulation due to resonance.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"Investigating the Dynamics of a Forced Damped Pendulum","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The forced damped pendulum is a nonlinear system governed by: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) $$ For small angles, \\(\\sin\\theta \\approx \\theta\\) , yielding a linear equation: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) $$ where \\(\\omega_0 = \\sqrt{g/L}\\) . Solutions include transient decay and a steady-state response: $$ \\theta_p(t) = D \\cos(\\omega t - \\phi), \\quad D = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (b \\omega)^2}} $$ Resonance occurs when \\(\\omega \\approx \\omega_0\\) , maximizing amplitude.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-system-dynamics","text":"Damping \\((b)\\) : Higher \\(b\\) reduces oscillation amplitude and shifts resonance. Driving Amplitude \\((A)\\) : Larger \\(A\\) increases response, introducing nonlinear effects. Driving Frequency \\((\\omega)\\) : Controls synchronization and energy transfer. Chaos : Increasing \\(A\\) can induce period doubling and chaotic behavior.","title":"2. System Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-applications","text":"Energy Harvesting : Piezoelectric devices optimize energy capture by tuning \\(\\omega_0\\) . Bridges : Wind-induced oscillations (e.g., Tacoma Narrows) align with resonance behavior. Oscillating Circuits : Analogous to RLC circuits with \\(\\omega_0\\) and damping.","title":"3. Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-of-the-forced-damped-pendulum-simulation","text":"This section demonstrates three different pendulum scenarios: 1. Pure pendulum (no damping, no external force) 2. Damped pendulum 3. Forced pendulum without damping","title":"4. Implementation of the Forced Damped Pendulum Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#41-pure-pendulum-no-damping-no-external-force","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def pure_pendulum(state, t): theta, v = state dtheta_dt = v dv_dt = -np.sin(theta) # No damping (b=0) and no external force (A=0) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 50, 1000) # Time array initial_conditions = [0.1, 0] # [theta0, v0] # Solve sol = odeint(pure_pendulum, initial_conditions, t) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Pure Pendulum: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Pure Pendulum: Phase Space') ax2.grid(True) plt.tight_layout() plt.show() Output : Two plots showing the pure pendulum motion: 1. Left: Time series of angular displacement \u03b8(t) 2. Right: Phase space trajectory showing the conservation of energy (closed orbit)","title":"4.1 Pure Pendulum (No Damping, No External Force)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#42-damped-pendulum","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def damped_pendulum(state, t, b): theta, v = state dtheta_dt = v dv_dt = -b * v - np.sin(theta) # With damping (b\u22600) but no external force (A=0) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 50, 1000) b = 0.5 # Damping coefficient initial_conditions = [0.1, 0] # Solve sol = odeint(damped_pendulum, initial_conditions, t, args=(b,)) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Damped Pendulum: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Damped Pendulum: Phase Space') ax2.grid(True) plt.tight_layout() plt.show() Output : Two plots showing the damped pendulum motion: 1. Left: Time series showing the decaying oscillations 2. Right: Phase space trajectory showing the energy dissipation (spiral trajectory)","title":"4.2 Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#43-forced-pendulum-without-damping","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def forced_pendulum(state, t, A, omega): theta, v = state dtheta_dt = v dv_dt = -np.sin(theta) + A * np.cos(omega * t) # No damping (b=0) but with external force (A\u22600) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 50, 1000) A = 0.5 # External force amplitude omega = 2/3 # Driving frequency initial_conditions = [0.1, 0] # Solve sol = odeint(forced_pendulum, initial_conditions, t, args=(A, omega)) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Forced Pendulum: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Forced Pendulum: Phase Space') ax2.grid(True) plt.tight_layout() plt.show() Output : Two plots showing the forced pendulum motion: 1. Left: Time series showing the driven oscillations 2. Right: Phase space trajectory showing the complex dynamics due to the external force","title":"4.3 Forced Pendulum without Damping"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-colab","text":"Souce Code","title":"5. Colab"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-forced-damped-pendulum-chaos-resonance","text":"","title":"6. Forced Damped Pendulum: Chaos &amp; Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#61-chaotic-motion-in-the-forced-damped-pendulum","text":"For certain values of the damping coefficient $ b $, driving amplitude $ A $, and driving frequency $ \\omega $, the forced damped pendulum exhibits chaotic behavior. A common set of parameters leading to chaos is: - $ b = 0.5 $ (moderate damping) - $ A = 1.2 $ (strong forcing) - $ \\omega = \\frac{2}{3} $ (driving frequency) Let's simulate the chaotic motion: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def chaotic_pendulum(state, t, b, A, omega): theta, v = state dtheta_dt = v dv_dt = -b * v - np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 100, 5000) # Extended time for chaotic behavior b = 0.5 A = 1.2 omega = 2/3 initial_conditions = [0.1, 0] # Solve sol = odeint(chaotic_pendulum, initial_conditions, t, args=(b, A, omega)) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Chaotic Pendulum: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Chaotic Pendulum: Phase Space') ax2.grid(True) plt.tight_layout() plt.show()","title":"6.1 Chaotic Motion in the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#expected-output","text":"Time Series Plot : Irregular oscillations with no periodic pattern. Phase Space Plot : A strange attractor instead of a closed orbit, characteristic of chaotic dynamics.","title":"Expected Output:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#62-resonance-in-the-forced-damped-pendulum","text":"Resonance occurs when the driving frequency $ \\omega $ is close to the system\u2019s natural frequency $ \\omega_0 = \\sqrt{g/L} $. This results in large oscillations. Let\u2019s simulate resonance by setting: - $ b = 0.1 $ (low damping) - $ A = 0.5 $ (moderate forcing) - $ \\omega = \\omega_0 \\approx 1 $ (resonance condition) # Define the system def resonance_pendulum(state, t, b, A, omega): theta, v = state dtheta_dt = v dv_dt = -b * v - np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 100, 5000) # Long simulation to see resonance effects b = 0.1 A = 0.5 omega = 1 # Resonance condition initial_conditions = [0.1, 0] # Solve sol = odeint(resonance_pendulum, initial_conditions, t, args=(b, A, omega)) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Resonance: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Resonance: Phase Space') ax2.grid(True) plt.tight_layout() plt.show()","title":"6.2 Resonance in the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#expected-output_1","text":"Time Series Plot : Oscillations with increasing amplitude over time. Phase Space Plot : Large periodic orbits, showing energy accumulation due to resonance.","title":"Expected Output:"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius 1. Theoretical Derivation of Kepler\u2019s Third Law 1.1 Newton's Law of Universal Gravitation The gravitational force between two masses is given by Newton\u2019s Law: \\[ F_g = G \\frac{Mm}{r^2} \\] Where: - \\(F_g\\) is the gravitational force, - \\(G\\) is the universal gravitational constant, - \\(M\\) is the mass of the central (larger) body (e.g., the Sun), - \\(m\\) is the mass of the orbiting body (e.g., a planet), - \\(r\\) is the orbital radius (distance between the centers of the two bodies). 1.2 Centripetal Force Requirement for Circular Motion For an object in circular motion, the centripetal force required to keep it in orbit is: \\[ F_c = \\frac{mv^2}{r} \\] Where: - \\(m\\) is the mass of the orbiting body, - \\(v\\) is its orbital speed, - \\(r\\) is the radius of the circular orbit. 1.3 Equating Gravitational and Centripetal Forces In a stable circular orbit, the gravitational force provides the necessary centripetal force: \\[ F_g = F_c \\] Thus: \\[ G \\frac{Mm}{r^2} = \\frac{mv^2}{r} \\] Cancel \\(m\\) from both sides: \\[ G \\frac{M}{r^2} = \\frac{v^2}{r} \\] Multiply both sides by \\(r\\) : \\[ G \\frac{M}{r} = v^2 \\] 1.4 Orbital Period and Velocity The orbital period \\(T\\) is the time taken to complete one full orbit. For a circular orbit of radius \\(r\\) , the orbital speed \\(v\\) is: \\[ v = \\frac{2\\pi r}{T} \\] Substitute this into the previous equation: \\[ G \\frac{M}{r} = \\left( \\frac{2\\pi r}{T} \\right)^2 \\] Simplify the right-hand side: \\[ G \\frac{M}{r} = \\frac{4\\pi^2 r^2}{T^2} \\] Multiply both sides by \\(T^2\\) : \\[ G M T^2 = 4\\pi^2 r^3 \\] Finally, solve for \\(T^2\\) : \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] 1.5 Result: Kepler\u2019s Third Law This shows the square of the orbital period is proportional to the cube of the orbital radius: \\[ T^2 \\propto r^3 \\] The constant of proportionality depends on the mass of the central object ( \\(M\\) ): \\[ T^2 = \\left( \\frac{4\\pi^2}{G M} \\right) r^3 \\] This is the mathematical expression of Kepler\u2019s Third Law for circular orbits, derived from Newtonian mechanics. 2. Conceptual Discussion: Significance of Kepler's Third Law 2.1 Importance in Astronomy Kepler\u2019s Third Law: \\[ T^2 \\propto r^3 \\] provides a foundational relationship between the orbital period ( \\(T\\) ) of a body and its average distance ( \\(r\\) ) from the object it orbits. When derived from Newtonian mechanics, this relationship becomes: \\[ T^2 = \\left( \\frac{4\\pi^2}{G M} \\right) r^3 \\] This is significant for several reasons: It connects orbital motion directly to the gravitational force and the mass of the central body . It allows astronomers to infer hidden properties of celestial systems using observable quantities like period and radius. It plays a key role in planetary science , stellar systems , exoplanet detection , and satellite engineering . 2.2 Determining Masses of Celestial Bodies Rearranging the Newtonian form of Kepler\u2019s Third Law: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] This equation enables us to calculate the mass ( \\(M\\) ) of the central object (e.g., Earth, the Sun, or a star), provided the orbital period ( \\(T\\) ) and orbital radius ( \\(r\\) ) of a satellite or planet are known. Example: Knowing the Moon\u2019s orbital radius and period allows us to compute Earth\u2019s mass. Observing the orbit of a moon around Jupiter allows astronomers to determine Jupiter\u2019s mass . 2.3 Measuring Distances Between Planets and Stars If the central mass \\(M\\) is already known (e.g., solar mass), then: \\[ r^3 = \\frac{G M T^2}{4\\pi^2} \\] This allows astronomers to compute orbital radii from observed periods. Applications: Calculating the average distances of planets from the Sun. Estimating the distances of exoplanets from their host stars (based on transit and radial velocity data). 2.4 Applications to Natural and Artificial Satellites Kepler's Third Law is universally valid for any object under gravitational orbit, whether natural or artificial. Natural Satellites: Describes the motion of moons around planets. Crucial for studying tidal locking , orbital resonances , and planetary system formation . Artificial Satellites: Essential for placing satellites in stable orbits around Earth (e.g., geostationary orbit ). Used to design communication satellites, GPS constellations, and space probes. For artificial satellites orbiting Earth: \\[ T^2 = \\left( \\frac{4\\pi^2}{G M_E} \\right) r^3 \\] where \\(M_E\\) is Earth's mass. Engineers use this to determine the required altitude ( \\(r\\) ) for a given orbital period ( \\(T\\) ). 2.5 Summary Kepler\u2019s Third Law is more than a mathematical curiosity\u2014it is a powerful tool for: Estimating masses and distances in the universe. Understanding both natural orbital mechanics and human-made satellite systems . Providing a bridge between observable orbital motion and invisible gravitational forces . 3. Real-World Applications of Kepler\u2019s Third Law Kepler\u2019s Third Law, in its Newtonian form: \\[ T^2 = \\left( \\frac{4\\pi^2}{G M} \\right) r^3 \\] can be tested and verified using real astronomical and artificial satellite data. The law enables calculations of orbital parameters across a wide range of systems\u2014from the Moon to distant planets, to GPS satellites. 3.1 The Moon Orbiting Earth Known values: - Orbital radius: \\(r \\approx 3.84 \\times 10^8 \\ \\text{m}\\) - Orbital period: \\(T \\approx 27.32 \\ \\text{days} \\approx 2.36 \\times 10^6 \\ \\text{s}\\) - Mass of Earth: \\(M_E \\approx 5.97 \\times 10^{24} \\ \\text{kg}\\) Prediction using Newtonian Kepler\u2019s Law: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M_E} \\] Plugging in values: \\[ T^2 \\approx \\frac{4\\pi^2 (3.84 \\times 10^8)^3}{6.674 \\times 10^{-11} \\cdot 5.97 \\times 10^{24}} \\approx 5.57 \\times 10^{12} \\ \\text{s}^2 \\] Taking square root: \\[ T \\approx \\sqrt{5.57 \\times 10^{12}} \\approx 2.36 \\times 10^6 \\ \\text{s} \\] \u2705 Match with observed period confirms validity. 3.2 Earth and Planets Orbiting the Sun Standard form using Astronomical Units (AU) and Earth years: If \\(T\\) is in Earth years and \\(r\\) in AU (Astronomical Units), then: \\[ T^2 = r^3 \\] Planet Orbital Radius \\(r\\) (AU) Period \\(T\\) (years) \\(T^2\\) \\(r^3\\) Earth 1.00 1.00 1.00 1.00 Mars 1.52 1.88 3.53 3.51 Jupiter 5.20 11.86 140.7 140.6 Saturn 9.58 29.46 867.9 880.3 \u2705 Close agreement of \\(T^2\\) and \\(r^3\\) supports Kepler's Law. 3.3 Artificial Satellites (e.g., GPS Satellites) GPS satellite parameters: - Orbital radius: \\(r \\approx 2.66 \\times 10^7 \\ \\text{m}\\) - Orbital period: \\(T \\approx 12 \\ \\text{hours} \\approx 4.32 \\times 10^4 \\ \\text{s}\\) - Mass of Earth: \\(M_E = 5.97 \\times 10^{24} \\ \\text{kg}\\) Use Kepler\u2019s Law: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M_E} \\] Calculate predicted \\(T\\) : \\[ T \\approx \\sqrt{ \\frac{4\\pi^2 (2.66 \\times 10^7)^3}{6.674 \\times 10^{-11} \\cdot 5.97 \\times 10^{24}} } \\approx 4.32 \\times 10^4 \\ \\text{s} \\] \u2705 Prediction matches design specification for GPS satellites. Comparison Summary Kepler\u2019s Third Law accurately predicts orbital behavior across: Natural satellites (e.g., Moon, planetary moons). Planetary orbits (in both AU and SI units). Artificial satellites (critical for telecommunications and navigation). This universality confirms the power and elegance of Kepler\u2019s Third Law when paired with Newton\u2019s laws of motion and gravitation. 4. Visualization and Verification 4.1 Real Data Plot: \\(T^2\\) vs \\(r^3\\) for Planets To test Kepler\u2019s Third Law using Solar System planets, we compute \\(T^2\\) and \\(r^3\\) using known orbital data: \\(r\\) : orbital radius in AU \\(T\\) : orbital period in Earth years We expect: \\[ T^2 = r^3 \\] import matplotlib.pyplot as plt import numpy as np # Planetary data planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'] r = np.array([0.39, 0.72, 1.00, 1.52, 5.20, 9.58]) # AU T = np.array([0.24, 0.62, 1.00, 1.88, 11.86, 29.46]) # years T_squared = T**2 r_cubed = r**3 plt.figure(figsize=(8, 5)) plt.scatter(r_cubed, T_squared, color='teal', s=70, edgecolor='black') for i, planet in enumerate(planets): plt.annotate(planet, (r_cubed[i], T_squared[i]), textcoords=\"offset points\", xytext=(5,5)) plt.title(\"$T^2$ vs $r^3$ for Planets in the Solar System\", fontsize=14) plt.xlabel(\"$r^3$ (AU\u00b3)\") plt.ylabel(\"$T^2$ (years\u00b2)\") plt.grid(True, linestyle='--', alpha=0.6) plt.tight_layout() plt.show() import matplotlib.pyplot as plt import numpy as np # Planetary data planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'] r = np.array([0.39, 0.72, 1.00, 1.52, 5.20, 9.58]) # AU T = np.array([0.24, 0.62, 1.00, 1.88, 11.86, 29.46]) # years # Compute T^2 and r^3 T_squared = T**2 r_cubed = r**3 # Plot in log-log scale plt.figure(figsize=(8, 5)) plt.loglog(r_cubed, T_squared, 'o', color='teal', markersize=8, markeredgecolor='black') # Annotations for i, planet in enumerate(planets): plt.annotate(planet, (r_cubed[i], T_squared[i]), textcoords=\"offset points\", xytext=(6,4)) plt.title(\"Log-Log Plot: $T^2$ vs $r^3$ for Planets\", fontsize=14) plt.xlabel(\"$r^3$ (AU\u00b3)\", fontsize=12) plt.ylabel(\"$T^2$ (years\u00b2)\", fontsize=12) plt.grid(True, which='both', linestyle='--', alpha=0.6) plt.tight_layout() plt.show() 4.2 Real Data: Log-Log Plot and Slope Verification To avoid compression near the origin and test proportionality: Transform both sides to logarithmic scale. Fit a line to the log-log data. Slope \\(\\approx 1\\) confirms \\(T^2 \\propto r^3\\) . from scipy.stats import linregress log_r3 = np.log10(r_cubed) log_T2 = np.log10(T_squared) slope, intercept, r_value, _, _ = linregress(log_r3, log_T2) plt.figure(figsize=(8, 5)) plt.plot(log_r3, log_T2, 'o-', color='darkgreen') plt.title(\"Log-Log Plot: $\\\\log(T^2)$ vs $\\\\log(r^3)$\", fontsize=14) plt.xlabel(\"$\\\\log(r^3)$\") plt.ylabel(\"$\\\\log(T^2)$\") plt.grid(True, which='both', linestyle='--', alpha=0.6) plt.text(min(log_r3), max(log_T2)-0.2, f\"Slope \u2248 {slope:.3f}\", color='red', fontsize=12) plt.tight_layout() plt.show() 4.3 Simulated Data: Verifying \\(T^2 \\propto r^3\\) Using Newton\u2019s formulation: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Simulate orbits for different radii and verify \\(T^2\\) vs \\(r^3\\) . # Simulate a system with Sun-like central mass G = 6.674e-11 # m^3 kg^-1 s^-2 M = 1.989e30 # kg (Sun's mass) r_vals = np.linspace(0.5e11, 2.5e11, 6) # meters T_vals = 2 * np.pi * np.sqrt(r_vals**3 / (G * M)) # seconds # Convert to AU and years AU = 1.496e11 year = 3.154e7 r_AU = r_vals / AU T_years = T_vals / year plt.figure(figsize=(8, 5)) plt.plot(r_AU**3, T_years**2, 'o-', color='darkorange') plt.title(\"Simulated: $T^2$ vs $r^3$\", fontsize=14) plt.xlabel(\"$r^3$ (AU\u00b3)\") plt.ylabel(\"$T^2$ (years\u00b2)\") plt.grid(True, linestyle='--', alpha=0.6) plt.tight_layout() plt.show() 4.4 Simulated Log-Log Plot and Slope Check log_r_sim = np.log10(r_AU**3) log_T_sim = np.log10(T_years**2) slope_sim, _, _, _, _ = linregress(log_r_sim, log_T_sim) plt.figure(figsize=(8, 5)) plt.plot(log_r_sim, log_T_sim, 'o-', color='purple') plt.title(\"Simulated: Log-Log Plot\", fontsize=14) plt.xlabel(\"$\\\\log(r^3)$\") plt.ylabel(\"$\\\\log(T^2)$\") plt.grid(True, which='both', linestyle='--', alpha=0.6) plt.text(min(log_r_sim), max(log_T_sim)-0.2, f\"Slope \u2248 {slope_sim:.3f}\", color='red', fontsize=12) plt.tight_layout() plt.show() 4.5 Simulated Orbit Animation: Earth Orbiting the Sun To enhance visual understanding, we simulate the circular orbit of Earth around the Sun using matplotlib.animation . This helps demonstrate: Constant radius motion in a circular orbit Uniform angular speed Central gravitational attraction (Sun remains at the focus) import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation from IPython.display import HTML # Constants G = 6.674e-11 # Gravitational constant (m^3/kg/s^2) M = 1.989e30 # Mass of the Sun (kg) r = 1.5e11 # Orbital radius (1 AU in meters) # Generate orbital positions theta = np.linspace(0, 2 * np.pi, 360) x = r * np.cos(theta) y = r * np.sin(theta) # Set up the figure fig, ax = plt.subplots(figsize=(6,6)) planet, = ax.plot([], [], 'bo', markersize=8) # Earth sun, = ax.plot(0, 0, 'yo', markersize=12) # Sun orbit, = ax.plot(x, y, 'k--', linewidth=0.5) # Orbit path ax.set_xlim(-r * 1.2, r * 1.2) ax.set_ylim(-r * 1.2, r * 1.2) ax.set_aspect('equal') ax.set_title('Earth Orbiting the Sun') # Animation update function def update(frame): planet.set_data([x[frame]], [y[frame]]) return planet, # Create animation ani = animation.FuncAnimation(fig, update, frames=len(theta), interval=20) # Display animation (for Jupyter/Colab) HTML(ani.to_jshtml()) 5. Conclusion Kepler\u2019s Third Law, which relates the square of the orbital period to the cube of the orbital radius ( \\(T^2 \\propto r^3\\) ), stands as a cornerstone of classical and celestial mechanics. Through theoretical derivation from Newton\u2019s laws, conceptual interpretation, real-world validation, and computational modeling, we have demonstrated its universality and predictive power. Theoretically , we derived the law from Newton's law of gravitation and circular motion, showing how gravitational interactions dictate orbital dynamics. Conceptually , we discussed its significance in astronomy, especially in calculating the masses of celestial bodies and determining distances in planetary systems. Empirically , we validated the law using real astronomical data from the Solar System and artificial satellites, all of which confirm the \\(T^2 \\propto r^3\\) relationship with high precision. Computationally , we simulated orbits using Newtonian mechanics and verified the proportionality through numerical data and log-log analysis. This multifaceted approach not only reinforces the law\u2019s correctness but also showcases its essential role in both scientific understanding and modern technological applications. Kepler\u2019s Third Law exemplifies the profound connection between simple mathematical relationships and the grand structure of the cosmos. 6. Colab Souce Code","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"Orbital Period and Orbital Radius","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-derivation-of-keplers-third-law","text":"","title":"1. Theoretical Derivation of Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#11-newtons-law-of-universal-gravitation","text":"The gravitational force between two masses is given by Newton\u2019s Law: \\[ F_g = G \\frac{Mm}{r^2} \\] Where: - \\(F_g\\) is the gravitational force, - \\(G\\) is the universal gravitational constant, - \\(M\\) is the mass of the central (larger) body (e.g., the Sun), - \\(m\\) is the mass of the orbiting body (e.g., a planet), - \\(r\\) is the orbital radius (distance between the centers of the two bodies).","title":"1.1 Newton's Law of Universal Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#12-centripetal-force-requirement-for-circular-motion","text":"For an object in circular motion, the centripetal force required to keep it in orbit is: \\[ F_c = \\frac{mv^2}{r} \\] Where: - \\(m\\) is the mass of the orbiting body, - \\(v\\) is its orbital speed, - \\(r\\) is the radius of the circular orbit.","title":"1.2 Centripetal Force Requirement for Circular Motion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#13-equating-gravitational-and-centripetal-forces","text":"In a stable circular orbit, the gravitational force provides the necessary centripetal force: \\[ F_g = F_c \\] Thus: \\[ G \\frac{Mm}{r^2} = \\frac{mv^2}{r} \\] Cancel \\(m\\) from both sides: \\[ G \\frac{M}{r^2} = \\frac{v^2}{r} \\] Multiply both sides by \\(r\\) : \\[ G \\frac{M}{r} = v^2 \\]","title":"1.3 Equating Gravitational and Centripetal Forces"},{"location":"1%20Physics/2%20Gravity/Problem_1/#14-orbital-period-and-velocity","text":"The orbital period \\(T\\) is the time taken to complete one full orbit. For a circular orbit of radius \\(r\\) , the orbital speed \\(v\\) is: \\[ v = \\frac{2\\pi r}{T} \\] Substitute this into the previous equation: \\[ G \\frac{M}{r} = \\left( \\frac{2\\pi r}{T} \\right)^2 \\] Simplify the right-hand side: \\[ G \\frac{M}{r} = \\frac{4\\pi^2 r^2}{T^2} \\] Multiply both sides by \\(T^2\\) : \\[ G M T^2 = 4\\pi^2 r^3 \\] Finally, solve for \\(T^2\\) : \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\]","title":"1.4 Orbital Period and Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_1/#15-result-keplers-third-law","text":"This shows the square of the orbital period is proportional to the cube of the orbital radius: \\[ T^2 \\propto r^3 \\] The constant of proportionality depends on the mass of the central object ( \\(M\\) ): \\[ T^2 = \\left( \\frac{4\\pi^2}{G M} \\right) r^3 \\] This is the mathematical expression of Kepler\u2019s Third Law for circular orbits, derived from Newtonian mechanics.","title":"1.5 Result: Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-conceptual-discussion-significance-of-keplers-third-law","text":"","title":"2. Conceptual Discussion: Significance of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#21-importance-in-astronomy","text":"Kepler\u2019s Third Law: \\[ T^2 \\propto r^3 \\] provides a foundational relationship between the orbital period ( \\(T\\) ) of a body and its average distance ( \\(r\\) ) from the object it orbits. When derived from Newtonian mechanics, this relationship becomes: \\[ T^2 = \\left( \\frac{4\\pi^2}{G M} \\right) r^3 \\] This is significant for several reasons: It connects orbital motion directly to the gravitational force and the mass of the central body . It allows astronomers to infer hidden properties of celestial systems using observable quantities like period and radius. It plays a key role in planetary science , stellar systems , exoplanet detection , and satellite engineering .","title":"2.1 Importance in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#22-determining-masses-of-celestial-bodies","text":"Rearranging the Newtonian form of Kepler\u2019s Third Law: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] This equation enables us to calculate the mass ( \\(M\\) ) of the central object (e.g., Earth, the Sun, or a star), provided the orbital period ( \\(T\\) ) and orbital radius ( \\(r\\) ) of a satellite or planet are known.","title":"2.2 Determining Masses of Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example","text":"Knowing the Moon\u2019s orbital radius and period allows us to compute Earth\u2019s mass. Observing the orbit of a moon around Jupiter allows astronomers to determine Jupiter\u2019s mass .","title":"Example:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#23-measuring-distances-between-planets-and-stars","text":"If the central mass \\(M\\) is already known (e.g., solar mass), then: \\[ r^3 = \\frac{G M T^2}{4\\pi^2} \\] This allows astronomers to compute orbital radii from observed periods.","title":"2.3 Measuring Distances Between Planets and Stars"},{"location":"1%20Physics/2%20Gravity/Problem_1/#applications","text":"Calculating the average distances of planets from the Sun. Estimating the distances of exoplanets from their host stars (based on transit and radial velocity data).","title":"Applications:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#24-applications-to-natural-and-artificial-satellites","text":"Kepler's Third Law is universally valid for any object under gravitational orbit, whether natural or artificial.","title":"2.4 Applications to Natural and Artificial Satellites"},{"location":"1%20Physics/2%20Gravity/Problem_1/#natural-satellites","text":"Describes the motion of moons around planets. Crucial for studying tidal locking , orbital resonances , and planetary system formation .","title":"Natural Satellites:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#artificial-satellites","text":"Essential for placing satellites in stable orbits around Earth (e.g., geostationary orbit ). Used to design communication satellites, GPS constellations, and space probes. For artificial satellites orbiting Earth: \\[ T^2 = \\left( \\frac{4\\pi^2}{G M_E} \\right) r^3 \\] where \\(M_E\\) is Earth's mass. Engineers use this to determine the required altitude ( \\(r\\) ) for a given orbital period ( \\(T\\) ).","title":"Artificial Satellites:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#25-summary","text":"Kepler\u2019s Third Law is more than a mathematical curiosity\u2014it is a powerful tool for: Estimating masses and distances in the universe. Understanding both natural orbital mechanics and human-made satellite systems . Providing a bridge between observable orbital motion and invisible gravitational forces .","title":"2.5 Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-applications-of-keplers-third-law","text":"Kepler\u2019s Third Law, in its Newtonian form: \\[ T^2 = \\left( \\frac{4\\pi^2}{G M} \\right) r^3 \\] can be tested and verified using real astronomical and artificial satellite data. The law enables calculations of orbital parameters across a wide range of systems\u2014from the Moon to distant planets, to GPS satellites.","title":"3. Real-World Applications of Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#31-the-moon-orbiting-earth","text":"Known values: - Orbital radius: \\(r \\approx 3.84 \\times 10^8 \\ \\text{m}\\) - Orbital period: \\(T \\approx 27.32 \\ \\text{days} \\approx 2.36 \\times 10^6 \\ \\text{s}\\) - Mass of Earth: \\(M_E \\approx 5.97 \\times 10^{24} \\ \\text{kg}\\) Prediction using Newtonian Kepler\u2019s Law: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M_E} \\] Plugging in values: \\[ T^2 \\approx \\frac{4\\pi^2 (3.84 \\times 10^8)^3}{6.674 \\times 10^{-11} \\cdot 5.97 \\times 10^{24}} \\approx 5.57 \\times 10^{12} \\ \\text{s}^2 \\] Taking square root: \\[ T \\approx \\sqrt{5.57 \\times 10^{12}} \\approx 2.36 \\times 10^6 \\ \\text{s} \\] \u2705 Match with observed period confirms validity.","title":"3.1 The Moon Orbiting Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#32-earth-and-planets-orbiting-the-sun","text":"Standard form using Astronomical Units (AU) and Earth years: If \\(T\\) is in Earth years and \\(r\\) in AU (Astronomical Units), then: \\[ T^2 = r^3 \\] Planet Orbital Radius \\(r\\) (AU) Period \\(T\\) (years) \\(T^2\\) \\(r^3\\) Earth 1.00 1.00 1.00 1.00 Mars 1.52 1.88 3.53 3.51 Jupiter 5.20 11.86 140.7 140.6 Saturn 9.58 29.46 867.9 880.3 \u2705 Close agreement of \\(T^2\\) and \\(r^3\\) supports Kepler's Law.","title":"3.2 Earth and Planets Orbiting the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#33-artificial-satellites-eg-gps-satellites","text":"GPS satellite parameters: - Orbital radius: \\(r \\approx 2.66 \\times 10^7 \\ \\text{m}\\) - Orbital period: \\(T \\approx 12 \\ \\text{hours} \\approx 4.32 \\times 10^4 \\ \\text{s}\\) - Mass of Earth: \\(M_E = 5.97 \\times 10^{24} \\ \\text{kg}\\) Use Kepler\u2019s Law: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M_E} \\] Calculate predicted \\(T\\) : \\[ T \\approx \\sqrt{ \\frac{4\\pi^2 (2.66 \\times 10^7)^3}{6.674 \\times 10^{-11} \\cdot 5.97 \\times 10^{24}} } \\approx 4.32 \\times 10^4 \\ \\text{s} \\] \u2705 Prediction matches design specification for GPS satellites.","title":"3.3 Artificial Satellites (e.g., GPS Satellites)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#comparison-summary","text":"Kepler\u2019s Third Law accurately predicts orbital behavior across: Natural satellites (e.g., Moon, planetary moons). Planetary orbits (in both AU and SI units). Artificial satellites (critical for telecommunications and navigation). This universality confirms the power and elegance of Kepler\u2019s Third Law when paired with Newton\u2019s laws of motion and gravitation.","title":"Comparison Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-visualization-and-verification","text":"","title":"4. Visualization and Verification"},{"location":"1%20Physics/2%20Gravity/Problem_1/#41-real-data-plot-t2-vs-r3-for-planets","text":"To test Kepler\u2019s Third Law using Solar System planets, we compute \\(T^2\\) and \\(r^3\\) using known orbital data: \\(r\\) : orbital radius in AU \\(T\\) : orbital period in Earth years We expect: \\[ T^2 = r^3 \\] import matplotlib.pyplot as plt import numpy as np # Planetary data planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'] r = np.array([0.39, 0.72, 1.00, 1.52, 5.20, 9.58]) # AU T = np.array([0.24, 0.62, 1.00, 1.88, 11.86, 29.46]) # years T_squared = T**2 r_cubed = r**3 plt.figure(figsize=(8, 5)) plt.scatter(r_cubed, T_squared, color='teal', s=70, edgecolor='black') for i, planet in enumerate(planets): plt.annotate(planet, (r_cubed[i], T_squared[i]), textcoords=\"offset points\", xytext=(5,5)) plt.title(\"$T^2$ vs $r^3$ for Planets in the Solar System\", fontsize=14) plt.xlabel(\"$r^3$ (AU\u00b3)\") plt.ylabel(\"$T^2$ (years\u00b2)\") plt.grid(True, linestyle='--', alpha=0.6) plt.tight_layout() plt.show() import matplotlib.pyplot as plt import numpy as np # Planetary data planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'] r = np.array([0.39, 0.72, 1.00, 1.52, 5.20, 9.58]) # AU T = np.array([0.24, 0.62, 1.00, 1.88, 11.86, 29.46]) # years # Compute T^2 and r^3 T_squared = T**2 r_cubed = r**3 # Plot in log-log scale plt.figure(figsize=(8, 5)) plt.loglog(r_cubed, T_squared, 'o', color='teal', markersize=8, markeredgecolor='black') # Annotations for i, planet in enumerate(planets): plt.annotate(planet, (r_cubed[i], T_squared[i]), textcoords=\"offset points\", xytext=(6,4)) plt.title(\"Log-Log Plot: $T^2$ vs $r^3$ for Planets\", fontsize=14) plt.xlabel(\"$r^3$ (AU\u00b3)\", fontsize=12) plt.ylabel(\"$T^2$ (years\u00b2)\", fontsize=12) plt.grid(True, which='both', linestyle='--', alpha=0.6) plt.tight_layout() plt.show()","title":"4.1 Real Data Plot: \\(T^2\\) vs \\(r^3\\) for Planets"},{"location":"1%20Physics/2%20Gravity/Problem_1/#42-real-data-log-log-plot-and-slope-verification","text":"To avoid compression near the origin and test proportionality: Transform both sides to logarithmic scale. Fit a line to the log-log data. Slope \\(\\approx 1\\) confirms \\(T^2 \\propto r^3\\) . from scipy.stats import linregress log_r3 = np.log10(r_cubed) log_T2 = np.log10(T_squared) slope, intercept, r_value, _, _ = linregress(log_r3, log_T2) plt.figure(figsize=(8, 5)) plt.plot(log_r3, log_T2, 'o-', color='darkgreen') plt.title(\"Log-Log Plot: $\\\\log(T^2)$ vs $\\\\log(r^3)$\", fontsize=14) plt.xlabel(\"$\\\\log(r^3)$\") plt.ylabel(\"$\\\\log(T^2)$\") plt.grid(True, which='both', linestyle='--', alpha=0.6) plt.text(min(log_r3), max(log_T2)-0.2, f\"Slope \u2248 {slope:.3f}\", color='red', fontsize=12) plt.tight_layout() plt.show()","title":"4.2 Real Data: Log-Log Plot and Slope Verification"},{"location":"1%20Physics/2%20Gravity/Problem_1/#43-simulated-data-verifying-t2-propto-r3","text":"Using Newton\u2019s formulation: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Simulate orbits for different radii and verify \\(T^2\\) vs \\(r^3\\) . # Simulate a system with Sun-like central mass G = 6.674e-11 # m^3 kg^-1 s^-2 M = 1.989e30 # kg (Sun's mass) r_vals = np.linspace(0.5e11, 2.5e11, 6) # meters T_vals = 2 * np.pi * np.sqrt(r_vals**3 / (G * M)) # seconds # Convert to AU and years AU = 1.496e11 year = 3.154e7 r_AU = r_vals / AU T_years = T_vals / year plt.figure(figsize=(8, 5)) plt.plot(r_AU**3, T_years**2, 'o-', color='darkorange') plt.title(\"Simulated: $T^2$ vs $r^3$\", fontsize=14) plt.xlabel(\"$r^3$ (AU\u00b3)\") plt.ylabel(\"$T^2$ (years\u00b2)\") plt.grid(True, linestyle='--', alpha=0.6) plt.tight_layout() plt.show()","title":"4.3 Simulated Data: Verifying \\(T^2 \\propto r^3\\)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#44-simulated-log-log-plot-and-slope-check","text":"log_r_sim = np.log10(r_AU**3) log_T_sim = np.log10(T_years**2) slope_sim, _, _, _, _ = linregress(log_r_sim, log_T_sim) plt.figure(figsize=(8, 5)) plt.plot(log_r_sim, log_T_sim, 'o-', color='purple') plt.title(\"Simulated: Log-Log Plot\", fontsize=14) plt.xlabel(\"$\\\\log(r^3)$\") plt.ylabel(\"$\\\\log(T^2)$\") plt.grid(True, which='both', linestyle='--', alpha=0.6) plt.text(min(log_r_sim), max(log_T_sim)-0.2, f\"Slope \u2248 {slope_sim:.3f}\", color='red', fontsize=12) plt.tight_layout() plt.show()","title":"4.4 Simulated Log-Log Plot and Slope Check"},{"location":"1%20Physics/2%20Gravity/Problem_1/#45-simulated-orbit-animation-earth-orbiting-the-sun","text":"To enhance visual understanding, we simulate the circular orbit of Earth around the Sun using matplotlib.animation . This helps demonstrate: Constant radius motion in a circular orbit Uniform angular speed Central gravitational attraction (Sun remains at the focus) import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation from IPython.display import HTML # Constants G = 6.674e-11 # Gravitational constant (m^3/kg/s^2) M = 1.989e30 # Mass of the Sun (kg) r = 1.5e11 # Orbital radius (1 AU in meters) # Generate orbital positions theta = np.linspace(0, 2 * np.pi, 360) x = r * np.cos(theta) y = r * np.sin(theta) # Set up the figure fig, ax = plt.subplots(figsize=(6,6)) planet, = ax.plot([], [], 'bo', markersize=8) # Earth sun, = ax.plot(0, 0, 'yo', markersize=12) # Sun orbit, = ax.plot(x, y, 'k--', linewidth=0.5) # Orbit path ax.set_xlim(-r * 1.2, r * 1.2) ax.set_ylim(-r * 1.2, r * 1.2) ax.set_aspect('equal') ax.set_title('Earth Orbiting the Sun') # Animation update function def update(frame): planet.set_data([x[frame]], [y[frame]]) return planet, # Create animation ani = animation.FuncAnimation(fig, update, frames=len(theta), interval=20) # Display animation (for Jupyter/Colab) HTML(ani.to_jshtml())","title":"4.5 Simulated Orbit Animation: Earth Orbiting the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-conclusion","text":"Kepler\u2019s Third Law, which relates the square of the orbital period to the cube of the orbital radius ( \\(T^2 \\propto r^3\\) ), stands as a cornerstone of classical and celestial mechanics. Through theoretical derivation from Newton\u2019s laws, conceptual interpretation, real-world validation, and computational modeling, we have demonstrated its universality and predictive power. Theoretically , we derived the law from Newton's law of gravitation and circular motion, showing how gravitational interactions dictate orbital dynamics. Conceptually , we discussed its significance in astronomy, especially in calculating the masses of celestial bodies and determining distances in planetary systems. Empirically , we validated the law using real astronomical data from the Solar System and artificial satellites, all of which confirm the \\(T^2 \\propto r^3\\) relationship with high precision. Computationally , we simulated orbits using Newtonian mechanics and verified the proportionality through numerical data and log-log analysis. This multifaceted approach not only reinforces the law\u2019s correctness but also showcases its essential role in both scientific understanding and modern technological applications. Kepler\u2019s Third Law exemplifies the profound connection between simple mathematical relationships and the grand structure of the cosmos.","title":"5. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#6-colab","text":"Souce Code","title":"6. Colab"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities 1. Definitions & Concepts 1.1 Escape Velocity Escape velocity is the minimum speed an object must reach to break free from the gravitational pull of a celestial body, without any further propulsion. The general formula for escape velocity is derived from the conservation of energy: \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{r} \\] Solving for velocity: \\[ v_{esc} = \\sqrt{\\frac{2GM}{r}} \\] Where: - \\(v_{esc}\\) is the escape velocity, - \\(G\\) is the gravitational constant \\((6.674 \\times 10^{-11}\\,\\text{m}^3\\,\\text{kg}^{-1}\\,\\text{s}^{-2})\\) , - \\(M\\) is the mass of the celestial body, - \\(r\\) is the distance from the center of the body to the point of escape (typically the planet\u2019s radius). 1.2 First Cosmic Velocity (Orbital Velocity) The first cosmic velocity refers to the minimum horizontal speed an object must have to remain in a stable, circular orbit just above the surface of a celestial body, without falling back to the surface. It is derived by equating gravitational force to centripetal force: \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Solving for \\(v\\) : \\[ v_{orb} = \\sqrt{\\frac{GM}{r}} \\] This is also called the orbital velocity , and it is lower than escape velocity: \\[ v_{orb} = \\frac{v_{esc}}{\\sqrt{2}} \\] 1.3 Second Cosmic Velocity The second cosmic velocity is simply another term for escape velocity from a planetary body. It is the minimum speed required to completely escape the gravitational influence of the planet and enter into space, assuming no further propulsion. Thus: \\[ v_{2nd} = v_{esc} = \\sqrt{\\frac{2GM}{r}} \\] 1.4 Third Cosmic Velocity The third cosmic velocity is the speed required for a spacecraft to escape not only Earth\u2019s gravity, but also the Sun\u2019s gravity, starting from Earth\u2019s orbit. This is relevant for interstellar missions. This involves both Earth\u2019s orbital velocity around the Sun and the Sun\u2019s gravitational influence. It can be approximated by: \\[ v_{3rd} = \\sqrt{v_{esc,\\odot}^2 + v_{orb,\\oplus}^2} \\] Where: - \\(v_{esc,\\odot}\\) is the escape velocity from the Sun at Earth\u2019s distance, - \\(v_{orb,\\oplus}\\) is Earth\u2019s orbital speed around the Sun ( \\(\\approx 29.78\\,\\text{km/s}\\) ). A simplified expression (ignoring Earth's gravity) for escaping the Solar System from Earth\u2019s orbit: \\[ v_{3rd} \\approx \\sqrt{\\frac{2GM_{\\odot}}{r_{\\oplus}}} \\] Where: - \\(M_{\\odot}\\) is the mass of the Sun, - \\(r_{\\oplus}\\) is the average distance from Earth to the Sun ( \\(\\approx 1.496 \\times 10^{11}\\,\\text{m}\\) ). 1.5 Physical Meaning in Space Exploration First Cosmic Velocity is the target speed for launching satellites into low Earth orbit. It represents the threshold for achieving continuous free-fall around Earth. Second Cosmic Velocity is critical for missions intending to leave Earth's orbit \u2014 such as lunar missions or probes bound for other planets. Third Cosmic Velocity pertains to missions aiming to exit the Solar System, such as the Voyager and Pioneer spacecraft. Achieving this velocity allows an object to overcome the Sun\u2019s gravitational hold. Understanding these velocities is fundamental for determining fuel requirements, launch windows, and mission design in astrodynamics and interplanetary navigation . 2. Mathematical Derivations 2.1 Escape Velocity To derive the escape velocity, we equate the kinetic energy of an object to the gravitational potential energy required to escape the gravitational field of a body. Kinetic energy of the object: $$ KE = \\frac{1}{2}mv^2 $$ Gravitational potential energy of the object (at distance \\(r\\) from the center of mass \\(M\\) ): $$ U = -\\frac{GMm}{r} $$ For escape, the total mechanical energy must be zero: \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{r} = 0 \\] Solving for \\(v\\) : \\[ v_{esc} = \\sqrt{\\frac{2GM}{r}} \\] This velocity is independent of the mass of the escaping object and depends only on the mass and radius of the celestial body. 2.2 First Cosmic Velocity (Orbital Velocity) This is the velocity required to keep an object in circular orbit just above the surface of a planet. It is derived by balancing the gravitational force and the required centripetal force: Gravitational force: $$ F_g = \\frac{GMm}{r^2} $$ Centripetal force: $$ F_c = \\frac{mv^2}{r} $$ Setting \\(F_g = F_c\\) : \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Cancelling \\(m\\) and solving for \\(v\\) : \\[ v_{orb} = \\sqrt{\\frac{GM}{r}} \\] This is the first cosmic velocity and is precisely the speed needed for stable circular orbit at altitude zero (neglecting atmosphere). 2.3 Third Cosmic Velocity The third cosmic velocity is the speed required to escape the Sun\u2019s gravitational field from Earth\u2019s orbit. The Sun\u2019s gravitational potential energy at Earth\u2019s orbital distance: \\[ U = -\\frac{GM_{\\odot}m}{r_{\\oplus}} \\] Kinetic energy needed to escape from the Sun\u2019s gravity: \\[ \\frac{1}{2}mv^2 = \\frac{GM_{\\odot}m}{r_{\\oplus}} \\] Solving for \\(v\\) : \\[ v_{3rd} = \\sqrt{\\frac{2GM_{\\odot}}{r_{\\oplus}}} \\] However, since Earth is already moving at orbital velocity \\(v_{\\oplus} \\approx 29.78\\) km/s, the spacecraft only needs additional velocity beyond this: \\[ v_{3rd,\\,launch} = \\sqrt{v_{esc,\\odot}^2 + v_{\\oplus}^2} \\] In practice, this value is adjusted depending on the spacecraft's launch trajectory and timing (e.g., gravity assists). 2.4 Influence of Mass and Radius From the escape velocity formula: \\[ v_{esc} = \\sqrt{\\frac{2GM}{r}}, \\quad v_{orb} = \\sqrt{\\frac{GM}{r}} \\] We can draw the following conclusions: Mass ( \\(M\\) ) : As the mass of the celestial body increases, both escape and orbital velocities increase. Radius ( \\(r\\) ) : As the radius increases, the velocities decrease. This is because the gravitational potential becomes weaker farther from the center of mass. Thus, denser and more massive planets like Jupiter have significantly higher escape velocities than Mars . 2.5 Assumptions in Derivations These derivations rely on several simplifying assumptions: The celestial body is a perfect sphere with mass concentrated at the center (i.e., it behaves as a point mass). No atmospheric drag or air resistance is considered (ideal vacuum conditions). No rotational effects (e.g., Coriolis force or frame-dragging from planet spin). The motion is assumed to be purely radial (for escape) or circular (for orbit). The object has no propulsion after initial velocity is imparted (i.e., ballistic motion). These assumptions allow for clean analytical expressions but differ from real-world engineering, where rocket burns, drag, and non-uniform mass distributions are considered. 3. Calculations 3.1 Constants and Celestial Parameters We begin by defining the necessary physical constants and planetary data: Universal Constants Gravitational constant: $$ G = 6.674 \\times 10^{-11}\\,\\text{m}^3\\,\\text{kg}^{-1}\\,\\text{s}^{-2} $$ Planetary Data Planet Mass \\((M)\\) [kg] Radius \\((r)\\) [m] Distance from Sun \\((r_{\\odot})\\) [m] Earth \\(5.972 \\times 10^{24}\\) \\(6.371 \\times 10^6\\) \\(1.496 \\times 10^{11}\\) Mars \\(6.417 \\times 10^{23}\\) \\(3.390 \\times 10^6\\) \\(2.279 \\times 10^{11}\\) Jupiter \\(1.898 \\times 10^{27}\\) \\(6.9911 \\times 10^7\\) \\(7.785 \\times 10^{11}\\) Solar Mass Mass of the Sun: $$ M_{\\odot} = 1.989 \\times 10^{30}\\,\\text{kg} $$ 3.2 Formulas First Cosmic Velocity (Orbital): $$ v_{orb} = \\sqrt{\\frac{GM}{r}} $$ Second Cosmic Velocity (Escape): $$ v_{esc} = \\sqrt{\\frac{2GM}{r}} $$ Third Cosmic Velocity (Escape from the Sun at planetary orbit): $$ v_{3rd} = \\sqrt{\\frac{2GM_{\\odot}}{r_{\\odot}}} $$ Note: We assume these are launched directly from the surface or orbital path with negligible atmospheric drag and no propulsion. 3.3 Numerical Calculations Earth \\(v_{orb,\\oplus} = \\sqrt{\\frac{6.674 \\times 10^{-11} \\cdot 5.972 \\times 10^{24}}{6.371 \\times 10^6}} \\approx 7.91\\,\\text{km/s}\\) \\(v_{esc,\\oplus} = \\sqrt{2} \\cdot v_{orb,\\oplus} \\approx 11.19\\,\\text{km/s}\\) \\(v_{3rd,\\oplus} = \\sqrt{\\frac{2 \\cdot 6.674 \\times 10^{-11} \\cdot 1.989 \\times 10^{30}}{1.496 \\times 10^{11}}} \\approx 42.1\\,\\text{km/s}\\) Mars \\(v_{orb,\\text{Mars}} \\approx \\sqrt{\\frac{6.674 \\times 10^{-11} \\cdot 6.417 \\times 10^{23}}{3.390 \\times 10^6}} \\approx 3.56\\,\\text{km/s}\\) \\(v_{esc,\\text{Mars}} \\approx \\sqrt{2} \\cdot v_{orb,\\text{Mars}} \\approx 5.03\\,\\text{km/s}\\) \\(v_{3rd,\\text{Mars}} \\approx \\sqrt{\\frac{2 \\cdot 6.674 \\times 10^{-11} \\cdot 1.989 \\times 10^{30}}{2.279 \\times 10^{11}}} \\approx 38.5\\,\\text{km/s}\\) Jupiter \\(v_{orb,\\text{Jup}} \\approx \\sqrt{\\frac{6.674 \\times 10^{-11} \\cdot 1.898 \\times 10^{27}}{6.9911 \\times 10^7}} \\approx 42.1\\,\\text{km/s}\\) \\(v_{esc,\\text{Jup}} \\approx \\sqrt{2} \\cdot v_{orb,\\text{Jup}} \\approx 59.5\\,\\text{km/s}\\) \\(v_{3rd,\\text{Jup}} \\approx \\sqrt{\\frac{2 \\cdot 6.674 \\times 10^{-11} \\cdot 1.989 \\times 10^{30}}{7.785 \\times 10^{11}}} \\approx 18.5\\,\\text{km/s}\\) 3.4 Summary Table Planet \\(v_{orb}\\) [km/s] \\(v_{esc}\\) [km/s] \\(v_{3rd}\\) [km/s] Earth 7.91 11.19 42.1 Mars 3.56 5.03 38.5 Jupiter 42.1 59.5 18.5 Remarks Earth has a balanced gravity well and a moderately high third cosmic velocity. Mars , due to its smaller mass and radius, has the lowest escape velocities \u2014 making it a practical target for missions. Jupiter has extreme gravitational requirements for launching from the surface, but its position farther from the Sun reduces the third cosmic velocity needed for solar escape. These values are foundational for mission planning and propulsion calculations in aerospace engineering. 4. Visualization and Verification 4.1 Kepler's Third Law Verification: \\(T^2 \\propto r^3\\) import numpy as np import matplotlib.pyplot as plt # Semi-major axes in AU and periods in years (data from real planets) r = np.array([0.39, 0.72, 1.00, 1.52, 5.20, 9.58]) # Mercury to Saturn T = np.array([0.24, 0.62, 1.00, 1.88, 11.86, 29.46]) plt.figure() plt.plot(r**3, T**2, 'o-', label=\"$T^2$ vs $r^3$\") plt.xlabel(\"$r^3$ (AU$^3$)\") plt.ylabel(\"$T^2$ (years$^2$)\") plt.title(\"Verification of Kepler's Third Law\") plt.grid(True) plt.legend() plt.annotate(\"Linear relationship confirms $T^2 \\\\propto r^3$\", xy=(1,1), xytext=(5, 500), arrowprops=dict(arrowstyle=\"->\")) plt.show() 4.2 Log-Log Plot to Check the Slope (Expected \u2248 1) plt.figure() plt.loglog(r, T, 'o-', label=\"Log-Log Plot\") plt.xlabel(\"log($r$) [AU]\") plt.ylabel(\"log($T$) [years]\") plt.title(\"Log-Log Plot of Kepler's Third Law\") plt.grid(True, which='both') # Fit and show slope slope, intercept = np.polyfit(np.log10(r), np.log10(T), 1) plt.text(0.1, 0.3, f\"Slope \u2248 {slope:.2f}\", transform=plt.gca().transAxes) plt.legend() plt.show() 4.3 Comparison of Cosmic Velocities Across Planets import matplotlib.pyplot as plt planets = ['Earth', 'Mars', 'Jupiter'] v_orb = [7.91, 3.56, 42.1] v_esc = [11.19, 5.03, 59.5] v_3rd = [42.1, 38.5, 18.5] x = np.arange(len(planets)) width = 0.25 plt.figure() plt.bar(x - width, v_orb, width, label='1st Cosmic (Orbital)') plt.bar(x, v_esc, width, label='2nd Cosmic (Escape)') plt.bar(x + width, v_3rd, width, label='3rd Cosmic (Solar Escape)') plt.xticks(x, planets) plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Earth, Mars, and Jupiter') plt.legend() plt.grid(axis='y') plt.show() 4.4 Mass/Radius vs Escape Velocity Relationship mass = np.array([5.972e24, 6.417e23, 1.898e27]) # kg radius = np.array([6.371e6, 3.390e6, 6.9911e7]) # m labels = ['Earth', 'Mars', 'Jupiter'] G = 6.674e-11 v_esc = np.sqrt(2 * G * mass / radius) / 1000 # km/s plt.figure() plt.scatter(mass/radius, v_esc) for i, label in enumerate(labels): plt.annotate(label, (mass[i]/radius[i], v_esc[i])) plt.xlabel('Mass/Radius (kg/m)') plt.ylabel('Escape Velocity (km/s)') plt.title('Escape Velocity vs Mass/Radius') plt.grid(True) plt.show() 4.5 Simulated Escape Trajectory (Ballistic Approx.) (Optional) from scipy.integrate import solve_ivp G = 6.674e-11 M_earth = 5.972e24 R_earth = 6.371e6 def trajectory(t, y): r, v = y a = -G * M_earth / r**2 return [v, a] # Initial condition: just above Earth's surface with v_esc v0 = np.sqrt(2 * G * M_earth / R_earth) sol = solve_ivp(trajectory, [0, 10000], [R_earth, v0], t_eval=np.linspace(0, 10000, 1000)) plt.figure() plt.plot(sol.t, (sol.y[0] - R_earth)/1000) plt.xlabel(\"Time (s)\") plt.ylabel(\"Altitude above surface (km)\") plt.title(\"Escape Trajectory from Earth\") plt.grid(True) plt.show() Colab Souce Code 5. Applications & Discussion 5.1 Relevance of Cosmic Velocities in Space Missions a. Satellite Launches For a satellite to maintain a stable low Earth orbit (LEO) , it must achieve the first cosmic velocity , i.e., the orbital velocity: \\[ v_{orb} = \\sqrt{\\frac{GM}{r}} \\] For Earth, this corresponds to approximately \\(7.91\\,\\text{km/s}\\) just above the surface. Rockets are designed to deliver payloads into this velocity band with high precision. Failing to reach this speed causes the satellite to re-enter the atmosphere; exceeding it without further control may lead to escape trajectories. Launch profiles often include a vertical ascent phase (to clear the atmosphere), followed by a gravity turn to achieve horizontal velocity for orbit. b. Planetary Missions To send a spacecraft to Mars , Jupiter , or any other planet, it must at minimum achieve the second cosmic velocity : \\[ v_{esc} = \\sqrt{\\frac{2GM}{r}} \\approx 11.19\\,\\text{km/s} \\quad \\text{(for Earth)} \\] However, this speed only places the spacecraft on a heliocentric (Sun-centered) trajectory. To intercept another planet, precise Hohmann transfer orbits are computed, often using gravitational slingshots for energy efficiency. The launch window is crucial, since planets move in elliptical orbits. Delta-v budgets are carefully calculated to ensure the spacecraft escapes Earth's gravity and enters the correct interplanetary trajectory. c. Interstellar Travel To escape the Solar System , a spacecraft must reach or exceed the third cosmic velocity : \\[ v_{3rd} = \\sqrt{\\frac{2GM_{\\odot}}{r_{\\oplus}}} \\approx 42.1\\,\\text{km/s} \\] This is far beyond the capacity of conventional chemical rockets for direct launch. Missions such as Voyager 1 achieved this by combining multiple gravity assists (Jupiter, Saturn) to boost their velocity incrementally. Interstellar travel requires either: - High-efficiency propulsion (e.g., ion drives, solar sails), - Long mission durations (decades or centuries), - Or breakthrough physics (e.g., nuclear or fusion propulsion). 5.2 Engineering and Fuel Implications Achieving each velocity level involves substantial energy expenditure , and the relationship is non-linear due to the rocket equation : \\[ \\Delta v = v_e \\ln\\left( \\frac{m_0}{m_f} \\right) \\] Where: - \\(\\Delta v\\) is the required change in velocity, - \\(v_e\\) is the effective exhaust velocity of the propulsion system, - \\(m_0\\) and \\(m_f\\) are the initial and final mass of the rocket. Implications: Achieving higher \\(\\Delta v\\) requires either: Extremely efficient engines (high \\(v_e\\) ), Large fuel-to-payload ratios (increasing \\(m_0/m_f\\) ), Or staging : discarding parts of the rocket after burnout. For LEO satellites , small rockets or reusable launchers suffice. For planetary missions , multi-stage rockets like the Saturn V or SLS are necessary. For interstellar probes , current propulsion is inadequate without significant advances in fuel efficiency or entirely new energy sources. Summary Understanding and overcoming the thresholds set by the first, second, and third cosmic velocities is at the core of mission planning in astrodynamics. Each level defines a new frontier: \\(v_{orb}\\) enables orbiting , \\(v_{esc}\\) enables exploration , \\(v_{3rd}\\) hints at the possibility of escape from our solar neighborhood. Each requires innovation in both physics and engineering \u2014 combining mathematical precision, materials science, and propulsion technologies to make the cosmos accessible.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"Escape Velocities and Cosmic Velocities","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-definitions-concepts","text":"","title":"1. Definitions &amp; Concepts"},{"location":"1%20Physics/2%20Gravity/Problem_2/#11-escape-velocity","text":"Escape velocity is the minimum speed an object must reach to break free from the gravitational pull of a celestial body, without any further propulsion. The general formula for escape velocity is derived from the conservation of energy: \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{r} \\] Solving for velocity: \\[ v_{esc} = \\sqrt{\\frac{2GM}{r}} \\] Where: - \\(v_{esc}\\) is the escape velocity, - \\(G\\) is the gravitational constant \\((6.674 \\times 10^{-11}\\,\\text{m}^3\\,\\text{kg}^{-1}\\,\\text{s}^{-2})\\) , - \\(M\\) is the mass of the celestial body, - \\(r\\) is the distance from the center of the body to the point of escape (typically the planet\u2019s radius).","title":"1.1 Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#12-first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity refers to the minimum horizontal speed an object must have to remain in a stable, circular orbit just above the surface of a celestial body, without falling back to the surface. It is derived by equating gravitational force to centripetal force: \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Solving for \\(v\\) : \\[ v_{orb} = \\sqrt{\\frac{GM}{r}} \\] This is also called the orbital velocity , and it is lower than escape velocity: \\[ v_{orb} = \\frac{v_{esc}}{\\sqrt{2}} \\]","title":"1.2 First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#13-second-cosmic-velocity","text":"The second cosmic velocity is simply another term for escape velocity from a planetary body. It is the minimum speed required to completely escape the gravitational influence of the planet and enter into space, assuming no further propulsion. Thus: \\[ v_{2nd} = v_{esc} = \\sqrt{\\frac{2GM}{r}} \\]","title":"1.3 Second Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#14-third-cosmic-velocity","text":"The third cosmic velocity is the speed required for a spacecraft to escape not only Earth\u2019s gravity, but also the Sun\u2019s gravity, starting from Earth\u2019s orbit. This is relevant for interstellar missions. This involves both Earth\u2019s orbital velocity around the Sun and the Sun\u2019s gravitational influence. It can be approximated by: \\[ v_{3rd} = \\sqrt{v_{esc,\\odot}^2 + v_{orb,\\oplus}^2} \\] Where: - \\(v_{esc,\\odot}\\) is the escape velocity from the Sun at Earth\u2019s distance, - \\(v_{orb,\\oplus}\\) is Earth\u2019s orbital speed around the Sun ( \\(\\approx 29.78\\,\\text{km/s}\\) ). A simplified expression (ignoring Earth's gravity) for escaping the Solar System from Earth\u2019s orbit: \\[ v_{3rd} \\approx \\sqrt{\\frac{2GM_{\\odot}}{r_{\\oplus}}} \\] Where: - \\(M_{\\odot}\\) is the mass of the Sun, - \\(r_{\\oplus}\\) is the average distance from Earth to the Sun ( \\(\\approx 1.496 \\times 10^{11}\\,\\text{m}\\) ).","title":"1.4 Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#15-physical-meaning-in-space-exploration","text":"First Cosmic Velocity is the target speed for launching satellites into low Earth orbit. It represents the threshold for achieving continuous free-fall around Earth. Second Cosmic Velocity is critical for missions intending to leave Earth's orbit \u2014 such as lunar missions or probes bound for other planets. Third Cosmic Velocity pertains to missions aiming to exit the Solar System, such as the Voyager and Pioneer spacecraft. Achieving this velocity allows an object to overcome the Sun\u2019s gravitational hold. Understanding these velocities is fundamental for determining fuel requirements, launch windows, and mission design in astrodynamics and interplanetary navigation .","title":"1.5 Physical Meaning in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-mathematical-derivations","text":"","title":"2. Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-escape-velocity","text":"To derive the escape velocity, we equate the kinetic energy of an object to the gravitational potential energy required to escape the gravitational field of a body. Kinetic energy of the object: $$ KE = \\frac{1}{2}mv^2 $$ Gravitational potential energy of the object (at distance \\(r\\) from the center of mass \\(M\\) ): $$ U = -\\frac{GMm}{r} $$ For escape, the total mechanical energy must be zero: \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{r} = 0 \\] Solving for \\(v\\) : \\[ v_{esc} = \\sqrt{\\frac{2GM}{r}} \\] This velocity is independent of the mass of the escaping object and depends only on the mass and radius of the celestial body.","title":"2.1 Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-first-cosmic-velocity-orbital-velocity","text":"This is the velocity required to keep an object in circular orbit just above the surface of a planet. It is derived by balancing the gravitational force and the required centripetal force: Gravitational force: $$ F_g = \\frac{GMm}{r^2} $$ Centripetal force: $$ F_c = \\frac{mv^2}{r} $$ Setting \\(F_g = F_c\\) : \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Cancelling \\(m\\) and solving for \\(v\\) : \\[ v_{orb} = \\sqrt{\\frac{GM}{r}} \\] This is the first cosmic velocity and is precisely the speed needed for stable circular orbit at altitude zero (neglecting atmosphere).","title":"2.2 First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#23-third-cosmic-velocity","text":"The third cosmic velocity is the speed required to escape the Sun\u2019s gravitational field from Earth\u2019s orbit. The Sun\u2019s gravitational potential energy at Earth\u2019s orbital distance: \\[ U = -\\frac{GM_{\\odot}m}{r_{\\oplus}} \\] Kinetic energy needed to escape from the Sun\u2019s gravity: \\[ \\frac{1}{2}mv^2 = \\frac{GM_{\\odot}m}{r_{\\oplus}} \\] Solving for \\(v\\) : \\[ v_{3rd} = \\sqrt{\\frac{2GM_{\\odot}}{r_{\\oplus}}} \\] However, since Earth is already moving at orbital velocity \\(v_{\\oplus} \\approx 29.78\\) km/s, the spacecraft only needs additional velocity beyond this: \\[ v_{3rd,\\,launch} = \\sqrt{v_{esc,\\odot}^2 + v_{\\oplus}^2} \\] In practice, this value is adjusted depending on the spacecraft's launch trajectory and timing (e.g., gravity assists).","title":"2.3 Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#24-influence-of-mass-and-radius","text":"From the escape velocity formula: \\[ v_{esc} = \\sqrt{\\frac{2GM}{r}}, \\quad v_{orb} = \\sqrt{\\frac{GM}{r}} \\] We can draw the following conclusions: Mass ( \\(M\\) ) : As the mass of the celestial body increases, both escape and orbital velocities increase. Radius ( \\(r\\) ) : As the radius increases, the velocities decrease. This is because the gravitational potential becomes weaker farther from the center of mass. Thus, denser and more massive planets like Jupiter have significantly higher escape velocities than Mars .","title":"2.4 Influence of Mass and Radius"},{"location":"1%20Physics/2%20Gravity/Problem_2/#25-assumptions-in-derivations","text":"These derivations rely on several simplifying assumptions: The celestial body is a perfect sphere with mass concentrated at the center (i.e., it behaves as a point mass). No atmospheric drag or air resistance is considered (ideal vacuum conditions). No rotational effects (e.g., Coriolis force or frame-dragging from planet spin). The motion is assumed to be purely radial (for escape) or circular (for orbit). The object has no propulsion after initial velocity is imparted (i.e., ballistic motion). These assumptions allow for clean analytical expressions but differ from real-world engineering, where rocket burns, drag, and non-uniform mass distributions are considered.","title":"2.5 Assumptions in Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-calculations","text":"","title":"3. Calculations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#31-constants-and-celestial-parameters","text":"We begin by defining the necessary physical constants and planetary data:","title":"3.1 Constants and Celestial Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#universal-constants","text":"Gravitational constant: $$ G = 6.674 \\times 10^{-11}\\,\\text{m}^3\\,\\text{kg}^{-1}\\,\\text{s}^{-2} $$","title":"Universal Constants"},{"location":"1%20Physics/2%20Gravity/Problem_2/#planetary-data","text":"Planet Mass \\((M)\\) [kg] Radius \\((r)\\) [m] Distance from Sun \\((r_{\\odot})\\) [m] Earth \\(5.972 \\times 10^{24}\\) \\(6.371 \\times 10^6\\) \\(1.496 \\times 10^{11}\\) Mars \\(6.417 \\times 10^{23}\\) \\(3.390 \\times 10^6\\) \\(2.279 \\times 10^{11}\\) Jupiter \\(1.898 \\times 10^{27}\\) \\(6.9911 \\times 10^7\\) \\(7.785 \\times 10^{11}\\)","title":"Planetary Data"},{"location":"1%20Physics/2%20Gravity/Problem_2/#solar-mass","text":"Mass of the Sun: $$ M_{\\odot} = 1.989 \\times 10^{30}\\,\\text{kg} $$","title":"Solar Mass"},{"location":"1%20Physics/2%20Gravity/Problem_2/#32-formulas","text":"First Cosmic Velocity (Orbital): $$ v_{orb} = \\sqrt{\\frac{GM}{r}} $$ Second Cosmic Velocity (Escape): $$ v_{esc} = \\sqrt{\\frac{2GM}{r}} $$ Third Cosmic Velocity (Escape from the Sun at planetary orbit): $$ v_{3rd} = \\sqrt{\\frac{2GM_{\\odot}}{r_{\\odot}}} $$ Note: We assume these are launched directly from the surface or orbital path with negligible atmospheric drag and no propulsion.","title":"3.2 Formulas"},{"location":"1%20Physics/2%20Gravity/Problem_2/#33-numerical-calculations","text":"","title":"3.3 Numerical Calculations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#earth","text":"\\(v_{orb,\\oplus} = \\sqrt{\\frac{6.674 \\times 10^{-11} \\cdot 5.972 \\times 10^{24}}{6.371 \\times 10^6}} \\approx 7.91\\,\\text{km/s}\\) \\(v_{esc,\\oplus} = \\sqrt{2} \\cdot v_{orb,\\oplus} \\approx 11.19\\,\\text{km/s}\\) \\(v_{3rd,\\oplus} = \\sqrt{\\frac{2 \\cdot 6.674 \\times 10^{-11} \\cdot 1.989 \\times 10^{30}}{1.496 \\times 10^{11}}} \\approx 42.1\\,\\text{km/s}\\)","title":"Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mars","text":"\\(v_{orb,\\text{Mars}} \\approx \\sqrt{\\frac{6.674 \\times 10^{-11} \\cdot 6.417 \\times 10^{23}}{3.390 \\times 10^6}} \\approx 3.56\\,\\text{km/s}\\) \\(v_{esc,\\text{Mars}} \\approx \\sqrt{2} \\cdot v_{orb,\\text{Mars}} \\approx 5.03\\,\\text{km/s}\\) \\(v_{3rd,\\text{Mars}} \\approx \\sqrt{\\frac{2 \\cdot 6.674 \\times 10^{-11} \\cdot 1.989 \\times 10^{30}}{2.279 \\times 10^{11}}} \\approx 38.5\\,\\text{km/s}\\)","title":"Mars"},{"location":"1%20Physics/2%20Gravity/Problem_2/#jupiter","text":"\\(v_{orb,\\text{Jup}} \\approx \\sqrt{\\frac{6.674 \\times 10^{-11} \\cdot 1.898 \\times 10^{27}}{6.9911 \\times 10^7}} \\approx 42.1\\,\\text{km/s}\\) \\(v_{esc,\\text{Jup}} \\approx \\sqrt{2} \\cdot v_{orb,\\text{Jup}} \\approx 59.5\\,\\text{km/s}\\) \\(v_{3rd,\\text{Jup}} \\approx \\sqrt{\\frac{2 \\cdot 6.674 \\times 10^{-11} \\cdot 1.989 \\times 10^{30}}{7.785 \\times 10^{11}}} \\approx 18.5\\,\\text{km/s}\\)","title":"Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#34-summary-table","text":"Planet \\(v_{orb}\\) [km/s] \\(v_{esc}\\) [km/s] \\(v_{3rd}\\) [km/s] Earth 7.91 11.19 42.1 Mars 3.56 5.03 38.5 Jupiter 42.1 59.5 18.5","title":"3.4 Summary Table"},{"location":"1%20Physics/2%20Gravity/Problem_2/#remarks","text":"Earth has a balanced gravity well and a moderately high third cosmic velocity. Mars , due to its smaller mass and radius, has the lowest escape velocities \u2014 making it a practical target for missions. Jupiter has extreme gravitational requirements for launching from the surface, but its position farther from the Sun reduces the third cosmic velocity needed for solar escape. These values are foundational for mission planning and propulsion calculations in aerospace engineering.","title":"Remarks"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-visualization-and-verification","text":"","title":"4. Visualization and Verification"},{"location":"1%20Physics/2%20Gravity/Problem_2/#41-keplers-third-law-verification-t2-propto-r3","text":"import numpy as np import matplotlib.pyplot as plt # Semi-major axes in AU and periods in years (data from real planets) r = np.array([0.39, 0.72, 1.00, 1.52, 5.20, 9.58]) # Mercury to Saturn T = np.array([0.24, 0.62, 1.00, 1.88, 11.86, 29.46]) plt.figure() plt.plot(r**3, T**2, 'o-', label=\"$T^2$ vs $r^3$\") plt.xlabel(\"$r^3$ (AU$^3$)\") plt.ylabel(\"$T^2$ (years$^2$)\") plt.title(\"Verification of Kepler's Third Law\") plt.grid(True) plt.legend() plt.annotate(\"Linear relationship confirms $T^2 \\\\propto r^3$\", xy=(1,1), xytext=(5, 500), arrowprops=dict(arrowstyle=\"->\")) plt.show()","title":"4.1 Kepler's Third Law Verification: \\(T^2 \\propto r^3\\)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#42-log-log-plot-to-check-the-slope-expected-1","text":"plt.figure() plt.loglog(r, T, 'o-', label=\"Log-Log Plot\") plt.xlabel(\"log($r$) [AU]\") plt.ylabel(\"log($T$) [years]\") plt.title(\"Log-Log Plot of Kepler's Third Law\") plt.grid(True, which='both') # Fit and show slope slope, intercept = np.polyfit(np.log10(r), np.log10(T), 1) plt.text(0.1, 0.3, f\"Slope \u2248 {slope:.2f}\", transform=plt.gca().transAxes) plt.legend() plt.show()","title":"4.2 Log-Log Plot to Check the Slope (Expected \u2248 1)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#43-comparison-of-cosmic-velocities-across-planets","text":"import matplotlib.pyplot as plt planets = ['Earth', 'Mars', 'Jupiter'] v_orb = [7.91, 3.56, 42.1] v_esc = [11.19, 5.03, 59.5] v_3rd = [42.1, 38.5, 18.5] x = np.arange(len(planets)) width = 0.25 plt.figure() plt.bar(x - width, v_orb, width, label='1st Cosmic (Orbital)') plt.bar(x, v_esc, width, label='2nd Cosmic (Escape)') plt.bar(x + width, v_3rd, width, label='3rd Cosmic (Solar Escape)') plt.xticks(x, planets) plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Earth, Mars, and Jupiter') plt.legend() plt.grid(axis='y') plt.show()","title":"4.3 Comparison of Cosmic Velocities Across Planets"},{"location":"1%20Physics/2%20Gravity/Problem_2/#44-massradius-vs-escape-velocity-relationship","text":"mass = np.array([5.972e24, 6.417e23, 1.898e27]) # kg radius = np.array([6.371e6, 3.390e6, 6.9911e7]) # m labels = ['Earth', 'Mars', 'Jupiter'] G = 6.674e-11 v_esc = np.sqrt(2 * G * mass / radius) / 1000 # km/s plt.figure() plt.scatter(mass/radius, v_esc) for i, label in enumerate(labels): plt.annotate(label, (mass[i]/radius[i], v_esc[i])) plt.xlabel('Mass/Radius (kg/m)') plt.ylabel('Escape Velocity (km/s)') plt.title('Escape Velocity vs Mass/Radius') plt.grid(True) plt.show()","title":"4.4 Mass/Radius vs Escape Velocity Relationship"},{"location":"1%20Physics/2%20Gravity/Problem_2/#45-simulated-escape-trajectory-ballistic-approx-optional","text":"from scipy.integrate import solve_ivp G = 6.674e-11 M_earth = 5.972e24 R_earth = 6.371e6 def trajectory(t, y): r, v = y a = -G * M_earth / r**2 return [v, a] # Initial condition: just above Earth's surface with v_esc v0 = np.sqrt(2 * G * M_earth / R_earth) sol = solve_ivp(trajectory, [0, 10000], [R_earth, v0], t_eval=np.linspace(0, 10000, 1000)) plt.figure() plt.plot(sol.t, (sol.y[0] - R_earth)/1000) plt.xlabel(\"Time (s)\") plt.ylabel(\"Altitude above surface (km)\") plt.title(\"Escape Trajectory from Earth\") plt.grid(True) plt.show()","title":"4.5 Simulated Escape Trajectory (Ballistic Approx.) (Optional)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#colab","text":"Souce Code","title":"Colab"},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-applications-discussion","text":"","title":"5. Applications &amp; Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_2/#51-relevance-of-cosmic-velocities-in-space-missions","text":"","title":"5.1 Relevance of Cosmic Velocities in Space Missions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#a-satellite-launches","text":"For a satellite to maintain a stable low Earth orbit (LEO) , it must achieve the first cosmic velocity , i.e., the orbital velocity: \\[ v_{orb} = \\sqrt{\\frac{GM}{r}} \\] For Earth, this corresponds to approximately \\(7.91\\,\\text{km/s}\\) just above the surface. Rockets are designed to deliver payloads into this velocity band with high precision. Failing to reach this speed causes the satellite to re-enter the atmosphere; exceeding it without further control may lead to escape trajectories. Launch profiles often include a vertical ascent phase (to clear the atmosphere), followed by a gravity turn to achieve horizontal velocity for orbit.","title":"a. Satellite Launches"},{"location":"1%20Physics/2%20Gravity/Problem_2/#b-planetary-missions","text":"To send a spacecraft to Mars , Jupiter , or any other planet, it must at minimum achieve the second cosmic velocity : \\[ v_{esc} = \\sqrt{\\frac{2GM}{r}} \\approx 11.19\\,\\text{km/s} \\quad \\text{(for Earth)} \\] However, this speed only places the spacecraft on a heliocentric (Sun-centered) trajectory. To intercept another planet, precise Hohmann transfer orbits are computed, often using gravitational slingshots for energy efficiency. The launch window is crucial, since planets move in elliptical orbits. Delta-v budgets are carefully calculated to ensure the spacecraft escapes Earth's gravity and enters the correct interplanetary trajectory.","title":"b. Planetary Missions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#c-interstellar-travel","text":"To escape the Solar System , a spacecraft must reach or exceed the third cosmic velocity : \\[ v_{3rd} = \\sqrt{\\frac{2GM_{\\odot}}{r_{\\oplus}}} \\approx 42.1\\,\\text{km/s} \\] This is far beyond the capacity of conventional chemical rockets for direct launch. Missions such as Voyager 1 achieved this by combining multiple gravity assists (Jupiter, Saturn) to boost their velocity incrementally. Interstellar travel requires either: - High-efficiency propulsion (e.g., ion drives, solar sails), - Long mission durations (decades or centuries), - Or breakthrough physics (e.g., nuclear or fusion propulsion).","title":"c. Interstellar Travel"},{"location":"1%20Physics/2%20Gravity/Problem_2/#52-engineering-and-fuel-implications","text":"Achieving each velocity level involves substantial energy expenditure , and the relationship is non-linear due to the rocket equation : \\[ \\Delta v = v_e \\ln\\left( \\frac{m_0}{m_f} \\right) \\] Where: - \\(\\Delta v\\) is the required change in velocity, - \\(v_e\\) is the effective exhaust velocity of the propulsion system, - \\(m_0\\) and \\(m_f\\) are the initial and final mass of the rocket.","title":"5.2 Engineering and Fuel Implications"},{"location":"1%20Physics/2%20Gravity/Problem_2/#implications","text":"Achieving higher \\(\\Delta v\\) requires either: Extremely efficient engines (high \\(v_e\\) ), Large fuel-to-payload ratios (increasing \\(m_0/m_f\\) ), Or staging : discarding parts of the rocket after burnout. For LEO satellites , small rockets or reusable launchers suffice. For planetary missions , multi-stage rockets like the Saturn V or SLS are necessary. For interstellar probes , current propulsion is inadequate without significant advances in fuel efficiency or entirely new energy sources.","title":"Implications:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#summary","text":"Understanding and overcoming the thresholds set by the first, second, and third cosmic velocities is at the core of mission planning in astrodynamics. Each level defines a new frontier: \\(v_{orb}\\) enables orbiting , \\(v_{esc}\\) enables exploration , \\(v_{3rd}\\) hints at the possibility of escape from our solar neighborhood. Each requires innovation in both physics and engineering \u2014 combining mathematical precision, materials science, and propulsion technologies to make the cosmos accessible.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth 1. Physics and Mathematical Foundations 1.1 Newton\u2019s Law of Gravitation Newton\u2019s Law of Gravitation states that every mass attracts every other mass with a force \\(F\\) given by: \\[ F = G \\frac{m_1 m_2}{r^2} \\] where: - \\(F\\) is the gravitational force, - \\(G\\) is the gravitational constant ( \\(G \\approx 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ), - \\(m_1\\) and \\(m_2\\) are the masses of the two objects, - \\(r\\) is the distance between the centers of the two masses. The gravitational force acts along the line joining the two masses. 1.2 Newton\u2019s Second Law Applied to Gravity Newton's Second Law states that the force on an object is proportional to its acceleration: \\[ \\vec{F} = m \\vec{a} \\] Applying this to gravitational force: \\[ m \\vec{a} = -G \\frac{M m}{r^2} \\hat{r} \\] Simplifying: \\[ \\vec{a} = -G \\frac{M}{r^2} \\hat{r} \\] where: - \\(\\vec{a}\\) is the acceleration vector, - \\(M\\) is the mass of the Earth, - \\(\\hat{r}\\) is the unit vector pointing from the payload to the Earth's center. This acceleration governs the motion of a freely falling payload near Earth. 1.3 Conic Sections and Trajectory Classification The path followed by the payload is a conic section determined by the total specific mechanical energy \\(\\varepsilon\\) : \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] where: - \\(v\\) is the magnitude of velocity, - \\(r\\) is the radial distance from Earth's center. The type of trajectory depends on \\(\\varepsilon\\) : - If \\(\\varepsilon < 0\\) , the trajectory is elliptical (bound orbit). - If \\(\\varepsilon = 0\\) , the trajectory is parabolic (escape at exactly escape velocity). - If \\(\\varepsilon > 0\\) , the trajectory is hyperbolic (escape with surplus energy). The general equation for conic sections in polar coordinates: \\[ r(\\theta) = \\frac{p}{1 + e \\cos(\\theta)} \\] where: - \\(p\\) is the semi-latus rectum, - \\(e\\) is the eccentricity: - \\(0 \\leq e < 1\\) for an ellipse, - \\(e = 1\\) for a parabola, - \\(e > 1\\) for a hyperbola. 1.4 Orbital Energy (Specific Mechanical Energy) Specific mechanical energy \\(\\varepsilon\\) combines kinetic and potential energy per unit mass: \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] where: - Positive \\(\\varepsilon\\) implies unbound (hyperbolic) motion, - Zero \\(\\varepsilon\\) corresponds to parabolic escape, - Negative \\(\\varepsilon\\) indicates a bound (elliptical) orbit. The escape velocity \\(v_{\\text{esc}}\\) is derived by setting \\(\\varepsilon = 0\\) : \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] Thus, if the initial velocity \\(v > v_{\\text{esc}}\\) , the payload will escape Earth\u2019s gravity. 1.5 Kepler\u2019s Laws of Planetary Motion First Law (Law of Ellipses) : Every orbit of a planet or object is an ellipse with the center of mass at one of the two foci. Second Law (Law of Equal Areas) : A line joining a planet and the Sun sweeps out equal areas during equal intervals of time. Mathematically: $$ \\frac{dA}{dt} = \\text{constant} $$ where \\(A\\) is the area swept out. Third Law (Law of Harmonies) : The square of the orbital period \\(T\\) is proportional to the cube of the semi-major axis \\(a\\) : $$ T^2 \\propto a^3 $$ or more precisely: $$ T^2 = \\frac{4\\pi^2}{GM} a^3 $$ These laws govern the orbital behavior of payloads near Earth and help predict future positions and velocities. 2. Identify and Define Initial Conditions To model and simulate the trajectory of a payload released near Earth, it is essential to specify the initial conditions precisely. These parameters determine the entire motion under gravitational forces. 2.1 Initial Position (Vector Relative to Earth\u2019s Center) The initial position \\(\\vec{r}_0\\) of the payload is given relative to the center of Earth: \\[ \\vec{r}_0 = (x_0, y_0, z_0) \\] where: - \\(x_0\\) , \\(y_0\\) , and \\(z_0\\) are the Cartesian coordinates of the payload in an inertial reference frame, - Alternatively, the position can be expressed in polar coordinates \\((r_0, \\theta_0, \\phi_0)\\) : - \\(r_0\\) is the radial distance from Earth's center, - \\(\\theta_0\\) is the azimuthal angle (longitude), - \\(\\phi_0\\) is the polar angle (colatitude). For many problems, assuming motion in a plane (e.g., equatorial plane) simplifies calculations by setting \\(z_0 = 0\\) . 2.2 Initial Velocity (Vector at Release) The initial velocity \\(\\vec{v}_0\\) of the payload must be defined with both magnitude and direction: \\[ \\vec{v}_0 = (v_{x,0}, v_{y,0}, v_{z,0}) \\] or alternatively in polar terms: \\[ \\vec{v}_0 = v_{r,0} \\hat{r} + v_{\\theta,0} \\hat{\\theta} \\] where: - \\(v_{r,0}\\) is the radial component (along \\(\\hat{r}\\) ), - \\(v_{\\theta,0}\\) is the transverse component (perpendicular to \\(\\hat{r}\\) in the orbital plane). The initial velocity vector relative to the local horizontal critically determines the type of trajectory: - Purely radial launch ( \\(v_{\\theta,0} = 0\\) ) results in a straight path, - Purely tangential launch ( \\(v_{r,0} = 0\\) ) can lead to circular or elliptical orbits, - Mixed radial and tangential velocities create general elliptical, hyperbolic, or parabolic paths. 2.3 Initial Altitude Above Earth\u2019s Surface The altitude \\(h_0\\) is the height of the payload above the Earth's surface: \\[ h_0 = r_0 - R_E \\] where: - \\(r_0\\) is the distance from the Earth's center, - \\(R_E\\) is the radius of the Earth ( \\(R_E \\approx 6371 \\, \\text{km}\\) ). The altitude is crucial because it influences the local gravitational force magnitude. The local gravitational acceleration \\(g(h)\\) at altitude \\(h\\) is given by: \\[ g(h) = \\frac{GM}{(R_E + h)^2} \\] 2.4 Gravitational Parameter of Earth (GM Value) The gravitational parameter \\(\\mu\\) (also called standard gravitational parameter) is defined as: \\[ \\mu = GM \\] where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the Earth. Numerically: \\[ \\mu \\approx 3.986 \\times 10^{14} \\, \\text{m}^3 \\, \\text{s}^{-2} \\] Using \\(\\mu\\) simplifies many orbital mechanics equations, for instance: Specific mechanical energy: \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{\\mu}{r} \\] Orbital velocity at a distance \\(r\\) for circular orbit: \\[ v_{\\text{circ}} = \\sqrt{\\frac{\\mu}{r}} \\] Escape velocity from distance \\(r\\) : \\[ v_{\\text{esc}} = \\sqrt{\\frac{2\\mu}{r}} \\] Knowledge of \\(\\mu\\) enables precise calculations of the payload\u2019s motion and trajectory classification. 3. Trajectory Analysis Understanding the trajectory of a payload released near Earth involves deriving its equations of motion under gravitational forces, analyzing specific orbital energy, and considering the influence of initial velocity magnitude and direction. 3.1 Equations of Motion (Second-Order Differential Equations) The motion of a payload under Earth's gravity is governed by Newton\u2019s Second Law: \\[ \\vec{F} = m \\vec{a} \\] Substituting the gravitational force: \\[ m \\vec{a} = -G \\frac{Mm}{r^2} \\hat{r} \\] Simplifying: \\[ \\vec{a} = -\\frac{\\mu}{r^2} \\hat{r} \\] where \\(\\mu = GM\\) is the standard gravitational parameter. In Cartesian coordinates \\((x, y, z)\\) , the second-order differential equations of motion are: \\[ \\ddot{x} = -\\frac{\\mu x}{(x^2 + y^2 + z^2)^{3/2}} \\] \\[ \\ddot{y} = -\\frac{\\mu y}{(x^2 + y^2 + z^2)^{3/2}} \\] \\[ \\ddot{z} = -\\frac{\\mu z}{(x^2 + y^2 + z^2)^{3/2}} \\] where \\(\\ddot{x}\\) , \\(\\ddot{y}\\) , and \\(\\ddot{z}\\) are the second derivatives of position with respect to time (accelerations). These equations describe the continuous motion of the payload influenced solely by Earth's gravitational field. 3.2 Specific Orbital Energy and Trajectory Classification The specific mechanical energy \\(\\varepsilon\\) is the sum of the specific kinetic and specific potential energies: \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{\\mu}{r} \\] where: - \\(v\\) is the magnitude of the velocity vector, - \\(r\\) is the radial distance from Earth's center. Classification based on \\(\\varepsilon\\) : - Elliptical Orbit (Bound) : $$ \\varepsilon < 0 $$ The payload remains gravitationally bound to Earth, following a closed, elliptical path. Parabolic Trajectory (Escape at Minimum Energy) : $$ \\varepsilon = 0 $$ The payload reaches exactly escape velocity and follows a parabolic trajectory, escaping Earth's gravity without excess energy. Hyperbolic Trajectory (Escape with Excess Energy) : $$ \\varepsilon > 0 $$ The payload escapes Earth's gravity with surplus kinetic energy, following an open hyperbolic path. 3.3 Effect of Initial Velocity Direction and Magnitude The initial velocity \\(\\vec{v}_0\\) relative to the local horizontal plane significantly influences the resulting trajectory: Purely Horizontal Launch : When the velocity is tangential to the surface (local horizontal), Enables orbital motion (circular or elliptical) if the speed is appropriate. Purely Radial Launch : When the velocity is directed straight outward or inward, Leads to vertical ascent or descent, If \\(v_0 \\geq v_{\\text{esc}}\\) , the object escapes along a parabolic or hyperbolic path. Mixed Direction Launch : A combination of radial and tangential components, Creates general elliptical or hyperbolic trajectories, The trajectory\u2019s shape and energy depend on the proportion of radial versus tangential velocity components. Decomposition of Initial Velocity: Given an angle \\(\\alpha\\) between the initial velocity vector and the local horizontal: \\[ v_{r,0} = v_0 \\sin(\\alpha) \\] \\[ v_{\\theta,0} = v_0 \\cos(\\alpha) \\] where: - \\(v_{r,0}\\) is the initial radial velocity component, - \\(v_{\\theta,0}\\) is the initial tangential (horizontal) velocity component. The effective orbital behavior thus depends on both the magnitude and the angle of the initial velocity. 3.4 Summary Accurately setting up the equations of motion and understanding specific orbital energy are fundamental for classifying the payload\u2019s trajectory after release. The initial velocity vector\u2019s magnitude and direction relative to the local horizontal critically determine whether the payload will: - Remain in orbit, - Fall back to Earth, - Escape Earth's gravitational influence entirely. 4. Numerical Simulation Setup Numerical simulations are essential for modeling the trajectory of a payload released near Earth. Due to the nonlinear nature of gravitational acceleration, analytical solutions are often impractical for general initial conditions, necessitating the use of numerical integration techniques. 4.1 Choosing a Numerical Integration Method The equations of motion derived earlier form a system of second-order ordinary differential equations (ODEs). To solve them numerically, it is standard practice to transform them into a system of first-order ODEs by introducing velocity components as independent variables. Let: \\[ \\vec{r} = (x, y, z), \\quad \\vec{v} = (\\dot{x}, \\dot{y}, \\dot{z}) \\] Then the system becomes: \\[ \\dot{\\vec{r}} = \\vec{v} \\] \\[ \\dot{\\vec{v}} = -\\frac{\\mu}{r^3} \\vec{r} \\] where \\(r = \\|\\vec{r}\\|\\) . Recommended Numerical Methods: Euler's Method (First-order accuracy): Simple but prone to large errors over time. Only suitable for very small time steps. Runge-Kutta Methods : Runge-Kutta 2nd Order (RK2) : Moderate accuracy, relatively easy to implement. Runge-Kutta 4th Order (RK4) : High accuracy, widely used for orbit simulations. Runge-Kutta 4th Order (RK4) algorithm for advancing from \\(t_n\\) to \\(t_{n+1} = t_n + \\Delta t\\) : \\[ \\begin{aligned} k_1 &= f(t_n, y_n) \\\\ k_2 &= f\\left(t_n + \\frac{\\Delta t}{2}, y_n + \\frac{\\Delta t}{2}k_1\\right) \\\\ k_3 &= f\\left(t_n + \\frac{\\Delta t}{2}, y_n + \\frac{\\Delta t}{2}k_2\\right) \\\\ k_4 &= f\\left(t_n + \\Delta t, y_n + \\Delta t \\, k_3\\right) \\\\ y_{n+1} &= y_n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4) \\end{aligned} \\] where \\(y\\) represents the state vector containing both \\(\\vec{r}\\) and \\(\\vec{v}\\) . 4.2 Time-Stepping and Tolerances for Numerical Accuracy The choice of time step \\(\\Delta t\\) is crucial: - If \\(\\Delta t\\) is too large, the simulation will suffer from significant numerical errors (e.g., energy drift). - If \\(\\Delta t\\) is too small, the simulation will be accurate but computationally expensive. Typical considerations: - Adaptive time-stepping can be employed, adjusting \\(\\Delta t\\) based on local truncation error estimates. - Otherwise, use a fixed \\(\\Delta t\\) small enough to accurately resolve the motion: Rule of thumb: \\(\\Delta t\\) should be at least \\(1000\\) times smaller than the orbital period for stable simulations. Tolerance settings (if using adaptive methods like Runge-Kutta-Fehlberg): - Relative Tolerance \\(\\sim 10^{-9}\\) - Absolute Tolerance \\(\\sim 10^{-12}\\) Maintaining energy conservation can serve as a good diagnostic for checking numerical accuracy. 4.3 Simplifications: Accounting Only for Earth's Gravity In this model: - Only central gravitational force from Earth is considered. - Atmospheric drag , solar radiation pressure , third-body effects (e.g., Moon, Sun) are ignored unless specified otherwise. The governing acceleration thus remains: \\[ \\vec{a} = -\\frac{\\mu}{r^3} \\vec{r} \\] Assumptions: - Earth is treated as a perfect sphere. - Earth's rotation effects (like Coriolis or centrifugal forces) are neglected unless explicitly modeled in a rotating reference frame. - No oblateness (no \\(J_2\\) perturbation). This simplifies the dynamics to a classic two-body problem under Newtonian gravity. 4.4 Summary For accurate simulation of a payload\u2019s trajectory near Earth: - Use Runge-Kutta 4th order method for numerical integration. - Choose appropriate time step sizes and consider adaptive time-stepping for high accuracy. - Focus solely on Earth\u2019s gravitational attraction unless additional forces are explicitly required. Proper numerical setup ensures reliable, physically consistent simulations essential for analyzing orbital dynamics. 5. Computational Tool and Visualization Calculate \\(v_{\\text{circ}}\\) and \\(v_{\\text{esc}}\\) for 1000 km altitude once and print/display them: r0 = R_earth + 1_000_000 # 1000 km altitude v_circ = np.sqrt(G*M_earth/r0) v_esc = np.sqrt(2*G*M_earth/r0) print(f\"Circular orbital velocity at 1000 km: {v_circ/1000:.2f} km/s\") print(f\"Escape velocity at 1000 km: {v_esc/1000:.2f} km/s\") 5.1 Crashing or Suborbital Trajectories import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M_earth = 5.972e24 R_earth = 6.371e6 # Simulation function def simulate_orbit(v0, steps=100000, dt=1): r0 = R_earth + 1_000_000 # 1000 km above surface x, y = r0, 0 vx, vy = 0, v0 pos = [] r_min, r_max = float('inf'), 0 escaped = False for _ in range(steps): r = np.sqrt(x**2 + y**2) if r < R_earth: break pos.append((x, y)) a = -G * M_earth / r**2 ax = a * x / r ay = a * y / r vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt r_min = min(r_min, r) r_max = max(r_max, r) if r > 20 * R_earth: escaped = True break return np.array(pos), r_min, r_max, escaped # Part 1: Low velocities (crash back) velocities = [4000, 5000, 6000, 7000, 8000] # m/s plt.figure(figsize=(8,8)) theta = np.linspace(0, 2*np.pi, 100) # plt.fill(R_earth*np.cos(theta), R_earth*np.sin(theta), color='lightblue', label='Earth') plt.fill(R_earth*np.cos(theta)/1000, R_earth*np.sin(theta)/1000, color='lightblue', label='Earth') plt.plot(0, 0, 'oy', label='Center of Earth') for v0 in velocities: traj, r_min, r_max, escaped = simulate_orbit(v0) x, y = traj[:,0], traj[:,1] # plt.plot(x, y, label=f'{v0/1000:.1f} km/s') plt.plot(x/1000, y/1000, label=f'{v0/1000:.1f} km/s') print(f\"v0={v0/1000:.1f} km/s | Perigee: {r_min/1000:.1f} km | Apogee: {r_max/1000:.1f} km | Escaped: {escaped}\") plt.title('Low Velocities: Crashing/Short Trajectories') plt.xlabel('x [km]') plt.ylabel('y [km]') plt.legend() plt.grid() plt.axis('equal') plt.show() 5.2 Circular and Elliptical Orbits (Bounded) import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M_earth = 5.972e24 R_earth = 6.371e6 # Simulation function def simulate_orbit(v0, steps=100000, dt=1): r0 = R_earth + 1_000_000 # 1000 km above surface x, y = r0, 0 vx, vy = 0, v0 pos = [] r_min, r_max = float('inf'), 0 escaped = False for _ in range(steps): r = np.sqrt(x**2 + y**2) if r < R_earth: break pos.append((x, y)) a = -G * M_earth / r**2 ax = a * x / r ay = a * y / r vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt r_min = min(r_min, r) r_max = max(r_max, r) if r > 20 * R_earth: escaped = True break return np.array(pos), r_min, r_max, escaped # Part 2: Medium velocities (orbiting) velocities = [9000, 9100, 9200, 9300, 9400, 9500, 9600, 9700, 9800, 9900, 10000] # m/s plt.figure(figsize=(8,8)) theta = np.linspace(0, 2*np.pi, 100) # plt.fill(R_earth*np.cos(theta), R_earth*np.sin(theta), color='lightblue', label='Earth') plt.fill(R_earth*np.cos(theta)/1000, R_earth*np.sin(theta)/1000, color='lightblue', label='Earth') plt.plot(0, 0, 'oy', label='Center of Earth') for v0 in velocities: traj, r_min, r_max, escaped = simulate_orbit(v0) x, y = traj[:,0], traj[:,1] # plt.plot(x, y, label=f'{v0/1000:.1f} km/s') plt.plot(x/1000, y/1000, label=f'{v0/1000:.1f} km/s') print(f\"v0={v0/1000:.1f} km/s | Perigee: {r_min/1000:.1f} km | Apogee: {r_max/1000:.1f} km | Escaped: {escaped}\") plt.title('Medium Velocities: Circular/Elliptical Orbits') plt.xlabel('x [km]') plt.ylabel('y [km]') plt.legend() plt.grid() plt.axis('equal') plt.show() 5.3 Escape Trajectories import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M_earth = 5.972e24 R_earth = 6.371e6 # Simulation function def simulate_orbit(v0, steps=100000, dt=1): r0 = R_earth + 1_000_000 # 1000 km above surface x, y = r0, 0 vx, vy = 0, v0 pos = [] r_min, r_max = float('inf'), 0 escaped = False for _ in range(steps): r = np.sqrt(x**2 + y**2) if r < R_earth: break pos.append((x, y)) a = -G * M_earth / r**2 ax = a * x / r ay = a * y / r vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt r_min = min(r_min, r) r_max = max(r_max, r) if r > 20 * R_earth: escaped = True break return np.array(pos), r_min, r_max, escaped # Part 3: High velocities (escape trajectories) velocities = [11000, 12000, 13000, 14000, 15000, 16000, 17000, 18000, 19000, 20000] # m/s plt.figure(figsize=(8,8)) theta = np.linspace(0, 2*np.pi, 100) # plt.fill(R_earth*np.cos(theta), R_earth*np.sin(theta), color='lightblue', label='Earth') plt.fill(R_earth*np.cos(theta)/1000, R_earth*np.sin(theta)/1000, color='lightblue', label='Earth') plt.plot(0, 0, 'oy', label='Center of Earth') for v0 in velocities: traj, r_min, r_max, escaped = simulate_orbit(v0) x, y = traj[:,0], traj[:,1] # plt.plot(x, y, label=f'{v0/1000:.1f} km/s') plt.plot(x/1000, y/1000, label=f'{v0/1000:.1f} km/s') print(f\"v0={v0/1000:.1f} km/s | Perigee: {r_min/1000:.1f} km | Apogee: {r_max/1000:.1f} km | Escaped: {escaped}\") plt.title('High Velocities: Escape Trajectories') plt.xlabel('x [km]') plt.ylabel('y [km]') plt.legend() plt.grid() plt.axis('equal') plt.show() 5.4 3D View from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(figsize=(10, 8)) ax = fig.add_subplot(111, projection='3d') ax.plot(x/1000, y/1000, np.zeros_like(x), label='Payload Trajectory') ax.scatter(0, 0, 0, color='blue', s=500, label='Earth') ax.set_xlabel('x (km)') ax.set_ylabel('y (km)') ax.set_zlabel('z (km)') ax.set_title('3D Trajectory Plot (Flat Plane)') ax.legend() plt.show() 5.5 Colab Souce Code 6. Discussion and Interpretation The trajectory of a payload released near Earth is determined primarily by its initial speed relative to the local horizontal direction. Different regimes of initial speed result in fundamentally different behaviors, each with important implications for space missions and engineering. 6.1 Physical Behavior at Different Initial Speeds 1. Below Orbital Speed If the initial speed \\(v_0\\) is less than the required orbital speed \\(v_{\\text{circ}}\\) , the payload does not achieve a stable orbit. Instead, gravitational attraction dominates and the payload: Follows a suborbital or ballistic trajectory, Ascends to a maximum altitude and then falls back toward Earth, Example: Suborbital flights like early test rockets or ballistic missile paths. Mathematically: \\[ v_0 < \\sqrt{\\frac{\\mu}{r_0}} \\] where: - \\(\\mu\\) is the Earth's gravitational parameter, - \\(r_0\\) is the initial distance from Earth's center. 2. At Orbital Speed If \\(v_0\\) is equal to the circular orbital speed: \\[ v_0 = \\sqrt{\\frac{\\mu}{r_0}} \\] then the payload enters a circular orbit around Earth, maintaining a constant altitude. If the launch is at a different angle or slightly different magnitude, the payload can enter an elliptical orbit instead, characterized by varying altitude between perigee (closest approach) and apogee (farthest point). Characteristics: - Circular orbit : constant radius \\(r\\) . - Elliptical orbit : varying radius, energy still negative ( \\(\\varepsilon < 0\\) ). 3. Above Escape Speed If the initial speed \\(v_0\\) exceeds the escape velocity \\(v_{\\text{esc}}\\) , the payload overcomes Earth's gravitational binding energy. Escape velocity: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2\\mu}{r_0}} \\] Two cases arise: - Exactly at escape velocity : - The payload follows a parabolic trajectory ( \\(\\varepsilon = 0\\) ). - It barely escapes, reaching infinite distance with zero residual velocity. Above escape velocity : The payload follows a hyperbolic trajectory ( \\(\\varepsilon > 0\\) ). It escapes Earth with surplus kinetic energy and continues moving indefinitely. 6.2 Real-World Applications Understanding the link between initial speed and trajectory is crucial in space engineering and operations: 1. Satellite Deployment Precise insertion into orbit requires achieving the correct orbital velocity. Slight deviations result in elliptical or unstable orbits. Low Earth Orbit (LEO) satellites typically require speeds around \\(7.8 \\, \\text{km/s}\\) at an altitude of about \\(300 \\, \\text{km}\\) . 2. Spacecraft Reentry Planning For reentry missions (e.g., returning astronauts or probes): Controlled reduction of orbital speed ensures the spacecraft descends safely. Reentry corridors must be carefully calculated to avoid burning up or bouncing off the atmosphere. 3. Space Escape Maneuvers Missions escaping Earth (e.g., missions to the Moon, Mars) must achieve escape velocity. Upper rocket stages are used to provide the additional speed required beyond orbital velocity. Example: Apollo missions required a Trans-Lunar Injection (TLI) maneuver to leave Earth's gravitational influence. 6.3 Summary The initial velocity of a released payload dictates whether it: - Falls back to Earth , - Enters stable orbit , - Escapes Earth's gravity . Mastering these relationships is fundamental for designing satellite deployments, planning space missions, and ensuring the success of reentry and escape trajectories. 7. Conclusion In this study, we explored the dynamics of payloads released near Earth under the influence of gravitational forces. Through theoretical analysis, numerical simulations, and visualizations, we classified possible trajectories into ballistic, orbital, and escape paths. The results underscore the critical dependence of trajectory type on initial velocity magnitude and direction. These findings have direct applications in satellite deployment, reentry planning, and interplanetary mission design, highlighting the importance of precise velocity control in space operations.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"Trajectories of a Freely Released Payload Near Earth","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-physics-and-mathematical-foundations","text":"","title":"1. Physics and Mathematical Foundations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#11-newtons-law-of-gravitation","text":"Newton\u2019s Law of Gravitation states that every mass attracts every other mass with a force \\(F\\) given by: \\[ F = G \\frac{m_1 m_2}{r^2} \\] where: - \\(F\\) is the gravitational force, - \\(G\\) is the gravitational constant ( \\(G \\approx 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ), - \\(m_1\\) and \\(m_2\\) are the masses of the two objects, - \\(r\\) is the distance between the centers of the two masses. The gravitational force acts along the line joining the two masses.","title":"1.1 Newton\u2019s Law of Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#12-newtons-second-law-applied-to-gravity","text":"Newton's Second Law states that the force on an object is proportional to its acceleration: \\[ \\vec{F} = m \\vec{a} \\] Applying this to gravitational force: \\[ m \\vec{a} = -G \\frac{M m}{r^2} \\hat{r} \\] Simplifying: \\[ \\vec{a} = -G \\frac{M}{r^2} \\hat{r} \\] where: - \\(\\vec{a}\\) is the acceleration vector, - \\(M\\) is the mass of the Earth, - \\(\\hat{r}\\) is the unit vector pointing from the payload to the Earth's center. This acceleration governs the motion of a freely falling payload near Earth.","title":"1.2 Newton\u2019s Second Law Applied to Gravity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#13-conic-sections-and-trajectory-classification","text":"The path followed by the payload is a conic section determined by the total specific mechanical energy \\(\\varepsilon\\) : \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] where: - \\(v\\) is the magnitude of velocity, - \\(r\\) is the radial distance from Earth's center. The type of trajectory depends on \\(\\varepsilon\\) : - If \\(\\varepsilon < 0\\) , the trajectory is elliptical (bound orbit). - If \\(\\varepsilon = 0\\) , the trajectory is parabolic (escape at exactly escape velocity). - If \\(\\varepsilon > 0\\) , the trajectory is hyperbolic (escape with surplus energy). The general equation for conic sections in polar coordinates: \\[ r(\\theta) = \\frac{p}{1 + e \\cos(\\theta)} \\] where: - \\(p\\) is the semi-latus rectum, - \\(e\\) is the eccentricity: - \\(0 \\leq e < 1\\) for an ellipse, - \\(e = 1\\) for a parabola, - \\(e > 1\\) for a hyperbola.","title":"1.3 Conic Sections and Trajectory Classification"},{"location":"1%20Physics/2%20Gravity/Problem_3/#14-orbital-energy-specific-mechanical-energy","text":"Specific mechanical energy \\(\\varepsilon\\) combines kinetic and potential energy per unit mass: \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] where: - Positive \\(\\varepsilon\\) implies unbound (hyperbolic) motion, - Zero \\(\\varepsilon\\) corresponds to parabolic escape, - Negative \\(\\varepsilon\\) indicates a bound (elliptical) orbit. The escape velocity \\(v_{\\text{esc}}\\) is derived by setting \\(\\varepsilon = 0\\) : \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] Thus, if the initial velocity \\(v > v_{\\text{esc}}\\) , the payload will escape Earth\u2019s gravity.","title":"1.4 Orbital Energy (Specific Mechanical Energy)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#15-keplers-laws-of-planetary-motion","text":"First Law (Law of Ellipses) : Every orbit of a planet or object is an ellipse with the center of mass at one of the two foci. Second Law (Law of Equal Areas) : A line joining a planet and the Sun sweeps out equal areas during equal intervals of time. Mathematically: $$ \\frac{dA}{dt} = \\text{constant} $$ where \\(A\\) is the area swept out. Third Law (Law of Harmonies) : The square of the orbital period \\(T\\) is proportional to the cube of the semi-major axis \\(a\\) : $$ T^2 \\propto a^3 $$ or more precisely: $$ T^2 = \\frac{4\\pi^2}{GM} a^3 $$ These laws govern the orbital behavior of payloads near Earth and help predict future positions and velocities.","title":"1.5 Kepler\u2019s Laws of Planetary Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-identify-and-define-initial-conditions","text":"To model and simulate the trajectory of a payload released near Earth, it is essential to specify the initial conditions precisely. These parameters determine the entire motion under gravitational forces.","title":"2. Identify and Define Initial Conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#21-initial-position-vector-relative-to-earths-center","text":"The initial position \\(\\vec{r}_0\\) of the payload is given relative to the center of Earth: \\[ \\vec{r}_0 = (x_0, y_0, z_0) \\] where: - \\(x_0\\) , \\(y_0\\) , and \\(z_0\\) are the Cartesian coordinates of the payload in an inertial reference frame, - Alternatively, the position can be expressed in polar coordinates \\((r_0, \\theta_0, \\phi_0)\\) : - \\(r_0\\) is the radial distance from Earth's center, - \\(\\theta_0\\) is the azimuthal angle (longitude), - \\(\\phi_0\\) is the polar angle (colatitude). For many problems, assuming motion in a plane (e.g., equatorial plane) simplifies calculations by setting \\(z_0 = 0\\) .","title":"2.1 Initial Position (Vector Relative to Earth\u2019s Center)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#22-initial-velocity-vector-at-release","text":"The initial velocity \\(\\vec{v}_0\\) of the payload must be defined with both magnitude and direction: \\[ \\vec{v}_0 = (v_{x,0}, v_{y,0}, v_{z,0}) \\] or alternatively in polar terms: \\[ \\vec{v}_0 = v_{r,0} \\hat{r} + v_{\\theta,0} \\hat{\\theta} \\] where: - \\(v_{r,0}\\) is the radial component (along \\(\\hat{r}\\) ), - \\(v_{\\theta,0}\\) is the transverse component (perpendicular to \\(\\hat{r}\\) in the orbital plane). The initial velocity vector relative to the local horizontal critically determines the type of trajectory: - Purely radial launch ( \\(v_{\\theta,0} = 0\\) ) results in a straight path, - Purely tangential launch ( \\(v_{r,0} = 0\\) ) can lead to circular or elliptical orbits, - Mixed radial and tangential velocities create general elliptical, hyperbolic, or parabolic paths.","title":"2.2 Initial Velocity (Vector at Release)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#23-initial-altitude-above-earths-surface","text":"The altitude \\(h_0\\) is the height of the payload above the Earth's surface: \\[ h_0 = r_0 - R_E \\] where: - \\(r_0\\) is the distance from the Earth's center, - \\(R_E\\) is the radius of the Earth ( \\(R_E \\approx 6371 \\, \\text{km}\\) ). The altitude is crucial because it influences the local gravitational force magnitude. The local gravitational acceleration \\(g(h)\\) at altitude \\(h\\) is given by: \\[ g(h) = \\frac{GM}{(R_E + h)^2} \\]","title":"2.3 Initial Altitude Above Earth\u2019s Surface"},{"location":"1%20Physics/2%20Gravity/Problem_3/#24-gravitational-parameter-of-earth-gm-value","text":"The gravitational parameter \\(\\mu\\) (also called standard gravitational parameter) is defined as: \\[ \\mu = GM \\] where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the Earth. Numerically: \\[ \\mu \\approx 3.986 \\times 10^{14} \\, \\text{m}^3 \\, \\text{s}^{-2} \\] Using \\(\\mu\\) simplifies many orbital mechanics equations, for instance: Specific mechanical energy: \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{\\mu}{r} \\] Orbital velocity at a distance \\(r\\) for circular orbit: \\[ v_{\\text{circ}} = \\sqrt{\\frac{\\mu}{r}} \\] Escape velocity from distance \\(r\\) : \\[ v_{\\text{esc}} = \\sqrt{\\frac{2\\mu}{r}} \\] Knowledge of \\(\\mu\\) enables precise calculations of the payload\u2019s motion and trajectory classification.","title":"2.4 Gravitational Parameter of Earth (GM Value)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-trajectory-analysis","text":"Understanding the trajectory of a payload released near Earth involves deriving its equations of motion under gravitational forces, analyzing specific orbital energy, and considering the influence of initial velocity magnitude and direction.","title":"3. Trajectory Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_3/#31-equations-of-motion-second-order-differential-equations","text":"The motion of a payload under Earth's gravity is governed by Newton\u2019s Second Law: \\[ \\vec{F} = m \\vec{a} \\] Substituting the gravitational force: \\[ m \\vec{a} = -G \\frac{Mm}{r^2} \\hat{r} \\] Simplifying: \\[ \\vec{a} = -\\frac{\\mu}{r^2} \\hat{r} \\] where \\(\\mu = GM\\) is the standard gravitational parameter. In Cartesian coordinates \\((x, y, z)\\) , the second-order differential equations of motion are: \\[ \\ddot{x} = -\\frac{\\mu x}{(x^2 + y^2 + z^2)^{3/2}} \\] \\[ \\ddot{y} = -\\frac{\\mu y}{(x^2 + y^2 + z^2)^{3/2}} \\] \\[ \\ddot{z} = -\\frac{\\mu z}{(x^2 + y^2 + z^2)^{3/2}} \\] where \\(\\ddot{x}\\) , \\(\\ddot{y}\\) , and \\(\\ddot{z}\\) are the second derivatives of position with respect to time (accelerations). These equations describe the continuous motion of the payload influenced solely by Earth's gravitational field.","title":"3.1 Equations of Motion (Second-Order Differential Equations)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#32-specific-orbital-energy-and-trajectory-classification","text":"The specific mechanical energy \\(\\varepsilon\\) is the sum of the specific kinetic and specific potential energies: \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{\\mu}{r} \\] where: - \\(v\\) is the magnitude of the velocity vector, - \\(r\\) is the radial distance from Earth's center. Classification based on \\(\\varepsilon\\) : - Elliptical Orbit (Bound) : $$ \\varepsilon < 0 $$ The payload remains gravitationally bound to Earth, following a closed, elliptical path. Parabolic Trajectory (Escape at Minimum Energy) : $$ \\varepsilon = 0 $$ The payload reaches exactly escape velocity and follows a parabolic trajectory, escaping Earth's gravity without excess energy. Hyperbolic Trajectory (Escape with Excess Energy) : $$ \\varepsilon > 0 $$ The payload escapes Earth's gravity with surplus kinetic energy, following an open hyperbolic path.","title":"3.2 Specific Orbital Energy and Trajectory Classification"},{"location":"1%20Physics/2%20Gravity/Problem_3/#33-effect-of-initial-velocity-direction-and-magnitude","text":"The initial velocity \\(\\vec{v}_0\\) relative to the local horizontal plane significantly influences the resulting trajectory: Purely Horizontal Launch : When the velocity is tangential to the surface (local horizontal), Enables orbital motion (circular or elliptical) if the speed is appropriate. Purely Radial Launch : When the velocity is directed straight outward or inward, Leads to vertical ascent or descent, If \\(v_0 \\geq v_{\\text{esc}}\\) , the object escapes along a parabolic or hyperbolic path. Mixed Direction Launch : A combination of radial and tangential components, Creates general elliptical or hyperbolic trajectories, The trajectory\u2019s shape and energy depend on the proportion of radial versus tangential velocity components.","title":"3.3 Effect of Initial Velocity Direction and Magnitude"},{"location":"1%20Physics/2%20Gravity/Problem_3/#decomposition-of-initial-velocity","text":"Given an angle \\(\\alpha\\) between the initial velocity vector and the local horizontal: \\[ v_{r,0} = v_0 \\sin(\\alpha) \\] \\[ v_{\\theta,0} = v_0 \\cos(\\alpha) \\] where: - \\(v_{r,0}\\) is the initial radial velocity component, - \\(v_{\\theta,0}\\) is the initial tangential (horizontal) velocity component. The effective orbital behavior thus depends on both the magnitude and the angle of the initial velocity.","title":"Decomposition of Initial Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#34-summary","text":"Accurately setting up the equations of motion and understanding specific orbital energy are fundamental for classifying the payload\u2019s trajectory after release. The initial velocity vector\u2019s magnitude and direction relative to the local horizontal critically determine whether the payload will: - Remain in orbit, - Fall back to Earth, - Escape Earth's gravitational influence entirely.","title":"3.4 Summary"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-numerical-simulation-setup","text":"Numerical simulations are essential for modeling the trajectory of a payload released near Earth. Due to the nonlinear nature of gravitational acceleration, analytical solutions are often impractical for general initial conditions, necessitating the use of numerical integration techniques.","title":"4. Numerical Simulation Setup"},{"location":"1%20Physics/2%20Gravity/Problem_3/#41-choosing-a-numerical-integration-method","text":"The equations of motion derived earlier form a system of second-order ordinary differential equations (ODEs). To solve them numerically, it is standard practice to transform them into a system of first-order ODEs by introducing velocity components as independent variables. Let: \\[ \\vec{r} = (x, y, z), \\quad \\vec{v} = (\\dot{x}, \\dot{y}, \\dot{z}) \\] Then the system becomes: \\[ \\dot{\\vec{r}} = \\vec{v} \\] \\[ \\dot{\\vec{v}} = -\\frac{\\mu}{r^3} \\vec{r} \\] where \\(r = \\|\\vec{r}\\|\\) .","title":"4.1 Choosing a Numerical Integration Method"},{"location":"1%20Physics/2%20Gravity/Problem_3/#recommended-numerical-methods","text":"Euler's Method (First-order accuracy): Simple but prone to large errors over time. Only suitable for very small time steps. Runge-Kutta Methods : Runge-Kutta 2nd Order (RK2) : Moderate accuracy, relatively easy to implement. Runge-Kutta 4th Order (RK4) : High accuracy, widely used for orbit simulations. Runge-Kutta 4th Order (RK4) algorithm for advancing from \\(t_n\\) to \\(t_{n+1} = t_n + \\Delta t\\) : \\[ \\begin{aligned} k_1 &= f(t_n, y_n) \\\\ k_2 &= f\\left(t_n + \\frac{\\Delta t}{2}, y_n + \\frac{\\Delta t}{2}k_1\\right) \\\\ k_3 &= f\\left(t_n + \\frac{\\Delta t}{2}, y_n + \\frac{\\Delta t}{2}k_2\\right) \\\\ k_4 &= f\\left(t_n + \\Delta t, y_n + \\Delta t \\, k_3\\right) \\\\ y_{n+1} &= y_n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4) \\end{aligned} \\] where \\(y\\) represents the state vector containing both \\(\\vec{r}\\) and \\(\\vec{v}\\) .","title":"Recommended Numerical Methods:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#42-time-stepping-and-tolerances-for-numerical-accuracy","text":"The choice of time step \\(\\Delta t\\) is crucial: - If \\(\\Delta t\\) is too large, the simulation will suffer from significant numerical errors (e.g., energy drift). - If \\(\\Delta t\\) is too small, the simulation will be accurate but computationally expensive. Typical considerations: - Adaptive time-stepping can be employed, adjusting \\(\\Delta t\\) based on local truncation error estimates. - Otherwise, use a fixed \\(\\Delta t\\) small enough to accurately resolve the motion: Rule of thumb: \\(\\Delta t\\) should be at least \\(1000\\) times smaller than the orbital period for stable simulations. Tolerance settings (if using adaptive methods like Runge-Kutta-Fehlberg): - Relative Tolerance \\(\\sim 10^{-9}\\) - Absolute Tolerance \\(\\sim 10^{-12}\\) Maintaining energy conservation can serve as a good diagnostic for checking numerical accuracy.","title":"4.2 Time-Stepping and Tolerances for Numerical Accuracy"},{"location":"1%20Physics/2%20Gravity/Problem_3/#43-simplifications-accounting-only-for-earths-gravity","text":"In this model: - Only central gravitational force from Earth is considered. - Atmospheric drag , solar radiation pressure , third-body effects (e.g., Moon, Sun) are ignored unless specified otherwise. The governing acceleration thus remains: \\[ \\vec{a} = -\\frac{\\mu}{r^3} \\vec{r} \\] Assumptions: - Earth is treated as a perfect sphere. - Earth's rotation effects (like Coriolis or centrifugal forces) are neglected unless explicitly modeled in a rotating reference frame. - No oblateness (no \\(J_2\\) perturbation). This simplifies the dynamics to a classic two-body problem under Newtonian gravity.","title":"4.3 Simplifications: Accounting Only for Earth's Gravity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#44-summary","text":"For accurate simulation of a payload\u2019s trajectory near Earth: - Use Runge-Kutta 4th order method for numerical integration. - Choose appropriate time step sizes and consider adaptive time-stepping for high accuracy. - Focus solely on Earth\u2019s gravitational attraction unless additional forces are explicitly required. Proper numerical setup ensures reliable, physically consistent simulations essential for analyzing orbital dynamics.","title":"4.4 Summary"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-computational-tool-and-visualization","text":"Calculate \\(v_{\\text{circ}}\\) and \\(v_{\\text{esc}}\\) for 1000 km altitude once and print/display them: r0 = R_earth + 1_000_000 # 1000 km altitude v_circ = np.sqrt(G*M_earth/r0) v_esc = np.sqrt(2*G*M_earth/r0) print(f\"Circular orbital velocity at 1000 km: {v_circ/1000:.2f} km/s\") print(f\"Escape velocity at 1000 km: {v_esc/1000:.2f} km/s\")","title":"5. Computational Tool and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_3/#51-crashing-or-suborbital-trajectories","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M_earth = 5.972e24 R_earth = 6.371e6 # Simulation function def simulate_orbit(v0, steps=100000, dt=1): r0 = R_earth + 1_000_000 # 1000 km above surface x, y = r0, 0 vx, vy = 0, v0 pos = [] r_min, r_max = float('inf'), 0 escaped = False for _ in range(steps): r = np.sqrt(x**2 + y**2) if r < R_earth: break pos.append((x, y)) a = -G * M_earth / r**2 ax = a * x / r ay = a * y / r vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt r_min = min(r_min, r) r_max = max(r_max, r) if r > 20 * R_earth: escaped = True break return np.array(pos), r_min, r_max, escaped # Part 1: Low velocities (crash back) velocities = [4000, 5000, 6000, 7000, 8000] # m/s plt.figure(figsize=(8,8)) theta = np.linspace(0, 2*np.pi, 100) # plt.fill(R_earth*np.cos(theta), R_earth*np.sin(theta), color='lightblue', label='Earth') plt.fill(R_earth*np.cos(theta)/1000, R_earth*np.sin(theta)/1000, color='lightblue', label='Earth') plt.plot(0, 0, 'oy', label='Center of Earth') for v0 in velocities: traj, r_min, r_max, escaped = simulate_orbit(v0) x, y = traj[:,0], traj[:,1] # plt.plot(x, y, label=f'{v0/1000:.1f} km/s') plt.plot(x/1000, y/1000, label=f'{v0/1000:.1f} km/s') print(f\"v0={v0/1000:.1f} km/s | Perigee: {r_min/1000:.1f} km | Apogee: {r_max/1000:.1f} km | Escaped: {escaped}\") plt.title('Low Velocities: Crashing/Short Trajectories') plt.xlabel('x [km]') plt.ylabel('y [km]') plt.legend() plt.grid() plt.axis('equal') plt.show()","title":"5.1 Crashing or Suborbital Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#52-circular-and-elliptical-orbits-bounded","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M_earth = 5.972e24 R_earth = 6.371e6 # Simulation function def simulate_orbit(v0, steps=100000, dt=1): r0 = R_earth + 1_000_000 # 1000 km above surface x, y = r0, 0 vx, vy = 0, v0 pos = [] r_min, r_max = float('inf'), 0 escaped = False for _ in range(steps): r = np.sqrt(x**2 + y**2) if r < R_earth: break pos.append((x, y)) a = -G * M_earth / r**2 ax = a * x / r ay = a * y / r vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt r_min = min(r_min, r) r_max = max(r_max, r) if r > 20 * R_earth: escaped = True break return np.array(pos), r_min, r_max, escaped # Part 2: Medium velocities (orbiting) velocities = [9000, 9100, 9200, 9300, 9400, 9500, 9600, 9700, 9800, 9900, 10000] # m/s plt.figure(figsize=(8,8)) theta = np.linspace(0, 2*np.pi, 100) # plt.fill(R_earth*np.cos(theta), R_earth*np.sin(theta), color='lightblue', label='Earth') plt.fill(R_earth*np.cos(theta)/1000, R_earth*np.sin(theta)/1000, color='lightblue', label='Earth') plt.plot(0, 0, 'oy', label='Center of Earth') for v0 in velocities: traj, r_min, r_max, escaped = simulate_orbit(v0) x, y = traj[:,0], traj[:,1] # plt.plot(x, y, label=f'{v0/1000:.1f} km/s') plt.plot(x/1000, y/1000, label=f'{v0/1000:.1f} km/s') print(f\"v0={v0/1000:.1f} km/s | Perigee: {r_min/1000:.1f} km | Apogee: {r_max/1000:.1f} km | Escaped: {escaped}\") plt.title('Medium Velocities: Circular/Elliptical Orbits') plt.xlabel('x [km]') plt.ylabel('y [km]') plt.legend() plt.grid() plt.axis('equal') plt.show()","title":"5.2 Circular and Elliptical Orbits (Bounded)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#53-escape-trajectories","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M_earth = 5.972e24 R_earth = 6.371e6 # Simulation function def simulate_orbit(v0, steps=100000, dt=1): r0 = R_earth + 1_000_000 # 1000 km above surface x, y = r0, 0 vx, vy = 0, v0 pos = [] r_min, r_max = float('inf'), 0 escaped = False for _ in range(steps): r = np.sqrt(x**2 + y**2) if r < R_earth: break pos.append((x, y)) a = -G * M_earth / r**2 ax = a * x / r ay = a * y / r vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt r_min = min(r_min, r) r_max = max(r_max, r) if r > 20 * R_earth: escaped = True break return np.array(pos), r_min, r_max, escaped # Part 3: High velocities (escape trajectories) velocities = [11000, 12000, 13000, 14000, 15000, 16000, 17000, 18000, 19000, 20000] # m/s plt.figure(figsize=(8,8)) theta = np.linspace(0, 2*np.pi, 100) # plt.fill(R_earth*np.cos(theta), R_earth*np.sin(theta), color='lightblue', label='Earth') plt.fill(R_earth*np.cos(theta)/1000, R_earth*np.sin(theta)/1000, color='lightblue', label='Earth') plt.plot(0, 0, 'oy', label='Center of Earth') for v0 in velocities: traj, r_min, r_max, escaped = simulate_orbit(v0) x, y = traj[:,0], traj[:,1] # plt.plot(x, y, label=f'{v0/1000:.1f} km/s') plt.plot(x/1000, y/1000, label=f'{v0/1000:.1f} km/s') print(f\"v0={v0/1000:.1f} km/s | Perigee: {r_min/1000:.1f} km | Apogee: {r_max/1000:.1f} km | Escaped: {escaped}\") plt.title('High Velocities: Escape Trajectories') plt.xlabel('x [km]') plt.ylabel('y [km]') plt.legend() plt.grid() plt.axis('equal') plt.show()","title":"5.3 Escape Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#54-3d-view","text":"from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(figsize=(10, 8)) ax = fig.add_subplot(111, projection='3d') ax.plot(x/1000, y/1000, np.zeros_like(x), label='Payload Trajectory') ax.scatter(0, 0, 0, color='blue', s=500, label='Earth') ax.set_xlabel('x (km)') ax.set_ylabel('y (km)') ax.set_zlabel('z (km)') ax.set_title('3D Trajectory Plot (Flat Plane)') ax.legend() plt.show()","title":"5.4 3D View"},{"location":"1%20Physics/2%20Gravity/Problem_3/#55-colab","text":"Souce Code","title":"5.5 Colab"},{"location":"1%20Physics/2%20Gravity/Problem_3/#6-discussion-and-interpretation","text":"The trajectory of a payload released near Earth is determined primarily by its initial speed relative to the local horizontal direction. Different regimes of initial speed result in fundamentally different behaviors, each with important implications for space missions and engineering.","title":"6. Discussion and Interpretation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#61-physical-behavior-at-different-initial-speeds","text":"","title":"6.1 Physical Behavior at Different Initial Speeds"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-below-orbital-speed","text":"If the initial speed \\(v_0\\) is less than the required orbital speed \\(v_{\\text{circ}}\\) , the payload does not achieve a stable orbit. Instead, gravitational attraction dominates and the payload: Follows a suborbital or ballistic trajectory, Ascends to a maximum altitude and then falls back toward Earth, Example: Suborbital flights like early test rockets or ballistic missile paths. Mathematically: \\[ v_0 < \\sqrt{\\frac{\\mu}{r_0}} \\] where: - \\(\\mu\\) is the Earth's gravitational parameter, - \\(r_0\\) is the initial distance from Earth's center.","title":"1. Below Orbital Speed"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-at-orbital-speed","text":"If \\(v_0\\) is equal to the circular orbital speed: \\[ v_0 = \\sqrt{\\frac{\\mu}{r_0}} \\] then the payload enters a circular orbit around Earth, maintaining a constant altitude. If the launch is at a different angle or slightly different magnitude, the payload can enter an elliptical orbit instead, characterized by varying altitude between perigee (closest approach) and apogee (farthest point). Characteristics: - Circular orbit : constant radius \\(r\\) . - Elliptical orbit : varying radius, energy still negative ( \\(\\varepsilon < 0\\) ).","title":"2. At Orbital Speed"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-above-escape-speed","text":"If the initial speed \\(v_0\\) exceeds the escape velocity \\(v_{\\text{esc}}\\) , the payload overcomes Earth's gravitational binding energy. Escape velocity: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2\\mu}{r_0}} \\] Two cases arise: - Exactly at escape velocity : - The payload follows a parabolic trajectory ( \\(\\varepsilon = 0\\) ). - It barely escapes, reaching infinite distance with zero residual velocity. Above escape velocity : The payload follows a hyperbolic trajectory ( \\(\\varepsilon > 0\\) ). It escapes Earth with surplus kinetic energy and continues moving indefinitely.","title":"3. Above Escape Speed"},{"location":"1%20Physics/2%20Gravity/Problem_3/#62-real-world-applications","text":"Understanding the link between initial speed and trajectory is crucial in space engineering and operations:","title":"6.2 Real-World Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-satellite-deployment","text":"Precise insertion into orbit requires achieving the correct orbital velocity. Slight deviations result in elliptical or unstable orbits. Low Earth Orbit (LEO) satellites typically require speeds around \\(7.8 \\, \\text{km/s}\\) at an altitude of about \\(300 \\, \\text{km}\\) .","title":"1. Satellite Deployment"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-spacecraft-reentry-planning","text":"For reentry missions (e.g., returning astronauts or probes): Controlled reduction of orbital speed ensures the spacecraft descends safely. Reentry corridors must be carefully calculated to avoid burning up or bouncing off the atmosphere.","title":"2. Spacecraft Reentry Planning"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-space-escape-maneuvers","text":"Missions escaping Earth (e.g., missions to the Moon, Mars) must achieve escape velocity. Upper rocket stages are used to provide the additional speed required beyond orbital velocity. Example: Apollo missions required a Trans-Lunar Injection (TLI) maneuver to leave Earth's gravitational influence.","title":"3. Space Escape Maneuvers"},{"location":"1%20Physics/2%20Gravity/Problem_3/#63-summary","text":"The initial velocity of a released payload dictates whether it: - Falls back to Earth , - Enters stable orbit , - Escapes Earth's gravity . Mastering these relationships is fundamental for designing satellite deployments, planning space missions, and ensuring the success of reentry and escape trajectories.","title":"6.3 Summary"},{"location":"1%20Physics/2%20Gravity/Problem_3/#7-conclusion","text":"In this study, we explored the dynamics of payloads released near Earth under the influence of gravitational forces. Through theoretical analysis, numerical simulations, and visualizations, we classified possible trajectories into ballistic, orbital, and escape paths. The results underscore the critical dependence of trajectory type on initial velocity magnitude and direction. These findings have direct applications in satellite deployment, reentry planning, and interplanetary mission design, highlighting the importance of precise velocity control in space operations.","title":"7. Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a water surface 1. Geometry Setup To study interference patterns, we start by placing point sources at the vertices of a regular polygon. 1.1 Regular Polygon A regular polygon has equal sides and angles. Let the number of sources be: $$ N \\geq 3 $$ 1.2 Vertex Coordinates Assume the polygon is inscribed in a circle centered at the origin with radius \\(R\\) . The angle between adjacent vertices is: $$ \\Delta \\theta = \\frac{2\\pi}{N}, \\quad \\theta_i = i \\Delta \\theta $$ Coordinates of the \\(i\\) -th vertex: $$ x_{0i} = R \\cos(\\theta_i), \\quad y_{0i} = R \\sin(\\theta_i) $$ 1.3 Choosing Radius \\(R\\) Radius \\(R\\) determines source spacing and pattern scale. A chord length of: $$ d = 2R \\sin\\left(\\frac{\\pi}{N}\\right) $$ Choosing \\(d \\sim (2-5) \\lambda\\) gives rich interference. 2. Wave Definition Each source emits a circular wave described by: $$ \\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t + \\phi) $$ Where \\(r_i = \\sqrt{(x - x_{0i})^2 + (y - y_{0i})^2}\\) is the distance from source \\(i\\) to point \\((x, y)\\) . Common assumptions: - All sources have same \\(A, k, \\omega, \\phi\\) . - Initial phase \\(\\phi = 0\\) . - Non-dispersive medium. 3. Superposition Principle Total displacement: $$ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t + \\phi) $$ Interference Conditions Constructive : \\(k(r_i - r_j) = 2n\\pi\\) Destructive : \\(k(r_i - r_j) = (2n + 1)\\pi\\) Patterns arise from the geometry and wave interactions. 4. Wave Parameters Amplitude ( \\(A\\) ) : maximum surface displacement. Wavelength ( \\(\\lambda\\) ) : defines wave number \\(k = 2\\pi/\\lambda\\) . Frequency ( \\(f\\) ) : defines \\(\\omega = 2\\pi f\\) . Phase ( \\(\\phi\\) ) : typically zero for all sources. These define wave behavior and interference scale. 5. Simulation Grid 5.1 Domain Choose spatial domain \\([x_{\\min}, x_{\\max}], [y_{\\min}, y_{\\max}]\\) large enough to capture wave effects: $$ (x_{\\max} - x_{\\min}) \\gtrsim 6\\lambda, \\quad (y_{\\max} - y_{\\min}) \\gtrsim 6\\lambda $$ 5.2 Resolution Grid spacing: $$ \\Delta x, \\Delta y \\leq \\frac{\\lambda}{10} $$ Construct grid using meshgrid in Python. 5.3 Boundary Effects Keep sources away from edges. Use absorbing or periodic boundaries as needed. 6. Time Component Each wave evolves in time: $$ \\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t + \\phi) $$ Visualization Modes Snapshot : Fixed \\(t = t_0\\) . Shows static interference. Animation : Vary \\(t\\) over interval with step \\(\\Delta t \\leq 1/(20f)\\) . Use animations or contour plots to show dynamics. 7. Visualization 7.1 Single Source \u2013 Static Wavefronts import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Wave parameters A = 1 lambda_ = 1 k = 2 * np.pi / lambda_ f = 1 omega = 2 * np.pi * f phi = 0 # Grid x = np.linspace(-5, 5, 400) y = np.linspace(-5, 5, 400) X, Y = np.meshgrid(x, y) r = np.sqrt((X - 0)**2 + (Y - 0)**2) # Setup plot fig, ax = plt.subplots() img = ax.imshow(np.zeros_like(X), extent=[-5, 5, -5, 5], cmap='viridis', origin='lower') plt.colorbar(img, ax=ax) ax.set_title(\"Single Source Wavefronts\") # Animation function def update(frame): t = frame / 20 eta = A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) img.set_data(eta) return [img] ani = animation.FuncAnimation(fig, update, frames=100, interval=50, blit=True) ani.save(\"single_source.gif\", writer=\"pillow\") plt.close() import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation # Parameters A = 1 lambda_ = 1 k = 2 * np.pi / lambda_ f = 1 omega = 2 * np.pi * f phi = 0 # Grid x = np.linspace(-5, 5, 150) y = np.linspace(-5, 5, 150) X, Y = np.meshgrid(x, y) r = np.sqrt((X - 0)**2 + (Y - 0)**2) # Setup plot fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') # Initialize the surface plot surf = ax.plot_surface(X, Y, np.zeros_like(X), cmap='viridis', edgecolor='none') ax.set_zlim(-2, 2) ax.set_title(\"Single Source \u2013 3D Animated Surface\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"Displacement\") def update(frame): global surf # Make surf accessible within the function t = frame / 20 eta = A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) # Remove the previous surface plot surf.remove() # Plot the new surface surf = ax.plot_surface(X, Y, eta, cmap='viridis', edgecolor='none') return [surf] # Return the updated surface ani = FuncAnimation(fig, update, frames=60, interval=100, blit=False) # blit=False is recommended for 3D animations ani.save(\"single_source_3d.gif\", writer=\"pillow\") plt.close() 7.2 Two Sources \u2013 Interference Pattern import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Wave parameters A = 1 lambda_ = 1 k = 2 * np.pi / lambda_ f = 1 omega = 2 * np.pi * f phi = 0 # Grid x = np.linspace(-5, 5, 400) y = np.linspace(-5, 5, 400) X, Y = np.meshgrid(x, y) # Two sources sources = [(-1.5, 0), (1.5, 0)] # Setup plot fig, ax = plt.subplots() img = ax.imshow(np.zeros_like(X), extent=[-5, 5, -5, 5], cmap='plasma', origin='lower') plt.colorbar(img, ax=ax) ax.set_title(\"Two Source Interference\") def update(frame): t = frame / 20 eta_sum = np.zeros_like(X) for x0, y0 in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_sum += A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) img.set_data(eta_sum) return [img] ani = animation.FuncAnimation(fig, update, frames=100, interval=50, blit=True) ani.save(\"two_sources.gif\", writer=\"pillow\") plt.close() import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation # Parameters A = 1 lambda_ = 1 k = 2 * np.pi / lambda_ f = 1 omega = 2 * np.pi * f phi = 0 # Grid x = np.linspace(-5, 5, 150) y = np.linspace(-5, 5, 150) X, Y = np.meshgrid(x, y) # Two source coordinates sources = [(-1.5, 0), (1.5, 0)] fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.set_zlim(-3, 3) ax.set_title(\"Two Sources \u2013 3D Animated Surface\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"Displacement\") # Initialize the surface plot outside the update function surf = ax.plot_surface(X, Y, np.zeros_like(X), cmap='plasma', edgecolor='none') def update(frame): global surf # Make surf accessible within the function t = frame / 20 eta_sum = np.zeros_like(X) for x0, y0 in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_sum += A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) # Remove the previous surface plot surf.remove() # Plot the new surface surf = ax.plot_surface(X, Y, eta_sum, cmap='plasma', edgecolor='none') return [surf] # Return the updated surface ani = FuncAnimation(fig, update, frames=60, interval=100, blit=False) # blit=False is recommended for 3D animations ani.save(\"two_sources_3d.gif\", writer=\"pillow\") plt.close() 7.3 Three Sources \u2013 Interference from Triangle Configuration import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Wave parameters A = 1 lambda_ = 1 k = 2 * np.pi / lambda_ f = 1 omega = 2 * np.pi * f phi = 0 # Grid x = np.linspace(-5, 5, 400) y = np.linspace(-5, 5, 400) X, Y = np.meshgrid(x, y) # Triangle config R = 2 sources = [(R * np.cos(2*np.pi*i/3), R * np.sin(2*np.pi*i/3)) for i in range(3)] fig, ax = plt.subplots() img = ax.imshow(np.zeros_like(X), extent=[-5, 5, -5, 5], cmap='inferno', origin='lower') plt.colorbar(img, ax=ax) ax.set_title(\"Triangle Interference \u2013 Three Sources\") def update(frame): t = frame / 20 eta_sum = np.zeros_like(X) for x0, y0 in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_sum += A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) img.set_data(eta_sum) return [img] ani = animation.FuncAnimation(fig, update, frames=100, interval=50, blit=True) ani.save(\"three_sources.gif\", writer=\"pillow\") plt.close() import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation # Parameters A = 1 lambda_ = 1 k = 2 * np.pi / lambda_ f = 1 omega = 2 * np.pi * f phi = 0 # Grid x = np.linspace(-5, 5, 150) y = np.linspace(-5, 5, 150) X, Y = np.meshgrid(x, y) # Triangle configuration R = 2 sources = [(R * np.cos(2 * np.pi * i / 3), R * np.sin(2 * np.pi * i / 3)) for i in range(3)] fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.set_zlim(-3, 3) ax.set_title(\"Three Sources \u2013 3D Animated Surface\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"Displacement\") # Initialize surface plot surf = ax.plot_surface(X, Y, np.zeros_like(X), cmap='inferno', edgecolor='none') def update(frame): global surf # Make surf accessible within the function t = frame / 20 eta_sum = np.zeros_like(X) for x0, y0 in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_sum += A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) # Remove the previous surface plot surf.remove() # Plot the new surface surf = ax.plot_surface(X, Y, eta_sum, cmap='inferno', edgecolor='none') return [surf] ani = FuncAnimation(fig, update, frames=60, interval=100, blit=False) # blit=False is important for 3D animations ani.save(\"three_sources_3d.gif\", writer=\"pillow\") plt.close() Colab: Waves Problem 1 Souce Code 8. Analysis Analyzing the resulting interference pattern reveals regions of amplification and cancellation. 8.1 Constructive Interference Occurs when waves are in phase: $$ k(r_i - r_j) = 2\\pi n $$ Leads to high displacement regions (bright fringes or peaks). 8.2 Destructive Interference Occurs when waves are out of phase: $$ k(r_i - r_j) = (2n + 1)\\pi $$ Leads to wave cancellation (dark zones or troughs). 8.3 Pattern Symmetry Pattern symmetry follows the polygon's geometry: - Two sources: symmetry about midpoint. - Three (triangle): \\(120^\\circ\\) rotational symmetry. - Four or more: increasing complexity, matching polygonal symmetry. 8.4 Visual Cues Bright ridges = constructive zones Dark lines = destructive zones Radial or rotational motifs reflect geometric layout Contours or threshold filters can aid interpretation.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"Interference Patterns on a water surface","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-geometry-setup","text":"To study interference patterns, we start by placing point sources at the vertices of a regular polygon.","title":"1. Geometry Setup"},{"location":"1%20Physics/3%20Waves/Problem_1/#11-regular-polygon","text":"A regular polygon has equal sides and angles. Let the number of sources be: $$ N \\geq 3 $$","title":"1.1 Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#12-vertex-coordinates","text":"Assume the polygon is inscribed in a circle centered at the origin with radius \\(R\\) . The angle between adjacent vertices is: $$ \\Delta \\theta = \\frac{2\\pi}{N}, \\quad \\theta_i = i \\Delta \\theta $$ Coordinates of the \\(i\\) -th vertex: $$ x_{0i} = R \\cos(\\theta_i), \\quad y_{0i} = R \\sin(\\theta_i) $$","title":"1.2 Vertex Coordinates"},{"location":"1%20Physics/3%20Waves/Problem_1/#13-choosing-radius-r","text":"Radius \\(R\\) determines source spacing and pattern scale. A chord length of: $$ d = 2R \\sin\\left(\\frac{\\pi}{N}\\right) $$ Choosing \\(d \\sim (2-5) \\lambda\\) gives rich interference.","title":"1.3 Choosing Radius \\(R\\)"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-wave-definition","text":"Each source emits a circular wave described by: $$ \\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t + \\phi) $$ Where \\(r_i = \\sqrt{(x - x_{0i})^2 + (y - y_{0i})^2}\\) is the distance from source \\(i\\) to point \\((x, y)\\) . Common assumptions: - All sources have same \\(A, k, \\omega, \\phi\\) . - Initial phase \\(\\phi = 0\\) . - Non-dispersive medium.","title":"2. Wave Definition"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-superposition-principle","text":"Total displacement: $$ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t + \\phi) $$","title":"3. Superposition Principle"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-conditions","text":"Constructive : \\(k(r_i - r_j) = 2n\\pi\\) Destructive : \\(k(r_i - r_j) = (2n + 1)\\pi\\) Patterns arise from the geometry and wave interactions.","title":"Interference Conditions"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-wave-parameters","text":"Amplitude ( \\(A\\) ) : maximum surface displacement. Wavelength ( \\(\\lambda\\) ) : defines wave number \\(k = 2\\pi/\\lambda\\) . Frequency ( \\(f\\) ) : defines \\(\\omega = 2\\pi f\\) . Phase ( \\(\\phi\\) ) : typically zero for all sources. These define wave behavior and interference scale.","title":"4. Wave Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-simulation-grid","text":"","title":"5. Simulation Grid"},{"location":"1%20Physics/3%20Waves/Problem_1/#51-domain","text":"Choose spatial domain \\([x_{\\min}, x_{\\max}], [y_{\\min}, y_{\\max}]\\) large enough to capture wave effects: $$ (x_{\\max} - x_{\\min}) \\gtrsim 6\\lambda, \\quad (y_{\\max} - y_{\\min}) \\gtrsim 6\\lambda $$","title":"5.1 Domain"},{"location":"1%20Physics/3%20Waves/Problem_1/#52-resolution","text":"Grid spacing: $$ \\Delta x, \\Delta y \\leq \\frac{\\lambda}{10} $$ Construct grid using meshgrid in Python.","title":"5.2 Resolution"},{"location":"1%20Physics/3%20Waves/Problem_1/#53-boundary-effects","text":"Keep sources away from edges. Use absorbing or periodic boundaries as needed.","title":"5.3 Boundary Effects"},{"location":"1%20Physics/3%20Waves/Problem_1/#6-time-component","text":"Each wave evolves in time: $$ \\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t + \\phi) $$","title":"6. Time Component"},{"location":"1%20Physics/3%20Waves/Problem_1/#visualization-modes","text":"Snapshot : Fixed \\(t = t_0\\) . Shows static interference. Animation : Vary \\(t\\) over interval with step \\(\\Delta t \\leq 1/(20f)\\) . Use animations or contour plots to show dynamics.","title":"Visualization Modes"},{"location":"1%20Physics/3%20Waves/Problem_1/#7-visualization","text":"","title":"7. Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#71-single-source-static-wavefronts","text":"import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Wave parameters A = 1 lambda_ = 1 k = 2 * np.pi / lambda_ f = 1 omega = 2 * np.pi * f phi = 0 # Grid x = np.linspace(-5, 5, 400) y = np.linspace(-5, 5, 400) X, Y = np.meshgrid(x, y) r = np.sqrt((X - 0)**2 + (Y - 0)**2) # Setup plot fig, ax = plt.subplots() img = ax.imshow(np.zeros_like(X), extent=[-5, 5, -5, 5], cmap='viridis', origin='lower') plt.colorbar(img, ax=ax) ax.set_title(\"Single Source Wavefronts\") # Animation function def update(frame): t = frame / 20 eta = A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) img.set_data(eta) return [img] ani = animation.FuncAnimation(fig, update, frames=100, interval=50, blit=True) ani.save(\"single_source.gif\", writer=\"pillow\") plt.close() import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation # Parameters A = 1 lambda_ = 1 k = 2 * np.pi / lambda_ f = 1 omega = 2 * np.pi * f phi = 0 # Grid x = np.linspace(-5, 5, 150) y = np.linspace(-5, 5, 150) X, Y = np.meshgrid(x, y) r = np.sqrt((X - 0)**2 + (Y - 0)**2) # Setup plot fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') # Initialize the surface plot surf = ax.plot_surface(X, Y, np.zeros_like(X), cmap='viridis', edgecolor='none') ax.set_zlim(-2, 2) ax.set_title(\"Single Source \u2013 3D Animated Surface\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"Displacement\") def update(frame): global surf # Make surf accessible within the function t = frame / 20 eta = A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) # Remove the previous surface plot surf.remove() # Plot the new surface surf = ax.plot_surface(X, Y, eta, cmap='viridis', edgecolor='none') return [surf] # Return the updated surface ani = FuncAnimation(fig, update, frames=60, interval=100, blit=False) # blit=False is recommended for 3D animations ani.save(\"single_source_3d.gif\", writer=\"pillow\") plt.close()","title":"7.1 Single Source \u2013 Static Wavefronts"},{"location":"1%20Physics/3%20Waves/Problem_1/#72-two-sources-interference-pattern","text":"import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Wave parameters A = 1 lambda_ = 1 k = 2 * np.pi / lambda_ f = 1 omega = 2 * np.pi * f phi = 0 # Grid x = np.linspace(-5, 5, 400) y = np.linspace(-5, 5, 400) X, Y = np.meshgrid(x, y) # Two sources sources = [(-1.5, 0), (1.5, 0)] # Setup plot fig, ax = plt.subplots() img = ax.imshow(np.zeros_like(X), extent=[-5, 5, -5, 5], cmap='plasma', origin='lower') plt.colorbar(img, ax=ax) ax.set_title(\"Two Source Interference\") def update(frame): t = frame / 20 eta_sum = np.zeros_like(X) for x0, y0 in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_sum += A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) img.set_data(eta_sum) return [img] ani = animation.FuncAnimation(fig, update, frames=100, interval=50, blit=True) ani.save(\"two_sources.gif\", writer=\"pillow\") plt.close() import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation # Parameters A = 1 lambda_ = 1 k = 2 * np.pi / lambda_ f = 1 omega = 2 * np.pi * f phi = 0 # Grid x = np.linspace(-5, 5, 150) y = np.linspace(-5, 5, 150) X, Y = np.meshgrid(x, y) # Two source coordinates sources = [(-1.5, 0), (1.5, 0)] fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.set_zlim(-3, 3) ax.set_title(\"Two Sources \u2013 3D Animated Surface\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"Displacement\") # Initialize the surface plot outside the update function surf = ax.plot_surface(X, Y, np.zeros_like(X), cmap='plasma', edgecolor='none') def update(frame): global surf # Make surf accessible within the function t = frame / 20 eta_sum = np.zeros_like(X) for x0, y0 in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_sum += A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) # Remove the previous surface plot surf.remove() # Plot the new surface surf = ax.plot_surface(X, Y, eta_sum, cmap='plasma', edgecolor='none') return [surf] # Return the updated surface ani = FuncAnimation(fig, update, frames=60, interval=100, blit=False) # blit=False is recommended for 3D animations ani.save(\"two_sources_3d.gif\", writer=\"pillow\") plt.close()","title":"7.2 Two Sources \u2013 Interference Pattern"},{"location":"1%20Physics/3%20Waves/Problem_1/#73-three-sources-interference-from-triangle-configuration","text":"import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Wave parameters A = 1 lambda_ = 1 k = 2 * np.pi / lambda_ f = 1 omega = 2 * np.pi * f phi = 0 # Grid x = np.linspace(-5, 5, 400) y = np.linspace(-5, 5, 400) X, Y = np.meshgrid(x, y) # Triangle config R = 2 sources = [(R * np.cos(2*np.pi*i/3), R * np.sin(2*np.pi*i/3)) for i in range(3)] fig, ax = plt.subplots() img = ax.imshow(np.zeros_like(X), extent=[-5, 5, -5, 5], cmap='inferno', origin='lower') plt.colorbar(img, ax=ax) ax.set_title(\"Triangle Interference \u2013 Three Sources\") def update(frame): t = frame / 20 eta_sum = np.zeros_like(X) for x0, y0 in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_sum += A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) img.set_data(eta_sum) return [img] ani = animation.FuncAnimation(fig, update, frames=100, interval=50, blit=True) ani.save(\"three_sources.gif\", writer=\"pillow\") plt.close() import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation # Parameters A = 1 lambda_ = 1 k = 2 * np.pi / lambda_ f = 1 omega = 2 * np.pi * f phi = 0 # Grid x = np.linspace(-5, 5, 150) y = np.linspace(-5, 5, 150) X, Y = np.meshgrid(x, y) # Triangle configuration R = 2 sources = [(R * np.cos(2 * np.pi * i / 3), R * np.sin(2 * np.pi * i / 3)) for i in range(3)] fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.set_zlim(-3, 3) ax.set_title(\"Three Sources \u2013 3D Animated Surface\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"Displacement\") # Initialize surface plot surf = ax.plot_surface(X, Y, np.zeros_like(X), cmap='inferno', edgecolor='none') def update(frame): global surf # Make surf accessible within the function t = frame / 20 eta_sum = np.zeros_like(X) for x0, y0 in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_sum += A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) # Remove the previous surface plot surf.remove() # Plot the new surface surf = ax.plot_surface(X, Y, eta_sum, cmap='inferno', edgecolor='none') return [surf] ani = FuncAnimation(fig, update, frames=60, interval=100, blit=False) # blit=False is important for 3D animations ani.save(\"three_sources_3d.gif\", writer=\"pillow\") plt.close()","title":"7.3 Three Sources \u2013 Interference from Triangle Configuration"},{"location":"1%20Physics/3%20Waves/Problem_1/#colab-waves-problem-1","text":"Souce Code","title":"Colab: Waves Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#8-analysis","text":"Analyzing the resulting interference pattern reveals regions of amplification and cancellation.","title":"8. Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#81-constructive-interference","text":"Occurs when waves are in phase: $$ k(r_i - r_j) = 2\\pi n $$ Leads to high displacement regions (bright fringes or peaks).","title":"8.1 Constructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#82-destructive-interference","text":"Occurs when waves are out of phase: $$ k(r_i - r_j) = (2n + 1)\\pi $$ Leads to wave cancellation (dark zones or troughs).","title":"8.2 Destructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#83-pattern-symmetry","text":"Pattern symmetry follows the polygon's geometry: - Two sources: symmetry about midpoint. - Three (triangle): \\(120^\\circ\\) rotational symmetry. - Four or more: increasing complexity, matching polygonal symmetry.","title":"8.3 Pattern Symmetry"},{"location":"1%20Physics/3%20Waves/Problem_1/#84-visual-cues","text":"Bright ridges = constructive zones Dark lines = destructive zones Radial or rotational motifs reflect geometric layout Contours or threshold filters can aid interpretation.","title":"8.4 Visual Cues"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1.1/","text":"Problem 1 (Shorted) Simulating the Lorentz Force 1. Applications of the Lorentz Force The Lorentz force law, $$ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B}, $$ governs the dynamics of charged particles in electric ( \\(\\mathbf{E}\\) ) and magnetic ( \\(\\mathbf{B}\\) ) fields. Key Applications: Particle Accelerators : Magnetic fields guide particles in circular paths; electric fields accelerate them. Mass Spectrometers : Different mass-to-charge ratios cause unique curvatures in magnetic fields. Plasma Confinement : Magnetic traps (e.g., tokamaks) confine charged plasma using helical motion. Field Setup Force Direction Resulting Motion \\(\\mathbf{E}\\) only Along \\(\\mathbf{E}\\) Linear acceleration \\(\\mathbf{B}\\) only Perpendicular to \\(\\mathbf{v}, \\mathbf{B}\\) Circular/helical motion \\(\\mathbf{E} \\perp \\mathbf{B}\\) Orthogonal force, causes drift Spiral with drift velocity 2. Simulating Particle Motion Governing Equation: \\[ m\\frac{d\\mathbf{v}}{dt} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] Methods: Euler Method : Simple but less accurate for oscillatory systems. Boris Algorithm : Preserves energy in magnetic fields. Runge-Kutta (RK4) : Offers high accuracy at greater computational cost. Motion Types: Circular : \\(\\mathbf{v} \\perp \\mathbf{B}\\) , no \\(\\mathbf{E}\\) . Helical : \\(\\mathbf{v}\\) has parallel and perpendicular components to \\(\\mathbf{B}\\) . Drift : \\(\\mathbf{E} \\perp \\mathbf{B}\\) causes uniform drift: $$ \\mathbf{v}_\\text{drift} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$ 3. Parameter Exploration Simulation results depend on: Field Strengths : \\(E \\rightarrow\\) linear acceleration \\(B \\rightarrow\\) tighter curvature, smaller Larmor radius Initial Velocity : Perpendicular component: affects orbit size Parallel component: affects pitch of helical motion Charge \\(q\\) : Affects direction (sign) and magnitude of motion Mass \\(m\\) : Heavier particles move slower, larger radius Real-world example: $$ r_L = \\frac{mv}{|q|B}, \\quad \\omega_c = \\frac{|q|B}{m} $$ 4. Visualization Visualizing charged particle trajectories under the Lorentz force helps build intuition about their motion in different electromagnetic fields. Using Python, we generate labeled 2D and 3D plots to illustrate key features like: Larmor radius \\(r_L\\) Helical pitch (spiral spacing along field lines) Drift velocity \\(\\mathbf{v}_\\text{drift} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2}\\) 4.1 Circular Motion in \\(xy\\) -Plane Charged particle moves in a circle under a uniform magnetic field ( \\(\\mathbf{B}\\) along \\(z\\) ). No electric field; pure cyclotron motion with constant radius and speed. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Parameters q, m = 1.0, 1.0 B = np.array([0, 0, 1.0]) v0 = np.array([1.0, 0.0, 0.0]) r0 = np.array([0.0, 0.0, 0.0]) dt, T = 0.01, 10 N = int(T / dt) # Calculate trajectory r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * np.cross(v[i], B) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Create animation fig, ax = plt.subplots() ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) ax.set_aspect('equal') line, = ax.plot([], [], lw=2) point, = ax.plot([], [], 'ro') def update(i): line.set_data(r[:i + 1, 0], r[:i + 1, 1]) # Trajectory line point.set_data([r[i, 0]], [r[i, 1]]) # Current point (wrapped in lists) return line, point # Create animation ani = FuncAnimation(fig, update, frames=N - 1, interval=30, blit=True) # Display animation inline in Jupyter Notebook plt.title(\"Circular Motion in xy-plane (Animated)\") plt.xlabel('x') plt.ylabel('y') # plt.grid(True) # plt.show() # Save animation as GIF gif_path = 'circular_motion.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html) 4.2 3D Helical Motion Particle follows a helical path due to velocity components both parallel and perpendicular to \\(\\mathbf{B}\\) . Circular motion + forward motion along field lines. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation from IPython.display import HTML import base64 from io import BytesIO # Parameters q, m = 1.0, 1.0 B = np.array([0, 0, 1.0]) v0 = np.array([1.0, 0.0, 0.5]) # Initial velocity with z-component for helical motion r0 = np.array([0.0, 0.0, 0.0]) dt, T = 0.01, 10 N = int(T / dt) # Calculate trajectory r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * np.cross(v[i], B) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Create 3D animation fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) ax.set_zlim(0, 6) line, = ax.plot([], [], [], lw=2) point, = ax.plot([], [], [], 'ro') def update_3d(i): # Update line (trajectory) line.set_data(r[:i, 0], r[:i, 1]) line.set_3d_properties(r[:i, 2]) # Update point (current position) point.set_data([r[i, 0]], [r[i, 1]]) # Wrap in lists to provide sequences point.set_3d_properties([r[i, 2]]) # Wrap in list to provide sequence return line, point # Create animation ani = FuncAnimation(fig, update_3d, frames=N - 1, interval=30, blit=False) # blit=False for 3D # Set plot labels and title ax.set_title(\"3D Helical Motion (Animated)\") ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') # Save animation as GIF gif_path = 'helical_motion.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html) 4.3 \\(\\mathbf{E} \\times \\mathbf{B}\\) Drift Motion In crossed electric and magnetic fields, the particle spirals while drifting uniformly perpendicular to both \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) . import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML import base64 from io import BytesIO # Parameters q, m = 1.0, 1.0 E = np.array([1.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field r0 = np.array([0.0, 0.0, 0.0]) v0 = np.array([0.5, 0.0, 0.0]) # Initial velocity dt, T = 0.01, 10 N = int(T / dt) # Calculate trajectory r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * (E + np.cross(v[i], B)) # Lorentz force with E and B fields a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Calculate E \u00d7 B drift drift = np.cross(E, B) / np.dot(B, B) # Drift velocity: (E \u00d7 B) / |B|^2 # Create 2D animation fig, ax = plt.subplots() ax.set_xlim(0, 10) ax.set_ylim(-2, 2) ax.set_aspect('equal') line, = ax.plot([], [], lw=2, label='Trajectory') point, = ax.plot([], [], 'ro', label='Particle') drift_line, = ax.plot([], [], 'r--', label='Drift') def update_drift(i): # Update trajectory line line.set_data(r[:i, 0], r[:i, 1]) # Update particle position point.set_data([r[i, 0]], [r[i, 1]]) # Wrap in lists to provide sequences # Update drift line if i > 1: # Ensure enough points for linspace t = np.linspace(0, r[i, 0], 50) # Use fixed number of points for smoothness drift_y = drift[1] * t + r[0, 1] # Drift along y-axis drift_line.set_data(t, drift_y) else: drift_line.set_data([], []) # Empty data for initial frames return line, point, drift_line # Create animation ani = FuncAnimation(fig, update_drift, frames=N - 1, interval=30, blit=True) # Set plot labels, title, and legend plt.title(\"Drift Motion in Crossed E \u00d7 B Fields (Animated)\") plt.xlabel('x') plt.ylabel('y') plt.grid(True) plt.legend() # Save animation as GIF gif_path = 'drift_motion.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html) Colab: Electromagnetism Problem 1 Souce Code 5. Numerical Methods Summary Use Euler for simplicity. Prefer Boris or RK4 for accuracy and energy stability. Keep \\(\\Delta t\\) small enough to resolve cyclotron motion: $$ \\Delta t \\ll \\frac{2\\pi m}{|q|B} $$","title":"Problem 1 (Shorted)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1.1/#problem-1-shorted","text":"Simulating the Lorentz Force","title":"Problem 1 (Shorted)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1.1/#1-applications-of-the-lorentz-force","text":"The Lorentz force law, $$ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B}, $$ governs the dynamics of charged particles in electric ( \\(\\mathbf{E}\\) ) and magnetic ( \\(\\mathbf{B}\\) ) fields.","title":"1. Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1.1/#key-applications","text":"Particle Accelerators : Magnetic fields guide particles in circular paths; electric fields accelerate them. Mass Spectrometers : Different mass-to-charge ratios cause unique curvatures in magnetic fields. Plasma Confinement : Magnetic traps (e.g., tokamaks) confine charged plasma using helical motion. Field Setup Force Direction Resulting Motion \\(\\mathbf{E}\\) only Along \\(\\mathbf{E}\\) Linear acceleration \\(\\mathbf{B}\\) only Perpendicular to \\(\\mathbf{v}, \\mathbf{B}\\) Circular/helical motion \\(\\mathbf{E} \\perp \\mathbf{B}\\) Orthogonal force, causes drift Spiral with drift velocity","title":"Key Applications:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1.1/#2-simulating-particle-motion","text":"","title":"2. Simulating Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1.1/#governing-equation","text":"\\[ m\\frac{d\\mathbf{v}}{dt} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\]","title":"Governing Equation:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1.1/#methods","text":"Euler Method : Simple but less accurate for oscillatory systems. Boris Algorithm : Preserves energy in magnetic fields. Runge-Kutta (RK4) : Offers high accuracy at greater computational cost.","title":"Methods:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1.1/#motion-types","text":"Circular : \\(\\mathbf{v} \\perp \\mathbf{B}\\) , no \\(\\mathbf{E}\\) . Helical : \\(\\mathbf{v}\\) has parallel and perpendicular components to \\(\\mathbf{B}\\) . Drift : \\(\\mathbf{E} \\perp \\mathbf{B}\\) causes uniform drift: $$ \\mathbf{v}_\\text{drift} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$","title":"Motion Types:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1.1/#3-parameter-exploration","text":"Simulation results depend on: Field Strengths : \\(E \\rightarrow\\) linear acceleration \\(B \\rightarrow\\) tighter curvature, smaller Larmor radius Initial Velocity : Perpendicular component: affects orbit size Parallel component: affects pitch of helical motion Charge \\(q\\) : Affects direction (sign) and magnitude of motion Mass \\(m\\) : Heavier particles move slower, larger radius Real-world example: $$ r_L = \\frac{mv}{|q|B}, \\quad \\omega_c = \\frac{|q|B}{m} $$","title":"3. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1.1/#4-visualization","text":"Visualizing charged particle trajectories under the Lorentz force helps build intuition about their motion in different electromagnetic fields. Using Python, we generate labeled 2D and 3D plots to illustrate key features like: Larmor radius \\(r_L\\) Helical pitch (spiral spacing along field lines) Drift velocity \\(\\mathbf{v}_\\text{drift} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2}\\)","title":"4. Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1.1/#41-circular-motion-in-xy-plane","text":"Charged particle moves in a circle under a uniform magnetic field ( \\(\\mathbf{B}\\) along \\(z\\) ). No electric field; pure cyclotron motion with constant radius and speed. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Parameters q, m = 1.0, 1.0 B = np.array([0, 0, 1.0]) v0 = np.array([1.0, 0.0, 0.0]) r0 = np.array([0.0, 0.0, 0.0]) dt, T = 0.01, 10 N = int(T / dt) # Calculate trajectory r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * np.cross(v[i], B) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Create animation fig, ax = plt.subplots() ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) ax.set_aspect('equal') line, = ax.plot([], [], lw=2) point, = ax.plot([], [], 'ro') def update(i): line.set_data(r[:i + 1, 0], r[:i + 1, 1]) # Trajectory line point.set_data([r[i, 0]], [r[i, 1]]) # Current point (wrapped in lists) return line, point # Create animation ani = FuncAnimation(fig, update, frames=N - 1, interval=30, blit=True) # Display animation inline in Jupyter Notebook plt.title(\"Circular Motion in xy-plane (Animated)\") plt.xlabel('x') plt.ylabel('y') # plt.grid(True) # plt.show() # Save animation as GIF gif_path = 'circular_motion.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html)","title":"4.1 Circular Motion in \\(xy\\)-Plane"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1.1/#42-3d-helical-motion","text":"Particle follows a helical path due to velocity components both parallel and perpendicular to \\(\\mathbf{B}\\) . Circular motion + forward motion along field lines. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation from IPython.display import HTML import base64 from io import BytesIO # Parameters q, m = 1.0, 1.0 B = np.array([0, 0, 1.0]) v0 = np.array([1.0, 0.0, 0.5]) # Initial velocity with z-component for helical motion r0 = np.array([0.0, 0.0, 0.0]) dt, T = 0.01, 10 N = int(T / dt) # Calculate trajectory r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * np.cross(v[i], B) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Create 3D animation fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) ax.set_zlim(0, 6) line, = ax.plot([], [], [], lw=2) point, = ax.plot([], [], [], 'ro') def update_3d(i): # Update line (trajectory) line.set_data(r[:i, 0], r[:i, 1]) line.set_3d_properties(r[:i, 2]) # Update point (current position) point.set_data([r[i, 0]], [r[i, 1]]) # Wrap in lists to provide sequences point.set_3d_properties([r[i, 2]]) # Wrap in list to provide sequence return line, point # Create animation ani = FuncAnimation(fig, update_3d, frames=N - 1, interval=30, blit=False) # blit=False for 3D # Set plot labels and title ax.set_title(\"3D Helical Motion (Animated)\") ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') # Save animation as GIF gif_path = 'helical_motion.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html)","title":"4.2 3D Helical Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1.1/#43-mathbfe-times-mathbfb-drift-motion","text":"In crossed electric and magnetic fields, the particle spirals while drifting uniformly perpendicular to both \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) . import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML import base64 from io import BytesIO # Parameters q, m = 1.0, 1.0 E = np.array([1.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field r0 = np.array([0.0, 0.0, 0.0]) v0 = np.array([0.5, 0.0, 0.0]) # Initial velocity dt, T = 0.01, 10 N = int(T / dt) # Calculate trajectory r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * (E + np.cross(v[i], B)) # Lorentz force with E and B fields a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Calculate E \u00d7 B drift drift = np.cross(E, B) / np.dot(B, B) # Drift velocity: (E \u00d7 B) / |B|^2 # Create 2D animation fig, ax = plt.subplots() ax.set_xlim(0, 10) ax.set_ylim(-2, 2) ax.set_aspect('equal') line, = ax.plot([], [], lw=2, label='Trajectory') point, = ax.plot([], [], 'ro', label='Particle') drift_line, = ax.plot([], [], 'r--', label='Drift') def update_drift(i): # Update trajectory line line.set_data(r[:i, 0], r[:i, 1]) # Update particle position point.set_data([r[i, 0]], [r[i, 1]]) # Wrap in lists to provide sequences # Update drift line if i > 1: # Ensure enough points for linspace t = np.linspace(0, r[i, 0], 50) # Use fixed number of points for smoothness drift_y = drift[1] * t + r[0, 1] # Drift along y-axis drift_line.set_data(t, drift_y) else: drift_line.set_data([], []) # Empty data for initial frames return line, point, drift_line # Create animation ani = FuncAnimation(fig, update_drift, frames=N - 1, interval=30, blit=True) # Set plot labels, title, and legend plt.title(\"Drift Motion in Crossed E \u00d7 B Fields (Animated)\") plt.xlabel('x') plt.ylabel('y') plt.grid(True) plt.legend() # Save animation as GIF gif_path = 'drift_motion.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html)","title":"4.3 \\(\\mathbf{E} \\times \\mathbf{B}\\) Drift Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1.1/#colab-electromagnetism-problem-1","text":"Souce Code","title":"Colab: Electromagnetism Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1.1/#5-numerical-methods-summary","text":"Use Euler for simplicity. Prefer Boris or RK4 for accuracy and energy stability. Keep \\(\\Delta t\\) small enough to resolve cyclotron motion: $$ \\Delta t \\ll \\frac{2\\pi m}{|q|B} $$","title":"5. Numerical Methods Summary"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the Lorentz Force 1. Exploration of Applications The Lorentz force describes the motion of a charged particle under the influence of electric and magnetic fields , and is one of the cornerstones of classical and modern electromagnetism. 1.1 Fundamental Equation The Lorentz force acting on a particle of charge \\(q\\) moving with velocity \\(\\mathbf{v}\\) in an electric field \\(\\mathbf{E}\\) and magnetic field \\(\\mathbf{B}\\) is given by: \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] This vector equation has two key components: The electric force : \\(q\\mathbf{E}\\) , which acts in the direction of the electric field. The magnetic force : \\(q\\mathbf{v} \\times \\mathbf{B}\\) , which acts perpendicular to both the velocity of the particle and the magnetic field. 1.2 Real-World Applications The Lorentz force plays a pivotal role in several technological and scientific domains: \u2022 Particle Accelerators In cyclotrons , synchrotrons , and linear accelerators , particles are steered and accelerated using electromagnetic fields. Magnetic fields enforce circular or helical motion: $$ r = \\frac{mv}{|q|B} $$ Electric fields provide kinetic energy: $$ \\Delta K = qEd $$ \u2022 Mass Spectrometers Used in chemistry and physics to identify atoms and molecules based on their mass-to-charge ratio. \u2022 Plasma Confinement (Fusion Reactors) In tokamaks and stellarators , magnetic fields confine high-energy plasma in a donut-shaped chamber. 1.3 Summary of Field Effects Field Type Direction of Force Effect on Motion \\(\\mathbf{E}\\) only Parallel to \\(\\mathbf{E}\\) Linear acceleration or deceleration \\(\\mathbf{B}\\) only Perpendicular to \\(\\mathbf{v}\\) and \\(\\mathbf{B}\\) Circular or helical motion \\(\\mathbf{E} \\perp \\mathbf{B}\\) Orthogonal force due to \\(\\mathbf{v} \\times \\mathbf{B}\\) Drift or spiral trajectories 2. Simulating Particle Motion 2.1 Governing Equation \\[ \\mathbf{F} = m \\frac{d\\mathbf{v}}{dt} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] 2.2 Numerical Implementation Euler method used initially: $$ \\mathbf{v} {n+1} = \\mathbf{v}_n + \\frac{q}{m}(\\mathbf{E} + \\mathbf{v}_n \\times \\mathbf{B})\\Delta t $$ $$ \\mathbf{r} {n+1} = \\mathbf{r}_n + \\mathbf{v}_n \\Delta t $$ 2.4 Boris Algorithm Implementation (Alternative to Euler) # Boris algorithm for stable motion in magnetic fields q, m = 1.0, 1.0 B = np.array([0, 0, 1.0]) E = np.array([0.0, 0.0, 0.0]) v0 = np.array([1.0, 0.0, 0.0]) r0 = np.array([0.0, 0.0, 0.0]) dt, T = 0.01, 10 N = int(T / dt) r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 t = (q * B / m) * (dt / 2) t_mag2 = np.dot(t, t) s = 2 * t / (1 + t_mag2) for i in range(N - 1): v_minus = v[i] + (q * E / m) * (dt / 2) v_prime = v_minus + np.cross(v_minus, t) v_plus = v_minus + np.cross(v_prime, s) v[i + 1] = v_plus + (q * E / m) * (dt / 2) r[i + 1] = r[i] + v[i + 1] * dt 2.5 Types of Motion \u2022 Circular Motion Occurs when: - \\(\\mathbf{E} = 0\\) - \\(\\mathbf{v} \\perp \\mathbf{B}\\) Result: - Constant-speed circular motion in the plane perpendicular to \\(\\mathbf{B}\\) \u2022 Helical Motion Occurs when: - \\(\\mathbf{v}\\) has both parallel and perpendicular components with respect to \\(\\mathbf{B}\\) - \\(\\mathbf{E} = 0\\) or parallel to \\(\\mathbf{B}\\) Result: - Particle moves in a spiral (helix) along field lines with pitch determined by \\(v_\\parallel\\) \u2022 Drift Motion Occurs under: - \\(\\mathbf{E} \\perp \\mathbf{B}\\) Result: - Circular/helical motion superimposed with uniform drift : $$ \\mathbf{v}_\\text{drift} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$ These simulations are vital in visualizing how charged particles behave in various field environments, providing insights into devices such as mass spectrometers , magnetic confinement systems , and beam control in accelerators . 3. Parameter Exploration The dynamics of charged particles under the Lorentz force are highly sensitive to physical parameters. Exploring variations in these parameters allows us to understand how they shape the trajectory and motion characteristics such as speed, curvature, and drift. The Lorentz force remains our starting point: \\[ \\mathbf{F} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] This governs the acceleration and thus the trajectory of the particle according to Newton's second law: \\[ \\mathbf{F} = m \\frac{d\\mathbf{v}}{dt} \\] 3.1 Key Parameters and Their Effects \u2022 Electric Field Strength ( \\(E\\) ) The electric field contributes directly to linear acceleration : \\[ \\mathbf{a}_E = \\frac{q\\mathbf{E}}{m} \\] Stronger \\(E\\) leads to higher linear acceleration. Dominant in configurations where \\(\\mathbf{B} = 0\\) or \\(\\mathbf{v} \\parallel \\mathbf{E}\\) . In combined fields, \\(E\\) affects drift velocity and can induce helical stretching . \u2022 Magnetic Field Strength ( \\(B\\) ) The magnetic component of the Lorentz force is velocity-dependent: \\[ \\mathbf{F}_B = q(\\mathbf{v} \\times \\mathbf{B}) \\] Stronger \\(B\\) increases the curvature of motion. In pure \\(\\mathbf{B}\\) fields, it reduces the Larmor radius : $$ r_L = \\frac{mv_\\perp}{|q|B} $$ It also increases the gyrofrequency : $$ \\omega_c = \\frac{|q|B}{m} $$ where \\(\\omega_c\\) is the cyclotron frequency . \u2022 Initial Velocity ( \\(\\mathbf{v}\\) ) The direction and magnitude of initial velocity define the geometry of motion: Perpendicular to \\(\\mathbf{B}\\) \\(\\rightarrow\\) circular motion Parallel to \\(\\mathbf{B}\\) \\(\\rightarrow\\) linear motion Mixed components \\(\\rightarrow\\) helical motion Magnitude affects: Radius of curvature ( \\(r_L\\) increases with \\(v_\\perp\\) ) Speed of drift in crossed fields: \\[ \\mathbf{v}_\\text{drift} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} \\] \u2022 Particle Charge ( \\(q\\) ) Charge affects both magnitude and direction of the Lorentz force: Sign of \\(q\\) reverses the direction of the magnetic force: $$ \\text{If } q > 0: \\text{ right-hand rule applies} \\ \\text{If } q < 0: \\text{ reverse direction (left-hand motion)} $$ Affects radius and frequency as: $$ r_L \\propto \\frac{1}{|q|}, \\quad \\omega_c \\propto |q| $$ \u2022 Particle Mass ( \\(m\\) ) Inversely proportional to acceleration for a given force: $$ \\mathbf{a} = \\frac{\\mathbf{F}}{m} $$ Affects Larmor radius and cyclotron frequency: $$ r_L \\propto m, \\quad \\omega_c \\propto \\frac{1}{m} $$ Heavier particles exhibit larger orbits and slower rotation under the same field conditions. 3.2 Visual Exploration Goals By varying the above parameters in simulations, one should: Track trajectory changes : curvature, helical pitch, drift. Compare motion types : linear vs circular vs spiral. Identify scaling laws for: Larmor radius: \\(r_L = \\frac{mv_\\perp}{|q|B}\\) Cyclotron frequency: \\(\\omega_c = \\frac{|q|B}{m}\\) Parameter exploration is essential for tuning real-world applications, from optimizing cyclotron paths to designing magnetic traps and beamlines. 3.3 Real-World System Example: Cyclotron Motion Proton in a cyclotron: - \\(B = 1\\ \\text{T}\\) - \\(v = 1 \\times 10^6\\ \\text{m/s}\\) Larmor radius: $$ r_L = \\frac{mv}{|q|B} = \\frac{1.67 \\times 10^{-27} \\cdot 10^6}{1.6 \\times 10^{-19} \\cdot 1} \\approx 0.0104\\ \\text{m} $$ 3.4 Interactive Parameter Exploration (Optional for Jupyter/Colab) import ipywidgets as widgets from IPython.display import display def update_simulation(B_field=1.0, velocity=1.0): # Call a simulation function with updated B and v pass display(widgets.FloatSlider(value=1.0, min=0.1, max=5.0, step=0.1, description='B Field')) display(widgets.FloatSlider(value=1.0, min=0.1, max=5.0, step=0.1, description='Velocity')) 4. Visualization Visualizing charged particle trajectories under the Lorentz force is critical for developing intuition about their motion in various electromagnetic field configurations. In this section, we use Python and standard scientific libraries to produce labeled, informative 2D and 3D plots that illustrate: Larmor radius \\(r_L\\) Helical pitch (distance between spiral turns along the field direction) Drift velocity \\(\\mathbf{v}_\\text{drift} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2}\\) 4.1 Circular Motion in \\(xy\\) -Plane Charged particle moves in a circle under a uniform magnetic field ( \\(\\mathbf{B}\\) along \\(z\\) ). No electric field; pure cyclotron motion with constant radius and speed. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Parameters q, m = 1.0, 1.0 B = np.array([0, 0, 1.0]) v0 = np.array([1.0, 0.0, 0.0]) r0 = np.array([0.0, 0.0, 0.0]) dt, T = 0.01, 10 N = int(T / dt) # Calculate trajectory r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * np.cross(v[i], B) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Create animation fig, ax = plt.subplots() ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) ax.set_aspect('equal') line, = ax.plot([], [], lw=2) point, = ax.plot([], [], 'ro') def update(i): line.set_data(r[:i + 1, 0], r[:i + 1, 1]) # Trajectory line point.set_data([r[i, 0]], [r[i, 1]]) # Current point (wrapped in lists) return line, point # Create animation ani = FuncAnimation(fig, update, frames=N - 1, interval=30, blit=True) # Display animation inline in Jupyter Notebook plt.title(\"Circular Motion in xy-plane (Animated)\") plt.xlabel('x') plt.ylabel('y') # plt.grid(True) # plt.show() # Save animation as GIF gif_path = 'circular_motion.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html) 4.2 3D Helical Motion Particle follows a helical path due to velocity components both parallel and perpendicular to \\(\\mathbf{B}\\) . Circular motion + forward motion along field lines. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation from IPython.display import HTML import base64 from io import BytesIO # Parameters q, m = 1.0, 1.0 B = np.array([0, 0, 1.0]) v0 = np.array([1.0, 0.0, 0.5]) # Initial velocity with z-component for helical motion r0 = np.array([0.0, 0.0, 0.0]) dt, T = 0.01, 10 N = int(T / dt) # Calculate trajectory r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * np.cross(v[i], B) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Create 3D animation fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) ax.set_zlim(0, 6) line, = ax.plot([], [], [], lw=2) point, = ax.plot([], [], [], 'ro') def update_3d(i): # Update line (trajectory) line.set_data(r[:i, 0], r[:i, 1]) line.set_3d_properties(r[:i, 2]) # Update point (current position) point.set_data([r[i, 0]], [r[i, 1]]) # Wrap in lists to provide sequences point.set_3d_properties([r[i, 2]]) # Wrap in list to provide sequence return line, point # Create animation ani = FuncAnimation(fig, update_3d, frames=N - 1, interval=30, blit=False) # blit=False for 3D # Set plot labels and title ax.set_title(\"3D Helical Motion (Animated)\") ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') # Save animation as GIF gif_path = 'helical_motion.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html) 4.3 \\(\\mathbf{E} \\times \\mathbf{B}\\) Drift Motion In crossed electric and magnetic fields, the particle spirals while drifting uniformly perpendicular to both \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) . import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML import base64 from io import BytesIO # Parameters q, m = 1.0, 1.0 E = np.array([1.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field r0 = np.array([0.0, 0.0, 0.0]) v0 = np.array([0.5, 0.0, 0.0]) # Initial velocity dt, T = 0.01, 10 N = int(T / dt) # Calculate trajectory r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * (E + np.cross(v[i], B)) # Lorentz force with E and B fields a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Calculate E \u00d7 B drift drift = np.cross(E, B) / np.dot(B, B) # Drift velocity: (E \u00d7 B) / |B|^2 # Create 2D animation fig, ax = plt.subplots() ax.set_xlim(0, 10) ax.set_ylim(-2, 2) ax.set_aspect('equal') line, = ax.plot([], [], lw=2, label='Trajectory') point, = ax.plot([], [], 'ro', label='Particle') drift_line, = ax.plot([], [], 'r--', label='Drift') def update_drift(i): # Update trajectory line line.set_data(r[:i, 0], r[:i, 1]) # Update particle position point.set_data([r[i, 0]], [r[i, 1]]) # Wrap in lists to provide sequences # Update drift line if i > 1: # Ensure enough points for linspace t = np.linspace(0, r[i, 0], 50) # Use fixed number of points for smoothness drift_y = drift[1] * t + r[0, 1] # Drift along y-axis drift_line.set_data(t, drift_y) else: drift_line.set_data([], []) # Empty data for initial frames return line, point, drift_line # Create animation ani = FuncAnimation(fig, update_drift, frames=N - 1, interval=30, blit=True) # Set plot labels, title, and legend plt.title(\"Drift Motion in Crossed E \u00d7 B Fields (Animated)\") plt.xlabel('x') plt.ylabel('y') plt.grid(True) plt.legend() # Save animation as GIF gif_path = 'drift_motion.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html) Colab: Electromagnetism Problem 1 Souce Code Summary of Visual Insights Larmor radius is determined by the perpendicular velocity component and magnetic field: $$ r_L = \\frac{mv_\\perp}{|q|B} $$ Helical pitch corresponds to the distance moved in the field direction per revolution: $$ \\text{Pitch} = v_\\parallel T = \\frac{2\\pi m v_\\parallel}{|q|B} $$ Drift velocity from crossed fields appears as a linear translation of the helix: $$ \\mathbf{v}_{\\text{drift}} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$ These visualizations provide powerful tools to explore particle behavior and validate analytic predictions. 5. Numerical Implementation Simulating the motion of charged particles under electromagnetic forces involves solving ordinary differential equations (ODEs) derived from the Lorentz force law : \\[ \\mathbf{F} = m\\frac{d\\mathbf{v}}{dt} = q\\left( \\mathbf{E} + \\mathbf{v} \\times \\mathbf{B} \\right) \\] This gives a coupled system of first-order ODEs: \\[ \\frac{d\\mathbf{v}}{dt} = \\frac{q}{m}(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}), \\quad \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\] These equations are nonlinear and cannot usually be solved analytically. Therefore, we use numerical methods. Euler Method (First-Order Approximation) The Euler method is the simplest approach, using forward differences: \\[ \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{q}{m}(\\mathbf{E} + \\mathbf{v}_n \\times \\mathbf{B})\\Delta t \\] \\[ \\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v}_n \\Delta t \\] Pros : Easy to implement Cons : Low accuracy, error grows with time, unstable for stiff or oscillatory systems Runge-Kutta Method (4th Order, RK4) The RK4 method offers a much more accurate solution. It approximates the next state using intermediate \"slopes\": Let \\(\\mathbf{f}(t, \\mathbf{y})\\) be the derivative function for velocity and position: Compute intermediate steps: $$ \\begin{aligned} \\mathbf{k}_1 &= f(t_n, \\mathbf{y}_n) \\ \\mathbf{k}_2 &= f(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_1) \\ \\mathbf{k}_3 &= f(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_2) \\ \\mathbf{k}_4 &= f(t_n + \\Delta t, \\mathbf{y}_n + \\Delta t \\mathbf{k}_3) \\end{aligned} $$ Update the solution: $$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4) $$ Where \\(\\mathbf{y}\\) can represent either \\(\\mathbf{r}\\) or \\(\\mathbf{v}\\) . Pros : Much more accurate and stable than Euler, handles oscillatory behavior well Cons : More computationally expensive Recommendation Use Euler method for quick visualizations or conceptual understanding. Use RK4 or the Boris method for precision and stability in realistic physics simulations (e.g., plasma modeling, cyclotron motion, fusion confinement). Numerical Stability Time step size \\(\\Delta t\\) must be small enough to resolve gyro-motion : \\[ \\Delta t \\ll \\frac{2\\pi m}{|q|B} = T_{\\text{cyclotron}} \\] Choosing too large a step causes inaccurate or even unstable results.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"Simulating the Lorentz Force","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-exploration-of-applications","text":"The Lorentz force describes the motion of a charged particle under the influence of electric and magnetic fields , and is one of the cornerstones of classical and modern electromagnetism.","title":"1. Exploration of Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#11-fundamental-equation","text":"The Lorentz force acting on a particle of charge \\(q\\) moving with velocity \\(\\mathbf{v}\\) in an electric field \\(\\mathbf{E}\\) and magnetic field \\(\\mathbf{B}\\) is given by: \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] This vector equation has two key components: The electric force : \\(q\\mathbf{E}\\) , which acts in the direction of the electric field. The magnetic force : \\(q\\mathbf{v} \\times \\mathbf{B}\\) , which acts perpendicular to both the velocity of the particle and the magnetic field.","title":"1.1 Fundamental Equation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#12-real-world-applications","text":"The Lorentz force plays a pivotal role in several technological and scientific domains:","title":"1.2 Real-World Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#particle-accelerators","text":"In cyclotrons , synchrotrons , and linear accelerators , particles are steered and accelerated using electromagnetic fields. Magnetic fields enforce circular or helical motion: $$ r = \\frac{mv}{|q|B} $$ Electric fields provide kinetic energy: $$ \\Delta K = qEd $$","title":"\u2022 Particle Accelerators"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#mass-spectrometers","text":"Used in chemistry and physics to identify atoms and molecules based on their mass-to-charge ratio.","title":"\u2022 Mass Spectrometers"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#plasma-confinement-fusion-reactors","text":"In tokamaks and stellarators , magnetic fields confine high-energy plasma in a donut-shaped chamber.","title":"\u2022 Plasma Confinement (Fusion Reactors)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#13-summary-of-field-effects","text":"Field Type Direction of Force Effect on Motion \\(\\mathbf{E}\\) only Parallel to \\(\\mathbf{E}\\) Linear acceleration or deceleration \\(\\mathbf{B}\\) only Perpendicular to \\(\\mathbf{v}\\) and \\(\\mathbf{B}\\) Circular or helical motion \\(\\mathbf{E} \\perp \\mathbf{B}\\) Orthogonal force due to \\(\\mathbf{v} \\times \\mathbf{B}\\) Drift or spiral trajectories","title":"1.3 Summary of Field Effects"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulating-particle-motion","text":"","title":"2. Simulating Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#21-governing-equation","text":"\\[ \\mathbf{F} = m \\frac{d\\mathbf{v}}{dt} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\]","title":"2.1 Governing Equation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#22-numerical-implementation","text":"Euler method used initially: $$ \\mathbf{v} {n+1} = \\mathbf{v}_n + \\frac{q}{m}(\\mathbf{E} + \\mathbf{v}_n \\times \\mathbf{B})\\Delta t $$ $$ \\mathbf{r} {n+1} = \\mathbf{r}_n + \\mathbf{v}_n \\Delta t $$","title":"2.2 Numerical Implementation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#24-boris-algorithm-implementation-alternative-to-euler","text":"# Boris algorithm for stable motion in magnetic fields q, m = 1.0, 1.0 B = np.array([0, 0, 1.0]) E = np.array([0.0, 0.0, 0.0]) v0 = np.array([1.0, 0.0, 0.0]) r0 = np.array([0.0, 0.0, 0.0]) dt, T = 0.01, 10 N = int(T / dt) r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 t = (q * B / m) * (dt / 2) t_mag2 = np.dot(t, t) s = 2 * t / (1 + t_mag2) for i in range(N - 1): v_minus = v[i] + (q * E / m) * (dt / 2) v_prime = v_minus + np.cross(v_minus, t) v_plus = v_minus + np.cross(v_prime, s) v[i + 1] = v_plus + (q * E / m) * (dt / 2) r[i + 1] = r[i] + v[i + 1] * dt","title":"2.4 Boris Algorithm Implementation (Alternative to Euler)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#25-types-of-motion","text":"","title":"2.5 Types of Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#circular-motion","text":"Occurs when: - \\(\\mathbf{E} = 0\\) - \\(\\mathbf{v} \\perp \\mathbf{B}\\) Result: - Constant-speed circular motion in the plane perpendicular to \\(\\mathbf{B}\\)","title":"\u2022 Circular Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#helical-motion","text":"Occurs when: - \\(\\mathbf{v}\\) has both parallel and perpendicular components with respect to \\(\\mathbf{B}\\) - \\(\\mathbf{E} = 0\\) or parallel to \\(\\mathbf{B}\\) Result: - Particle moves in a spiral (helix) along field lines with pitch determined by \\(v_\\parallel\\)","title":"\u2022 Helical Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#drift-motion","text":"Occurs under: - \\(\\mathbf{E} \\perp \\mathbf{B}\\) Result: - Circular/helical motion superimposed with uniform drift : $$ \\mathbf{v}_\\text{drift} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$ These simulations are vital in visualizing how charged particles behave in various field environments, providing insights into devices such as mass spectrometers , magnetic confinement systems , and beam control in accelerators .","title":"\u2022 Drift Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-parameter-exploration","text":"The dynamics of charged particles under the Lorentz force are highly sensitive to physical parameters. Exploring variations in these parameters allows us to understand how they shape the trajectory and motion characteristics such as speed, curvature, and drift. The Lorentz force remains our starting point: \\[ \\mathbf{F} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] This governs the acceleration and thus the trajectory of the particle according to Newton's second law: \\[ \\mathbf{F} = m \\frac{d\\mathbf{v}}{dt} \\]","title":"3. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#31-key-parameters-and-their-effects","text":"","title":"3.1 Key Parameters and Their Effects"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electric-field-strength-e","text":"The electric field contributes directly to linear acceleration : \\[ \\mathbf{a}_E = \\frac{q\\mathbf{E}}{m} \\] Stronger \\(E\\) leads to higher linear acceleration. Dominant in configurations where \\(\\mathbf{B} = 0\\) or \\(\\mathbf{v} \\parallel \\mathbf{E}\\) . In combined fields, \\(E\\) affects drift velocity and can induce helical stretching .","title":"\u2022 Electric Field Strength (\\(E\\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#magnetic-field-strength-b","text":"The magnetic component of the Lorentz force is velocity-dependent: \\[ \\mathbf{F}_B = q(\\mathbf{v} \\times \\mathbf{B}) \\] Stronger \\(B\\) increases the curvature of motion. In pure \\(\\mathbf{B}\\) fields, it reduces the Larmor radius : $$ r_L = \\frac{mv_\\perp}{|q|B} $$ It also increases the gyrofrequency : $$ \\omega_c = \\frac{|q|B}{m} $$ where \\(\\omega_c\\) is the cyclotron frequency .","title":"\u2022 Magnetic Field Strength (\\(B\\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#initial-velocity-mathbfv","text":"The direction and magnitude of initial velocity define the geometry of motion: Perpendicular to \\(\\mathbf{B}\\) \\(\\rightarrow\\) circular motion Parallel to \\(\\mathbf{B}\\) \\(\\rightarrow\\) linear motion Mixed components \\(\\rightarrow\\) helical motion Magnitude affects: Radius of curvature ( \\(r_L\\) increases with \\(v_\\perp\\) ) Speed of drift in crossed fields: \\[ \\mathbf{v}_\\text{drift} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} \\]","title":"\u2022 Initial Velocity (\\(\\mathbf{v}\\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#particle-charge-q","text":"Charge affects both magnitude and direction of the Lorentz force: Sign of \\(q\\) reverses the direction of the magnetic force: $$ \\text{If } q > 0: \\text{ right-hand rule applies} \\ \\text{If } q < 0: \\text{ reverse direction (left-hand motion)} $$ Affects radius and frequency as: $$ r_L \\propto \\frac{1}{|q|}, \\quad \\omega_c \\propto |q| $$","title":"\u2022 Particle Charge (\\(q\\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#particle-mass-m","text":"Inversely proportional to acceleration for a given force: $$ \\mathbf{a} = \\frac{\\mathbf{F}}{m} $$ Affects Larmor radius and cyclotron frequency: $$ r_L \\propto m, \\quad \\omega_c \\propto \\frac{1}{m} $$ Heavier particles exhibit larger orbits and slower rotation under the same field conditions.","title":"\u2022 Particle Mass (\\(m\\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#32-visual-exploration-goals","text":"By varying the above parameters in simulations, one should: Track trajectory changes : curvature, helical pitch, drift. Compare motion types : linear vs circular vs spiral. Identify scaling laws for: Larmor radius: \\(r_L = \\frac{mv_\\perp}{|q|B}\\) Cyclotron frequency: \\(\\omega_c = \\frac{|q|B}{m}\\) Parameter exploration is essential for tuning real-world applications, from optimizing cyclotron paths to designing magnetic traps and beamlines.","title":"3.2 Visual Exploration Goals"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#33-real-world-system-example-cyclotron-motion","text":"Proton in a cyclotron: - \\(B = 1\\ \\text{T}\\) - \\(v = 1 \\times 10^6\\ \\text{m/s}\\) Larmor radius: $$ r_L = \\frac{mv}{|q|B} = \\frac{1.67 \\times 10^{-27} \\cdot 10^6}{1.6 \\times 10^{-19} \\cdot 1} \\approx 0.0104\\ \\text{m} $$","title":"3.3 Real-World System Example: Cyclotron Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#34-interactive-parameter-exploration-optional-for-jupytercolab","text":"import ipywidgets as widgets from IPython.display import display def update_simulation(B_field=1.0, velocity=1.0): # Call a simulation function with updated B and v pass display(widgets.FloatSlider(value=1.0, min=0.1, max=5.0, step=0.1, description='B Field')) display(widgets.FloatSlider(value=1.0, min=0.1, max=5.0, step=0.1, description='Velocity'))","title":"3.4 Interactive Parameter Exploration (Optional for Jupyter/Colab)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-visualization","text":"Visualizing charged particle trajectories under the Lorentz force is critical for developing intuition about their motion in various electromagnetic field configurations. In this section, we use Python and standard scientific libraries to produce labeled, informative 2D and 3D plots that illustrate: Larmor radius \\(r_L\\) Helical pitch (distance between spiral turns along the field direction) Drift velocity \\(\\mathbf{v}_\\text{drift} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2}\\)","title":"4. Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#41-circular-motion-in-xy-plane","text":"Charged particle moves in a circle under a uniform magnetic field ( \\(\\mathbf{B}\\) along \\(z\\) ). No electric field; pure cyclotron motion with constant radius and speed. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Parameters q, m = 1.0, 1.0 B = np.array([0, 0, 1.0]) v0 = np.array([1.0, 0.0, 0.0]) r0 = np.array([0.0, 0.0, 0.0]) dt, T = 0.01, 10 N = int(T / dt) # Calculate trajectory r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * np.cross(v[i], B) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Create animation fig, ax = plt.subplots() ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) ax.set_aspect('equal') line, = ax.plot([], [], lw=2) point, = ax.plot([], [], 'ro') def update(i): line.set_data(r[:i + 1, 0], r[:i + 1, 1]) # Trajectory line point.set_data([r[i, 0]], [r[i, 1]]) # Current point (wrapped in lists) return line, point # Create animation ani = FuncAnimation(fig, update, frames=N - 1, interval=30, blit=True) # Display animation inline in Jupyter Notebook plt.title(\"Circular Motion in xy-plane (Animated)\") plt.xlabel('x') plt.ylabel('y') # plt.grid(True) # plt.show() # Save animation as GIF gif_path = 'circular_motion.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html)","title":"4.1 Circular Motion in \\(xy\\)-Plane"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#42-3d-helical-motion","text":"Particle follows a helical path due to velocity components both parallel and perpendicular to \\(\\mathbf{B}\\) . Circular motion + forward motion along field lines. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation from IPython.display import HTML import base64 from io import BytesIO # Parameters q, m = 1.0, 1.0 B = np.array([0, 0, 1.0]) v0 = np.array([1.0, 0.0, 0.5]) # Initial velocity with z-component for helical motion r0 = np.array([0.0, 0.0, 0.0]) dt, T = 0.01, 10 N = int(T / dt) # Calculate trajectory r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * np.cross(v[i], B) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Create 3D animation fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) ax.set_zlim(0, 6) line, = ax.plot([], [], [], lw=2) point, = ax.plot([], [], [], 'ro') def update_3d(i): # Update line (trajectory) line.set_data(r[:i, 0], r[:i, 1]) line.set_3d_properties(r[:i, 2]) # Update point (current position) point.set_data([r[i, 0]], [r[i, 1]]) # Wrap in lists to provide sequences point.set_3d_properties([r[i, 2]]) # Wrap in list to provide sequence return line, point # Create animation ani = FuncAnimation(fig, update_3d, frames=N - 1, interval=30, blit=False) # blit=False for 3D # Set plot labels and title ax.set_title(\"3D Helical Motion (Animated)\") ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') # Save animation as GIF gif_path = 'helical_motion.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html)","title":"4.2 3D Helical Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#43-mathbfe-times-mathbfb-drift-motion","text":"In crossed electric and magnetic fields, the particle spirals while drifting uniformly perpendicular to both \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) . import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML import base64 from io import BytesIO # Parameters q, m = 1.0, 1.0 E = np.array([1.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field r0 = np.array([0.0, 0.0, 0.0]) v0 = np.array([0.5, 0.0, 0.0]) # Initial velocity dt, T = 0.01, 10 N = int(T / dt) # Calculate trajectory r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * (E + np.cross(v[i], B)) # Lorentz force with E and B fields a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Calculate E \u00d7 B drift drift = np.cross(E, B) / np.dot(B, B) # Drift velocity: (E \u00d7 B) / |B|^2 # Create 2D animation fig, ax = plt.subplots() ax.set_xlim(0, 10) ax.set_ylim(-2, 2) ax.set_aspect('equal') line, = ax.plot([], [], lw=2, label='Trajectory') point, = ax.plot([], [], 'ro', label='Particle') drift_line, = ax.plot([], [], 'r--', label='Drift') def update_drift(i): # Update trajectory line line.set_data(r[:i, 0], r[:i, 1]) # Update particle position point.set_data([r[i, 0]], [r[i, 1]]) # Wrap in lists to provide sequences # Update drift line if i > 1: # Ensure enough points for linspace t = np.linspace(0, r[i, 0], 50) # Use fixed number of points for smoothness drift_y = drift[1] * t + r[0, 1] # Drift along y-axis drift_line.set_data(t, drift_y) else: drift_line.set_data([], []) # Empty data for initial frames return line, point, drift_line # Create animation ani = FuncAnimation(fig, update_drift, frames=N - 1, interval=30, blit=True) # Set plot labels, title, and legend plt.title(\"Drift Motion in Crossed E \u00d7 B Fields (Animated)\") plt.xlabel('x') plt.ylabel('y') plt.grid(True) plt.legend() # Save animation as GIF gif_path = 'drift_motion.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html)","title":"4.3 \\(\\mathbf{E} \\times \\mathbf{B}\\) Drift Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#colab-electromagnetism-problem-1","text":"Souce Code","title":"Colab: Electromagnetism Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#summary-of-visual-insights","text":"Larmor radius is determined by the perpendicular velocity component and magnetic field: $$ r_L = \\frac{mv_\\perp}{|q|B} $$ Helical pitch corresponds to the distance moved in the field direction per revolution: $$ \\text{Pitch} = v_\\parallel T = \\frac{2\\pi m v_\\parallel}{|q|B} $$ Drift velocity from crossed fields appears as a linear translation of the helix: $$ \\mathbf{v}_{\\text{drift}} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$ These visualizations provide powerful tools to explore particle behavior and validate analytic predictions.","title":"Summary of Visual Insights"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-numerical-implementation","text":"Simulating the motion of charged particles under electromagnetic forces involves solving ordinary differential equations (ODEs) derived from the Lorentz force law : \\[ \\mathbf{F} = m\\frac{d\\mathbf{v}}{dt} = q\\left( \\mathbf{E} + \\mathbf{v} \\times \\mathbf{B} \\right) \\] This gives a coupled system of first-order ODEs: \\[ \\frac{d\\mathbf{v}}{dt} = \\frac{q}{m}(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}), \\quad \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\] These equations are nonlinear and cannot usually be solved analytically. Therefore, we use numerical methods.","title":"5. Numerical Implementation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#euler-method-first-order-approximation","text":"The Euler method is the simplest approach, using forward differences: \\[ \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{q}{m}(\\mathbf{E} + \\mathbf{v}_n \\times \\mathbf{B})\\Delta t \\] \\[ \\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v}_n \\Delta t \\] Pros : Easy to implement Cons : Low accuracy, error grows with time, unstable for stiff or oscillatory systems","title":"Euler Method (First-Order Approximation)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#runge-kutta-method-4th-order-rk4","text":"The RK4 method offers a much more accurate solution. It approximates the next state using intermediate \"slopes\": Let \\(\\mathbf{f}(t, \\mathbf{y})\\) be the derivative function for velocity and position: Compute intermediate steps: $$ \\begin{aligned} \\mathbf{k}_1 &= f(t_n, \\mathbf{y}_n) \\ \\mathbf{k}_2 &= f(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_1) \\ \\mathbf{k}_3 &= f(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_2) \\ \\mathbf{k}_4 &= f(t_n + \\Delta t, \\mathbf{y}_n + \\Delta t \\mathbf{k}_3) \\end{aligned} $$ Update the solution: $$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4) $$ Where \\(\\mathbf{y}\\) can represent either \\(\\mathbf{r}\\) or \\(\\mathbf{v}\\) . Pros : Much more accurate and stable than Euler, handles oscillatory behavior well Cons : More computationally expensive","title":"Runge-Kutta Method (4th Order, RK4)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#recommendation","text":"Use Euler method for quick visualizations or conceptual understanding. Use RK4 or the Boris method for precision and stability in realistic physics simulations (e.g., plasma modeling, cyclotron motion, fusion confinement).","title":"Recommendation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#numerical-stability","text":"Time step size \\(\\Delta t\\) must be small enough to resolve gyro-motion : \\[ \\Delta t \\ll \\frac{2\\pi m}{|q|B} = T_{\\text{cyclotron}} \\] Choosing too large a step causes inaccurate or even unstable results.","title":"Numerical Stability"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory 1. Graph-Based Modeling An electrical circuit can be modeled as an undirected weighted graph : Nodes ( \\(V\\) ): represent junctions. Edges ( \\(E\\) ): represent resistors, with weights corresponding to resistance values in ohms ( \\(\\Omega\\) ). Thus, a graph is defined as: \\[ G = (V, E) \\] Each edge \\(e \\in E\\) has an associated weight function: \\[ w: E \\rightarrow \\mathbb{R}^{+} \\] where \\(w(e)\\) is the resistance value. Note : Use a Graph if each resistor connects different pairs of nodes. Use a MultiGraph if multiple resistors exist between the same two nodes. 2. Mathematical Rules for Simplification 2.1 Series Connection When two resistors are connected end-to-end (node degree \\(=2\\) ), their resistances add directly: \\[ R_{\\text{eq}} = R_1 + R_2 + \\cdots + R_n \\] Simplification steps: - Identify a node with exactly two neighbors. - Replace the two connecting resistors with one of equivalent resistance. 2.2 Parallel Connection When multiple resistors connect the same pair of nodes, the equivalent resistance satisfies: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\cdots + \\frac{1}{R_n} \\] Or equivalently: \\[ R_{\\text{eq}} = \\left( \\sum_{i=1}^n \\frac{1}{R_i} \\right)^{-1} \\] Simplification steps: - Identify multiple edges between two nodes. - Collapse them into a single edge using the above formula. 3. Algorithm Description Given a graph \\(G = (V, E)\\) and two distinguished nodes \\(A\\) and \\(B\\) : Input Graph \\(G\\) where each edge has weight \\(w(e)\\) . Source node \\(A\\) , target node \\(B\\) . Output Equivalent resistance \\(R_{\\text{eq}}\\) between \\(A\\) and \\(B\\) . Steps While changes are possible : Series Reduction : Find nodes (except \\(A\\) and \\(B\\) ) with degree 2. Combine adjacent resistors by summing resistances. Parallel Reduction : Find multiple edges between the same two nodes. Combine using parallel formula. After each operation : Check if \\(A\\) and \\(B\\) remain connected. If disconnected: \\(R_{\\text{eq}} = \\infty\\) . Stopping condition : If only one edge exists between \\(A\\) and \\(B\\) , return its weight. 4. Pseudocode def detect_and_simplify_series(G, source, target): for node in list(G.nodes()): if node in (source, target): continue if G.degree(node) == 2: neighbors = list(G.neighbors(node)) u, w = neighbors R1 = G[node][u]['weight'] R2 = G[node][w]['weight'] G.remove_node(node) G.add_edge(u, w, weight=R1 + R2) return True return False def detect_and_simplify_parallel(G): edge_dict = {} for u, v, data in G.edges(data=True): key = tuple(sorted((u, v))) edge_dict.setdefault(key, []).append(data['weight']) for (u, v), resistances in edge_dict.items(): if len(resistances) > 1: R_eq = 1 / sum(1/r for r in resistances) G.remove_edges_from([(u, v)] * len(resistances)) G.add_edge(u, v, weight=R_eq) return True return False def simplify_graph(G, source, target): while True: changed = detect_and_simplify_series(G, source, target) changed |= detect_and_simplify_parallel(G) if not changed: break if not nx.has_path(G, source, target): return float('inf') return G[source][target]['weight'] 5. Important Observations Series and parallel reductions are associative : For series: $$ (R_1 + R_2) + R_3 = R_1 + (R_2 + R_3) $$ For parallel: $$ \\left( \\frac{1}{R_1} + \\frac{1}{R_2} \\right)^{-1} \\parallel R_3 = \\left( \\frac{1}{\\left( \\frac{1}{R_1} + \\frac{1}{R_2} \\right) + \\frac{1}{R_3}} \\right) $$ Algorithm always terminates because each operation reduces the number of nodes or edges. Edge Cases : Mesh networks (complex loops) require advanced methods (Kirchhoff\u2019s laws, Star-Delta transformations). Disconnection means \\(R_{\\text{eq}} = \\infty\\) . 6. Example Series Example Three resistors in series: G = nx.Graph() G.add_edge('A', 'B', weight=5) G.add_edge('B', 'C', weight=10) After simplifying: \\[ R_{\\text{AC}} = 5 + 10 = 15\\ \\Omega \\] Parallel Example Two resistors in parallel: G = nx.MultiGraph() G.add_edge('A', 'B', weight=8) G.add_edge('A', 'B', weight=12) After simplifying: \\[ R_{\\text{eq}} = \\left( \\frac{1}{8} + \\frac{1}{12} \\right)^{-1} = 4.8\\ \\Omega \\] 7. Visualizations In this section, we provide graphical visualizations of circuits before and after applying series and parallel simplifications. Each plot clearly shows how the graph structure evolves during reductions. 7.1 Series Simplification (a) Original Series Circuit import networkx as nx import matplotlib.pyplot as plt G = nx.Graph() G.add_edge('A', 'B', weight=5) G.add_edge('B', 'C', weight=10) pos = nx.spring_layout(G, seed=42) edge_labels = nx.get_edge_attributes(G, 'weight') plt.figure(figsize=(6, 4)) nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=700) nx.draw_networkx_edge_labels(G, pos, edge_labels={k: f\"{v}\u03a9\" for k, v in edge_labels.items()}) plt.title(\"Original Series Circuit: A \u2192 B \u2192 C\") plt.show() (b) After Series Simplification import networkx as nx import matplotlib.pyplot as plt G_simplified = nx.Graph() G_simplified.add_edge('A', 'C', weight=15) # 5\u03a9 + 10\u03a9 pos = nx.spring_layout(G_simplified, seed=42) edge_labels = nx.get_edge_attributes(G_simplified, 'weight') plt.figure(figsize=(6, 4)) nx.draw(G_simplified, pos, with_labels=True, node_color='lightgreen', node_size=700) nx.draw_networkx_edge_labels(G_simplified, pos, edge_labels={k: f\"{v}\u03a9\" for k, v in edge_labels.items()}) plt.title(\"After Series Simplification: A \u2192 C (15\u03a9)\") plt.show() 7.2 Parallel Simplification (a) Original Parallel Circuit import networkx as nx import matplotlib.pyplot as plt G_parallel = nx.MultiGraph() G_parallel.add_edge('A', 'B', weight=8) G_parallel.add_edge('A', 'B', weight=12) pos = nx.spring_layout(G_parallel, seed=42) edge_labels = {(u, v, k): d['weight'] for u, v, k, d in G_parallel.edges(keys=True, data=True)} plt.figure(figsize=(6, 4)) nx.draw(G_parallel, pos, with_labels=True, node_color='lightcoral', node_size=700) nx.draw_networkx_edge_labels( G_parallel, pos, edge_labels={(u, v): f\"{w}\u03a9\" for (u, v, k), w in edge_labels.items()} ) plt.title(\"Original Parallel Circuit: Two Resistors A \u2194 B\") plt.show() (b) After Parallel Simplification import networkx as nx import matplotlib.pyplot as plt G_parallel_simple = nx.Graph() G_parallel_simple.add_edge('A', 'B', weight=4.8) # Simplified 8\u03a9 || 12\u03a9 pos = nx.spring_layout(G_parallel_simple, seed=42) edge_labels = nx.get_edge_attributes(G_parallel_simple, 'weight') plt.figure(figsize=(6, 4)) nx.draw(G_parallel_simple, pos, with_labels=True, node_color='lightyellow', node_size=700) nx.draw_networkx_edge_labels(G_parallel_simple, pos, edge_labels={k: f\"{v:.1f}\u03a9\" for k, v in edge_labels.items()}) plt.title(\"After Parallel Simplification: A \u2194 B (4.8\u03a9)\") plt.show() Colab: Circuits Problem 1 Souce Code","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"Equivalent Resistance Using Graph Theory","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-graph-based-modeling","text":"An electrical circuit can be modeled as an undirected weighted graph : Nodes ( \\(V\\) ): represent junctions. Edges ( \\(E\\) ): represent resistors, with weights corresponding to resistance values in ohms ( \\(\\Omega\\) ). Thus, a graph is defined as: \\[ G = (V, E) \\] Each edge \\(e \\in E\\) has an associated weight function: \\[ w: E \\rightarrow \\mathbb{R}^{+} \\] where \\(w(e)\\) is the resistance value. Note : Use a Graph if each resistor connects different pairs of nodes. Use a MultiGraph if multiple resistors exist between the same two nodes.","title":"1. Graph-Based Modeling"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-mathematical-rules-for-simplification","text":"","title":"2. Mathematical Rules for Simplification"},{"location":"1%20Physics/5%20Circuits/Problem_1/#21-series-connection","text":"When two resistors are connected end-to-end (node degree \\(=2\\) ), their resistances add directly: \\[ R_{\\text{eq}} = R_1 + R_2 + \\cdots + R_n \\] Simplification steps: - Identify a node with exactly two neighbors. - Replace the two connecting resistors with one of equivalent resistance.","title":"2.1 Series Connection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#22-parallel-connection","text":"When multiple resistors connect the same pair of nodes, the equivalent resistance satisfies: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\cdots + \\frac{1}{R_n} \\] Or equivalently: \\[ R_{\\text{eq}} = \\left( \\sum_{i=1}^n \\frac{1}{R_i} \\right)^{-1} \\] Simplification steps: - Identify multiple edges between two nodes. - Collapse them into a single edge using the above formula.","title":"2.2 Parallel Connection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-algorithm-description","text":"Given a graph \\(G = (V, E)\\) and two distinguished nodes \\(A\\) and \\(B\\) :","title":"3. Algorithm Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#input","text":"Graph \\(G\\) where each edge has weight \\(w(e)\\) . Source node \\(A\\) , target node \\(B\\) .","title":"Input"},{"location":"1%20Physics/5%20Circuits/Problem_1/#output","text":"Equivalent resistance \\(R_{\\text{eq}}\\) between \\(A\\) and \\(B\\) .","title":"Output"},{"location":"1%20Physics/5%20Circuits/Problem_1/#steps","text":"While changes are possible : Series Reduction : Find nodes (except \\(A\\) and \\(B\\) ) with degree 2. Combine adjacent resistors by summing resistances. Parallel Reduction : Find multiple edges between the same two nodes. Combine using parallel formula. After each operation : Check if \\(A\\) and \\(B\\) remain connected. If disconnected: \\(R_{\\text{eq}} = \\infty\\) . Stopping condition : If only one edge exists between \\(A\\) and \\(B\\) , return its weight.","title":"Steps"},{"location":"1%20Physics/5%20Circuits/Problem_1/#4-pseudocode","text":"def detect_and_simplify_series(G, source, target): for node in list(G.nodes()): if node in (source, target): continue if G.degree(node) == 2: neighbors = list(G.neighbors(node)) u, w = neighbors R1 = G[node][u]['weight'] R2 = G[node][w]['weight'] G.remove_node(node) G.add_edge(u, w, weight=R1 + R2) return True return False def detect_and_simplify_parallel(G): edge_dict = {} for u, v, data in G.edges(data=True): key = tuple(sorted((u, v))) edge_dict.setdefault(key, []).append(data['weight']) for (u, v), resistances in edge_dict.items(): if len(resistances) > 1: R_eq = 1 / sum(1/r for r in resistances) G.remove_edges_from([(u, v)] * len(resistances)) G.add_edge(u, v, weight=R_eq) return True return False def simplify_graph(G, source, target): while True: changed = detect_and_simplify_series(G, source, target) changed |= detect_and_simplify_parallel(G) if not changed: break if not nx.has_path(G, source, target): return float('inf') return G[source][target]['weight']","title":"4. Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/#5-important-observations","text":"Series and parallel reductions are associative : For series: $$ (R_1 + R_2) + R_3 = R_1 + (R_2 + R_3) $$ For parallel: $$ \\left( \\frac{1}{R_1} + \\frac{1}{R_2} \\right)^{-1} \\parallel R_3 = \\left( \\frac{1}{\\left( \\frac{1}{R_1} + \\frac{1}{R_2} \\right) + \\frac{1}{R_3}} \\right) $$ Algorithm always terminates because each operation reduces the number of nodes or edges. Edge Cases : Mesh networks (complex loops) require advanced methods (Kirchhoff\u2019s laws, Star-Delta transformations). Disconnection means \\(R_{\\text{eq}} = \\infty\\) .","title":"5. Important Observations"},{"location":"1%20Physics/5%20Circuits/Problem_1/#6-example","text":"","title":"6. Example"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-example","text":"Three resistors in series: G = nx.Graph() G.add_edge('A', 'B', weight=5) G.add_edge('B', 'C', weight=10) After simplifying: \\[ R_{\\text{AC}} = 5 + 10 = 15\\ \\Omega \\]","title":"Series Example"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-example","text":"Two resistors in parallel: G = nx.MultiGraph() G.add_edge('A', 'B', weight=8) G.add_edge('A', 'B', weight=12) After simplifying: \\[ R_{\\text{eq}} = \\left( \\frac{1}{8} + \\frac{1}{12} \\right)^{-1} = 4.8\\ \\Omega \\]","title":"Parallel Example"},{"location":"1%20Physics/5%20Circuits/Problem_1/#7-visualizations","text":"In this section, we provide graphical visualizations of circuits before and after applying series and parallel simplifications. Each plot clearly shows how the graph structure evolves during reductions.","title":"7. Visualizations"},{"location":"1%20Physics/5%20Circuits/Problem_1/#71-series-simplification","text":"","title":"7.1 Series Simplification"},{"location":"1%20Physics/5%20Circuits/Problem_1/#a-original-series-circuit","text":"import networkx as nx import matplotlib.pyplot as plt G = nx.Graph() G.add_edge('A', 'B', weight=5) G.add_edge('B', 'C', weight=10) pos = nx.spring_layout(G, seed=42) edge_labels = nx.get_edge_attributes(G, 'weight') plt.figure(figsize=(6, 4)) nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=700) nx.draw_networkx_edge_labels(G, pos, edge_labels={k: f\"{v}\u03a9\" for k, v in edge_labels.items()}) plt.title(\"Original Series Circuit: A \u2192 B \u2192 C\") plt.show()","title":"(a) Original Series Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#b-after-series-simplification","text":"import networkx as nx import matplotlib.pyplot as plt G_simplified = nx.Graph() G_simplified.add_edge('A', 'C', weight=15) # 5\u03a9 + 10\u03a9 pos = nx.spring_layout(G_simplified, seed=42) edge_labels = nx.get_edge_attributes(G_simplified, 'weight') plt.figure(figsize=(6, 4)) nx.draw(G_simplified, pos, with_labels=True, node_color='lightgreen', node_size=700) nx.draw_networkx_edge_labels(G_simplified, pos, edge_labels={k: f\"{v}\u03a9\" for k, v in edge_labels.items()}) plt.title(\"After Series Simplification: A \u2192 C (15\u03a9)\") plt.show()","title":"(b) After Series Simplification"},{"location":"1%20Physics/5%20Circuits/Problem_1/#72-parallel-simplification","text":"","title":"7.2 Parallel Simplification"},{"location":"1%20Physics/5%20Circuits/Problem_1/#a-original-parallel-circuit","text":"import networkx as nx import matplotlib.pyplot as plt G_parallel = nx.MultiGraph() G_parallel.add_edge('A', 'B', weight=8) G_parallel.add_edge('A', 'B', weight=12) pos = nx.spring_layout(G_parallel, seed=42) edge_labels = {(u, v, k): d['weight'] for u, v, k, d in G_parallel.edges(keys=True, data=True)} plt.figure(figsize=(6, 4)) nx.draw(G_parallel, pos, with_labels=True, node_color='lightcoral', node_size=700) nx.draw_networkx_edge_labels( G_parallel, pos, edge_labels={(u, v): f\"{w}\u03a9\" for (u, v, k), w in edge_labels.items()} ) plt.title(\"Original Parallel Circuit: Two Resistors A \u2194 B\") plt.show()","title":"(a) Original Parallel Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#b-after-parallel-simplification","text":"import networkx as nx import matplotlib.pyplot as plt G_parallel_simple = nx.Graph() G_parallel_simple.add_edge('A', 'B', weight=4.8) # Simplified 8\u03a9 || 12\u03a9 pos = nx.spring_layout(G_parallel_simple, seed=42) edge_labels = nx.get_edge_attributes(G_parallel_simple, 'weight') plt.figure(figsize=(6, 4)) nx.draw(G_parallel_simple, pos, with_labels=True, node_color='lightyellow', node_size=700) nx.draw_networkx_edge_labels(G_parallel_simple, pos, edge_labels={k: f\"{v:.1f}\u03a9\" for k, v in edge_labels.items()}) plt.title(\"After Parallel Simplification: A \u2194 B (4.8\u03a9)\") plt.show()","title":"(b) After Parallel Simplification"},{"location":"1%20Physics/5%20Circuits/Problem_1/#colab-circuits-problem-1","text":"Souce Code","title":"Colab: Circuits Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}