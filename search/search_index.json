{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1: Projectile Motion Investigating the Range as a Function of the Angle of Projection Projectile motion provides a fundamental framework for understanding physics in two dimensions. This document derives the governing equations, analyzes the range as a function of the angle of projection, explores practical applications, and implements simulations to visualize key relationships. 1. Theoretical Foundation Derivation of Equations of Motion Consider a projectile launched with initial velocity \\(v_0\\) at angle \\(\\theta\\) from height \\(h\\) , under gravity \\(g\\) as the sole force. Using Newton\u2019s second law, \\(\\vec{F} = m \\vec{a}\\) , with \\(F_x = 0\\) and \\(F_y = -mg\\) : Horizontal: \\(\\frac{d^2x}{dt^2} = 0\\) . Vertical: \\(\\frac{d^2y}{dt^2} = -g\\) . Initial conditions are \\(x(0) = 0\\) , \\(y(0) = h\\) , \\(\\frac{dx}{dt}(0) = v_{0x} = v_0 \\cos\\theta\\) , \\(\\frac{dy}{dt}(0) = v_{0y} = v_0 \\sin\\theta\\) . Solving: \\[ x(t) = (v_0 \\cos\\theta) t, \\] \\[ y(t) = h + (v_0 \\sin\\theta) t - \\frac{1}{2} g t^2. \\] Trajectory Equation Eliminate \\(t\\) from \\(x(t)\\) : \\(t = \\frac{x}{v_0 \\cos\\theta}\\) . Substitute into \\(y(t)\\) : \\[ y = h + (v_0 \\sin\\theta) \\frac{x}{v_0 \\cos\\theta} - \\frac{1}{2} g \\left( \\frac{x}{v_0 \\cos\\theta} \\right)^2, \\] \\[ y = h + x \\tan\\theta - \\frac{g x^2}{2 v_0^2 \\cos^2\\theta}. \\] This parabolic form depends on \\(v_0\\) , \\(\\theta\\) , \\(h\\) , and \\(g\\) , defining a family of solutions. Family of Solutions For \\(h = 0\\) , the range \\(R\\) (where \\(y = 0\\) ) is: \\[ 0 = R \\tan\\theta - \\frac{g R^2}{2 v_0^2 \\cos^2\\theta}, \\] \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g}. \\] Varying \\(v_0\\) , \\(\\theta\\) , \\(h\\) , or \\(g\\) generates distinct trajectories, e.g., higher \\(v_0\\) flattens the curve, while \\(h \\neq 0\\) shifts the landing point. 2. Analysis of the Range Range Formula For \\(h = 0\\) : \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g}. \\] Key Parameters \\(v_0\\) : Range scales as \\(v_0^2\\) . \\(g\\) : Inversely proportional to \\(R\\) . \\(\\theta\\) : \\(\\sin 2\\theta\\) peaks at 1, affecting \\(R\\) symmetrically about 45\u00b0. Parameter Effects Increasing \\(v_0\\) : If \\(v_0\\) doubles, \\(R\\) quadruples (e.g., from 10 m/s to 20 m/s, \\(R\\) increases by 4\u00d7). Changing \\(g\\) : On the Moon ( \\(g = 1.62 \\, \\text{m/s}^2\\) ), \\(R\\) is \\(9.81 / 1.62 \\approx 6\\) times larger than on Earth. Varying \\(\\theta\\) : \\(R = 0\\) at \\(\\theta = 0^\\circ, 90^\\circ\\) ; peaks at \\(\\theta = 45^\\circ\\) . Optimal Angle Maximize \\(R = \\frac{v_0^2}{g} \\sin 2\\theta\\) : \\[ \\frac{dR}{d\\theta} = \\frac{v_0^2}{g} \\cdot 2 \\cos 2\\theta = 0, \\] \\[ \\theta = 45^\\circ, \\quad R_{\\text{max}} = \\frac{v_0^2}{g}. \\] 3. Practical Applications Scenarios Basketball : Shots follow \\(y = x \\tan\\theta - \\frac{g x^2}{2 v_0^2 \\cos^2\\theta}\\) . Artillery : Targets require adjusted \\(R\\) . Space Launches : Early trajectories approximate projectiles. Uneven Terrain For landing height \\(h_f\\) : \\[ h_f = h + R \\tan\\theta - \\frac{g R^2}{2 v_0^2 \\cos^2\\theta}, \\] solve the quadratic for \\(R\\) . For \\(h > h_f\\) , \\(R\\) increases. Additional Factors Air Resistance : \\(F_d = -k v^2\\) reduces \\(R\\) , solved numerically. Wind : Adds \\(w t\\) to \\(x(t)\\) , shifting \\(R\\) . Adaptations Use numerical methods (e.g., Runge-Kutta) for drag; adjust \\(x(t) = (v_0 \\cos\\theta + w) t\\) for wind. 4. Implementation Simulation Tool Below are Python scripts simulating projectile motion. Code 1: Plotting the Trajectory for a Single Set of Parameters import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 20.0 # Initial velocity (m/s) theta_deg = 45 # Angle in degrees g = 9.81 # Gravitational acceleration (m/s^2) h = 0.0 # Initial height (m) # Convert angle to radians theta = np.radians(theta_deg) # Time of flight (for h = 0, adjust if h != 0) t_flight = 2 * v0 * np.sin(theta) / g t = np.linspace(0, t_flight, 100) # Position equations x = v0 * np.cos(theta) * t y = h + v0 * np.sin(theta) * t - 0.5 * g * t**2 # Plot plt.figure(figsize=(8, 6)) plt.plot(x, y, label=f'\u03b8 = {theta_deg}\u00b0', color='blue') plt.title('Projectile Trajectory') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Height (m)') plt.grid(True) plt.legend() plt.axhline(0, color='black', linewidth=0.5) plt.show() Code 2: Range vs. Angle for Different Initial Velocities import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 # Gravitational acceleration (m/s^2) angles_deg = np.linspace(0, 90, 91) # Angles from 0\u00b0 to 90\u00b0 angles_rad = np.radians(angles_deg) v0_values = [10, 20, 30] # Different initial velocities (m/s) # Plot plt.figure(figsize=(8, 6)) for v0 in v0_values: R = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles_deg, R, label=f'v\u2080 = {v0} m/s') plt.title('Range vs. Angle of Projection') plt.xlabel('Angle \u03b8 (degrees)') plt.ylabel('Range R (m)') plt.grid(True) plt.legend() plt.show() Code 3: Range vs. Angle for Different Gravitational Accelerations import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 20.0 # Initial velocity (m/s) angles_deg = np.linspace(0, 90, 91) # Angles from 0\u00b0 to 90\u00b0 angles_rad = np.radians(angles_deg) g_values = {'Earth': 9.81, 'Moon': 1.62, 'Mars': 3.72} # Gravity (m/s^2) # Plot plt.figure(figsize=(8, 6)) for planet, g in g_values.items(): R = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles_deg, R, label=f'{planet} (g = {g} m/s\u00b2)') plt.title('Range vs. Angle for Different Gravities') plt.xlabel('Angle \u03b8 (degrees)') plt.ylabel('Range R (m)') plt.grid(True) plt.legend() plt.show() Code 4: Trajectory with Non-Zero Initial Height import matplotlib.pyplot as plt import numpy as np # Constants g = 9.81 # gravity (m/s^2) v0 = 25 # initial speed (m/s) angle_deg = 45 # launch angle (degrees) angle_rad = np.radians(angle_deg) # Initial heights to test initial_heights = [0, 10, 20] # in meters labels = [f\"h0 = {h} m\" for h in initial_heights] # Time array t = np.linspace(0, 5, num=500) # simulate for 5 seconds # Plotting plt.figure(figsize=(10, 6)) for h0, label in zip(initial_heights, labels): # Equations of motion x = v0 * np.cos(angle_rad) * t y = h0 + v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 # Only keep points where y >= 0 (above ground) mask = y >= 0 plt.plot(x[mask], y[mask], label=label) plt.title(\"Projectile Motion for Different Initial Heights\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.legend() plt.grid(True) plt.show() Deliverables Equations : Derived \\(x(t)\\) , \\(y(t)\\) , and \\(R\\) . Graphs : Trajectory and \\(R\\) vs. \\(\\theta\\) plots. Limitations : Ideal model ignores drag; extend with numerical solvers. Conclusion The range \\(R = \\frac{v_0^2 \\sin 2\\theta}{g}\\) peaks at 45\u00b0, scales with \\(v_0^2\\) , and adapts to real-world factors via modifications, demonstrated through simulations. Colab Souce Code","title":"Problem 1:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion","text":"","title":"Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"Projectile motion provides a fundamental framework for understanding physics in two dimensions. This document derives the governing equations, analyzes the range as a function of the angle of projection, explores practical applications, and implements simulations to visualize key relationships.","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-equations-of-motion","text":"Consider a projectile launched with initial velocity \\(v_0\\) at angle \\(\\theta\\) from height \\(h\\) , under gravity \\(g\\) as the sole force. Using Newton\u2019s second law, \\(\\vec{F} = m \\vec{a}\\) , with \\(F_x = 0\\) and \\(F_y = -mg\\) : Horizontal: \\(\\frac{d^2x}{dt^2} = 0\\) . Vertical: \\(\\frac{d^2y}{dt^2} = -g\\) . Initial conditions are \\(x(0) = 0\\) , \\(y(0) = h\\) , \\(\\frac{dx}{dt}(0) = v_{0x} = v_0 \\cos\\theta\\) , \\(\\frac{dy}{dt}(0) = v_{0y} = v_0 \\sin\\theta\\) . Solving: \\[ x(t) = (v_0 \\cos\\theta) t, \\] \\[ y(t) = h + (v_0 \\sin\\theta) t - \\frac{1}{2} g t^2. \\]","title":"Derivation of Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#trajectory-equation","text":"Eliminate \\(t\\) from \\(x(t)\\) : \\(t = \\frac{x}{v_0 \\cos\\theta}\\) . Substitute into \\(y(t)\\) : \\[ y = h + (v_0 \\sin\\theta) \\frac{x}{v_0 \\cos\\theta} - \\frac{1}{2} g \\left( \\frac{x}{v_0 \\cos\\theta} \\right)^2, \\] \\[ y = h + x \\tan\\theta - \\frac{g x^2}{2 v_0^2 \\cos^2\\theta}. \\] This parabolic form depends on \\(v_0\\) , \\(\\theta\\) , \\(h\\) , and \\(g\\) , defining a family of solutions.","title":"Trajectory Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"For \\(h = 0\\) , the range \\(R\\) (where \\(y = 0\\) ) is: \\[ 0 = R \\tan\\theta - \\frac{g R^2}{2 v_0^2 \\cos^2\\theta}, \\] \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g}. \\] Varying \\(v_0\\) , \\(\\theta\\) , \\(h\\) , or \\(g\\) generates distinct trajectories, e.g., higher \\(v_0\\) flattens the curve, while \\(h \\neq 0\\) shifts the landing point.","title":"Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-formula","text":"For \\(h = 0\\) : \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g}. \\]","title":"Range Formula"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-parameters","text":"\\(v_0\\) : Range scales as \\(v_0^2\\) . \\(g\\) : Inversely proportional to \\(R\\) . \\(\\theta\\) : \\(\\sin 2\\theta\\) peaks at 1, affecting \\(R\\) symmetrically about 45\u00b0.","title":"Key Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#parameter-effects","text":"Increasing \\(v_0\\) : If \\(v_0\\) doubles, \\(R\\) quadruples (e.g., from 10 m/s to 20 m/s, \\(R\\) increases by 4\u00d7). Changing \\(g\\) : On the Moon ( \\(g = 1.62 \\, \\text{m/s}^2\\) ), \\(R\\) is \\(9.81 / 1.62 \\approx 6\\) times larger than on Earth. Varying \\(\\theta\\) : \\(R = 0\\) at \\(\\theta = 0^\\circ, 90^\\circ\\) ; peaks at \\(\\theta = 45^\\circ\\) .","title":"Parameter Effects"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#optimal-angle","text":"Maximize \\(R = \\frac{v_0^2}{g} \\sin 2\\theta\\) : \\[ \\frac{dR}{d\\theta} = \\frac{v_0^2}{g} \\cdot 2 \\cos 2\\theta = 0, \\] \\[ \\theta = 45^\\circ, \\quad R_{\\text{max}} = \\frac{v_0^2}{g}. \\]","title":"Optimal Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#scenarios","text":"Basketball : Shots follow \\(y = x \\tan\\theta - \\frac{g x^2}{2 v_0^2 \\cos^2\\theta}\\) . Artillery : Targets require adjusted \\(R\\) . Space Launches : Early trajectories approximate projectiles.","title":"Scenarios"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#uneven-terrain","text":"For landing height \\(h_f\\) : \\[ h_f = h + R \\tan\\theta - \\frac{g R^2}{2 v_0^2 \\cos^2\\theta}, \\] solve the quadratic for \\(R\\) . For \\(h > h_f\\) , \\(R\\) increases.","title":"Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#additional-factors","text":"Air Resistance : \\(F_d = -k v^2\\) reduces \\(R\\) , solved numerically. Wind : Adds \\(w t\\) to \\(x(t)\\) , shifting \\(R\\) .","title":"Additional Factors"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#adaptations","text":"Use numerical methods (e.g., Runge-Kutta) for drag; adjust \\(x(t) = (v_0 \\cos\\theta + w) t\\) for wind.","title":"Adaptations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#simulation-tool","text":"Below are Python scripts simulating projectile motion.","title":"Simulation Tool"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#code-1-plotting-the-trajectory-for-a-single-set-of-parameters","text":"import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 20.0 # Initial velocity (m/s) theta_deg = 45 # Angle in degrees g = 9.81 # Gravitational acceleration (m/s^2) h = 0.0 # Initial height (m) # Convert angle to radians theta = np.radians(theta_deg) # Time of flight (for h = 0, adjust if h != 0) t_flight = 2 * v0 * np.sin(theta) / g t = np.linspace(0, t_flight, 100) # Position equations x = v0 * np.cos(theta) * t y = h + v0 * np.sin(theta) * t - 0.5 * g * t**2 # Plot plt.figure(figsize=(8, 6)) plt.plot(x, y, label=f'\u03b8 = {theta_deg}\u00b0', color='blue') plt.title('Projectile Trajectory') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Height (m)') plt.grid(True) plt.legend() plt.axhline(0, color='black', linewidth=0.5) plt.show()","title":"Code 1: Plotting the Trajectory for a Single Set of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#code-2-range-vs-angle-for-different-initial-velocities","text":"import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 # Gravitational acceleration (m/s^2) angles_deg = np.linspace(0, 90, 91) # Angles from 0\u00b0 to 90\u00b0 angles_rad = np.radians(angles_deg) v0_values = [10, 20, 30] # Different initial velocities (m/s) # Plot plt.figure(figsize=(8, 6)) for v0 in v0_values: R = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles_deg, R, label=f'v\u2080 = {v0} m/s') plt.title('Range vs. Angle of Projection') plt.xlabel('Angle \u03b8 (degrees)') plt.ylabel('Range R (m)') plt.grid(True) plt.legend() plt.show()","title":"Code 2: Range vs. Angle for Different Initial Velocities"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#code-3-range-vs-angle-for-different-gravitational-accelerations","text":"import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 20.0 # Initial velocity (m/s) angles_deg = np.linspace(0, 90, 91) # Angles from 0\u00b0 to 90\u00b0 angles_rad = np.radians(angles_deg) g_values = {'Earth': 9.81, 'Moon': 1.62, 'Mars': 3.72} # Gravity (m/s^2) # Plot plt.figure(figsize=(8, 6)) for planet, g in g_values.items(): R = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles_deg, R, label=f'{planet} (g = {g} m/s\u00b2)') plt.title('Range vs. Angle for Different Gravities') plt.xlabel('Angle \u03b8 (degrees)') plt.ylabel('Range R (m)') plt.grid(True) plt.legend() plt.show()","title":"Code 3: Range vs. Angle for Different Gravitational Accelerations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#code-4-trajectory-with-non-zero-initial-height","text":"import matplotlib.pyplot as plt import numpy as np # Constants g = 9.81 # gravity (m/s^2) v0 = 25 # initial speed (m/s) angle_deg = 45 # launch angle (degrees) angle_rad = np.radians(angle_deg) # Initial heights to test initial_heights = [0, 10, 20] # in meters labels = [f\"h0 = {h} m\" for h in initial_heights] # Time array t = np.linspace(0, 5, num=500) # simulate for 5 seconds # Plotting plt.figure(figsize=(10, 6)) for h0, label in zip(initial_heights, labels): # Equations of motion x = v0 * np.cos(angle_rad) * t y = h0 + v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 # Only keep points where y >= 0 (above ground) mask = y >= 0 plt.plot(x[mask], y[mask], label=label) plt.title(\"Projectile Motion for Different Initial Heights\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.legend() plt.grid(True) plt.show()","title":"Code 4: Trajectory with Non-Zero Initial Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#deliverables","text":"Equations : Derived \\(x(t)\\) , \\(y(t)\\) , and \\(R\\) . Graphs : Trajectory and \\(R\\) vs. \\(\\theta\\) plots. Limitations : Ideal model ignores drag; extend with numerical solvers.","title":"Deliverables"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"The range \\(R = \\frac{v_0^2 \\sin 2\\theta}{g}\\) peaks at 45\u00b0, scales with \\(v_0^2\\) , and adapts to real-world factors via modifications, demonstrated through simulations.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#colab","text":"Souce Code","title":"Colab"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2: Forced Damped Pendulum 1. Theoretical Foundation The forced damped pendulum is a nonlinear system governed by: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) $$ For small angles, \\(\\sin\\theta \\approx \\theta\\) , yielding a linear equation: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) $$ where \\(\\omega_0 = \\sqrt{g/L}\\) . Solutions include transient decay and a steady-state response: $$ \\theta_p(t) = D \\cos(\\omega t - \\phi), \\quad D = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (b \\omega)^2}} $$ Resonance occurs when \\(\\omega \\approx \\omega_0\\) , maximizing amplitude. 2. System Dynamics Damping \\((b)\\) : Higher \\(b\\) reduces oscillation amplitude and shifts resonance. Driving Amplitude \\((A)\\) : Larger \\(A\\) increases response, introducing nonlinear effects. Driving Frequency \\((\\omega)\\) : Controls synchronization and energy transfer. Chaos : Increasing \\(A\\) can induce period doubling and chaotic behavior. 3. Applications Energy Harvesting : Piezoelectric devices optimize energy capture by tuning \\(\\omega_0\\) . Bridges : Wind-induced oscillations (e.g., Tacoma Narrows) align with resonance behavior. Oscillating Circuits : Analogous to RLC circuits with \\(\\omega_0\\) and damping. 4. Implementation of the Forced Damped Pendulum Simulation This section demonstrates three different pendulum scenarios: 1. Pure pendulum (no damping, no external force) 2. Damped pendulum 3. Forced pendulum without damping 4.1 Pure Pendulum (No Damping, No External Force) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def pure_pendulum(state, t): theta, v = state dtheta_dt = v dv_dt = -np.sin(theta) # No damping (b=0) and no external force (A=0) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 50, 1000) # Time array initial_conditions = [0.1, 0] # [theta0, v0] # Solve sol = odeint(pure_pendulum, initial_conditions, t) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Pure Pendulum: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Pure Pendulum: Phase Space') ax2.grid(True) plt.tight_layout() plt.show() Output : Two plots showing the pure pendulum motion: 1. Left: Time series of angular displacement \u03b8(t) 2. Right: Phase space trajectory showing the conservation of energy (closed orbit) 4.2 Damped Pendulum import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def damped_pendulum(state, t, b): theta, v = state dtheta_dt = v dv_dt = -b * v - np.sin(theta) # With damping (b\u22600) but no external force (A=0) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 50, 1000) b = 0.5 # Damping coefficient initial_conditions = [0.1, 0] # Solve sol = odeint(damped_pendulum, initial_conditions, t, args=(b,)) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Damped Pendulum: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Damped Pendulum: Phase Space') ax2.grid(True) plt.tight_layout() plt.show() Output : Two plots showing the damped pendulum motion: 1. Left: Time series showing the decaying oscillations 2. Right: Phase space trajectory showing the energy dissipation (spiral trajectory) 4.3 Forced Pendulum without Damping import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def forced_pendulum(state, t, A, omega): theta, v = state dtheta_dt = v dv_dt = -np.sin(theta) + A * np.cos(omega * t) # No damping (b=0) but with external force (A\u22600) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 50, 1000) A = 0.5 # External force amplitude omega = 2/3 # Driving frequency initial_conditions = [0.1, 0] # Solve sol = odeint(forced_pendulum, initial_conditions, t, args=(A, omega)) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Forced Pendulum: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Forced Pendulum: Phase Space') ax2.grid(True) plt.tight_layout() plt.show() Output : Two plots showing the forced pendulum motion: 1. Left: Time series showing the driven oscillations 2. Right: Phase space trajectory showing the complex dynamics due to the external force 5. Colab Souce Code 6. Forced Damped Pendulum: Chaos & Resonance 6.1 Chaotic Motion in the Forced Damped Pendulum For certain values of the damping coefficient $ b $, driving amplitude $ A $, and driving frequency $ \\omega $, the forced damped pendulum exhibits chaotic behavior. A common set of parameters leading to chaos is: - $ b = 0.5 $ (moderate damping) - $ A = 1.2 $ (strong forcing) - $ \\omega = \\frac{2}{3} $ (driving frequency) Let's simulate the chaotic motion: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def chaotic_pendulum(state, t, b, A, omega): theta, v = state dtheta_dt = v dv_dt = -b * v - np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 100, 5000) # Extended time for chaotic behavior b = 0.5 A = 1.2 omega = 2/3 initial_conditions = [0.1, 0] # Solve sol = odeint(chaotic_pendulum, initial_conditions, t, args=(b, A, omega)) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Chaotic Pendulum: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Chaotic Pendulum: Phase Space') ax2.grid(True) plt.tight_layout() plt.show() Expected Output: Time Series Plot : Irregular oscillations with no periodic pattern. Phase Space Plot : A strange attractor instead of a closed orbit, characteristic of chaotic dynamics. 6.2 Resonance in the Forced Damped Pendulum Resonance occurs when the driving frequency $ \\omega $ is close to the system\u2019s natural frequency $ \\omega_0 = \\sqrt{g/L} $. This results in large oscillations. Let\u2019s simulate resonance by setting: - $ b = 0.1 $ (low damping) - $ A = 0.5 $ (moderate forcing) - $ \\omega = \\omega_0 \\approx 1 $ (resonance condition) # Define the system def resonance_pendulum(state, t, b, A, omega): theta, v = state dtheta_dt = v dv_dt = -b * v - np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 100, 5000) # Long simulation to see resonance effects b = 0.1 A = 0.5 omega = 1 # Resonance condition initial_conditions = [0.1, 0] # Solve sol = odeint(resonance_pendulum, initial_conditions, t, args=(b, A, omega)) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Resonance: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Resonance: Phase Space') ax2.grid(True) plt.tight_layout() plt.show() Expected Output: Time Series Plot : Oscillations with increasing amplitude over time. Phase Space Plot : Large periodic orbits, showing energy accumulation due to resonance.","title":"Problem 2:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum","text":"","title":"Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The forced damped pendulum is a nonlinear system governed by: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) $$ For small angles, \\(\\sin\\theta \\approx \\theta\\) , yielding a linear equation: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) $$ where \\(\\omega_0 = \\sqrt{g/L}\\) . Solutions include transient decay and a steady-state response: $$ \\theta_p(t) = D \\cos(\\omega t - \\phi), \\quad D = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (b \\omega)^2}} $$ Resonance occurs when \\(\\omega \\approx \\omega_0\\) , maximizing amplitude.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-system-dynamics","text":"Damping \\((b)\\) : Higher \\(b\\) reduces oscillation amplitude and shifts resonance. Driving Amplitude \\((A)\\) : Larger \\(A\\) increases response, introducing nonlinear effects. Driving Frequency \\((\\omega)\\) : Controls synchronization and energy transfer. Chaos : Increasing \\(A\\) can induce period doubling and chaotic behavior.","title":"2. System Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-applications","text":"Energy Harvesting : Piezoelectric devices optimize energy capture by tuning \\(\\omega_0\\) . Bridges : Wind-induced oscillations (e.g., Tacoma Narrows) align with resonance behavior. Oscillating Circuits : Analogous to RLC circuits with \\(\\omega_0\\) and damping.","title":"3. Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-of-the-forced-damped-pendulum-simulation","text":"This section demonstrates three different pendulum scenarios: 1. Pure pendulum (no damping, no external force) 2. Damped pendulum 3. Forced pendulum without damping","title":"4. Implementation of the Forced Damped Pendulum Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#41-pure-pendulum-no-damping-no-external-force","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def pure_pendulum(state, t): theta, v = state dtheta_dt = v dv_dt = -np.sin(theta) # No damping (b=0) and no external force (A=0) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 50, 1000) # Time array initial_conditions = [0.1, 0] # [theta0, v0] # Solve sol = odeint(pure_pendulum, initial_conditions, t) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Pure Pendulum: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Pure Pendulum: Phase Space') ax2.grid(True) plt.tight_layout() plt.show() Output : Two plots showing the pure pendulum motion: 1. Left: Time series of angular displacement \u03b8(t) 2. Right: Phase space trajectory showing the conservation of energy (closed orbit)","title":"4.1 Pure Pendulum (No Damping, No External Force)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#42-damped-pendulum","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def damped_pendulum(state, t, b): theta, v = state dtheta_dt = v dv_dt = -b * v - np.sin(theta) # With damping (b\u22600) but no external force (A=0) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 50, 1000) b = 0.5 # Damping coefficient initial_conditions = [0.1, 0] # Solve sol = odeint(damped_pendulum, initial_conditions, t, args=(b,)) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Damped Pendulum: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Damped Pendulum: Phase Space') ax2.grid(True) plt.tight_layout() plt.show() Output : Two plots showing the damped pendulum motion: 1. Left: Time series showing the decaying oscillations 2. Right: Phase space trajectory showing the energy dissipation (spiral trajectory)","title":"4.2 Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#43-forced-pendulum-without-damping","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def forced_pendulum(state, t, A, omega): theta, v = state dtheta_dt = v dv_dt = -np.sin(theta) + A * np.cos(omega * t) # No damping (b=0) but with external force (A\u22600) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 50, 1000) A = 0.5 # External force amplitude omega = 2/3 # Driving frequency initial_conditions = [0.1, 0] # Solve sol = odeint(forced_pendulum, initial_conditions, t, args=(A, omega)) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Forced Pendulum: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Forced Pendulum: Phase Space') ax2.grid(True) plt.tight_layout() plt.show() Output : Two plots showing the forced pendulum motion: 1. Left: Time series showing the driven oscillations 2. Right: Phase space trajectory showing the complex dynamics due to the external force","title":"4.3 Forced Pendulum without Damping"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-colab","text":"Souce Code","title":"5. Colab"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-forced-damped-pendulum-chaos-resonance","text":"","title":"6. Forced Damped Pendulum: Chaos &amp; Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#61-chaotic-motion-in-the-forced-damped-pendulum","text":"For certain values of the damping coefficient $ b $, driving amplitude $ A $, and driving frequency $ \\omega $, the forced damped pendulum exhibits chaotic behavior. A common set of parameters leading to chaos is: - $ b = 0.5 $ (moderate damping) - $ A = 1.2 $ (strong forcing) - $ \\omega = \\frac{2}{3} $ (driving frequency) Let's simulate the chaotic motion: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def chaotic_pendulum(state, t, b, A, omega): theta, v = state dtheta_dt = v dv_dt = -b * v - np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 100, 5000) # Extended time for chaotic behavior b = 0.5 A = 1.2 omega = 2/3 initial_conditions = [0.1, 0] # Solve sol = odeint(chaotic_pendulum, initial_conditions, t, args=(b, A, omega)) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Chaotic Pendulum: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Chaotic Pendulum: Phase Space') ax2.grid(True) plt.tight_layout() plt.show()","title":"6.1 Chaotic Motion in the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#expected-output","text":"Time Series Plot : Irregular oscillations with no periodic pattern. Phase Space Plot : A strange attractor instead of a closed orbit, characteristic of chaotic dynamics.","title":"Expected Output:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#62-resonance-in-the-forced-damped-pendulum","text":"Resonance occurs when the driving frequency $ \\omega $ is close to the system\u2019s natural frequency $ \\omega_0 = \\sqrt{g/L} $. This results in large oscillations. Let\u2019s simulate resonance by setting: - $ b = 0.1 $ (low damping) - $ A = 0.5 $ (moderate forcing) - $ \\omega = \\omega_0 \\approx 1 $ (resonance condition) # Define the system def resonance_pendulum(state, t, b, A, omega): theta, v = state dtheta_dt = v dv_dt = -b * v - np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 100, 5000) # Long simulation to see resonance effects b = 0.1 A = 0.5 omega = 1 # Resonance condition initial_conditions = [0.1, 0] # Solve sol = odeint(resonance_pendulum, initial_conditions, t, args=(b, A, omega)) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Resonance: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Resonance: Phase Space') ax2.grid(True) plt.tight_layout() plt.show()","title":"6.2 Resonance in the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#expected-output_1","text":"Time Series Plot : Oscillations with increasing amplitude over time. Phase Space Plot : Large periodic orbits, showing energy accumulation due to resonance.","title":"Expected Output:"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Hello","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"Hello","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}