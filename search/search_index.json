{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Projectile motion provides a fundamental framework for understanding physics in two dimensions. This document derives the governing equations, analyzes the range as a function of the angle of projection, explores practical applications, and implements simulations to visualize key relationships. 1. Theoretical Foundation Derivation of Equations of Motion Consider a projectile launched with initial velocity \\(v_0\\) at angle \\(\\theta\\) from height \\(h\\) , under gravity \\(g\\) as the sole force. Using Newton\u2019s second law, \\(\\vec{F} = m \\vec{a}\\) , with \\(F_x = 0\\) and \\(F_y = -mg\\) : Horizontal: \\(\\frac{d^2x}{dt^2} = 0\\) . Vertical: \\(\\frac{d^2y}{dt^2} = -g\\) . Initial conditions are \\(x(0) = 0\\) , \\(y(0) = h\\) , \\(\\frac{dx}{dt}(0) = v_{0x} = v_0 \\cos\\theta\\) , \\(\\frac{dy}{dt}(0) = v_{0y} = v_0 \\sin\\theta\\) . Solving: \\[ x(t) = (v_0 \\cos\\theta) t, \\] \\[ y(t) = h + (v_0 \\sin\\theta) t - \\frac{1}{2} g t^2. \\] Trajectory Equation Eliminate \\(t\\) from \\(x(t)\\) : \\(t = \\frac{x}{v_0 \\cos\\theta}\\) . Substitute into \\(y(t)\\) : \\[ y = h + (v_0 \\sin\\theta) \\frac{x}{v_0 \\cos\\theta} - \\frac{1}{2} g \\left( \\frac{x}{v_0 \\cos\\theta} \\right)^2, \\] \\[ y = h + x \\tan\\theta - \\frac{g x^2}{2 v_0^2 \\cos^2\\theta}. \\] This parabolic form depends on \\(v_0\\) , \\(\\theta\\) , \\(h\\) , and \\(g\\) , defining a family of solutions. Family of Solutions For \\(h = 0\\) , the range \\(R\\) (where \\(y = 0\\) ) is: \\[ 0 = R \\tan\\theta - \\frac{g R^2}{2 v_0^2 \\cos^2\\theta}, \\] \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g}. \\] Varying \\(v_0\\) , \\(\\theta\\) , \\(h\\) , or \\(g\\) generates distinct trajectories, e.g., higher \\(v_0\\) flattens the curve, while \\(h \\neq 0\\) shifts the landing point. 2. Analysis of the Range Range Formula For \\(h = 0\\) : \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g}. \\] Key Parameters \\(v_0\\) : Range scales as \\(v_0^2\\) . \\(g\\) : Inversely proportional to \\(R\\) . \\(\\theta\\) : \\(\\sin 2\\theta\\) peaks at 1, affecting \\(R\\) symmetrically about 45\u00b0. Parameter Effects Increasing \\(v_0\\) : If \\(v_0\\) doubles, \\(R\\) quadruples (e.g., from 10 m/s to 20 m/s, \\(R\\) increases by 4\u00d7). Changing \\(g\\) : On the Moon ( \\(g = 1.62 \\, \\text{m/s}^2\\) ), \\(R\\) is \\(9.81 / 1.62 \\approx 6\\) times larger than on Earth. Varying \\(\\theta\\) : \\(R = 0\\) at \\(\\theta = 0^\\circ, 90^\\circ\\) ; peaks at \\(\\theta = 45^\\circ\\) . Optimal Angle Maximize \\(R = \\frac{v_0^2}{g} \\sin 2\\theta\\) : \\[ \\frac{dR}{d\\theta} = \\frac{v_0^2}{g} \\cdot 2 \\cos 2\\theta = 0, \\] \\[ \\theta = 45^\\circ, \\quad R_{\\text{max}} = \\frac{v_0^2}{g}. \\] 3. Practical Applications Scenarios Basketball : Shots follow \\(y = x \\tan\\theta - \\frac{g x^2}{2 v_0^2 \\cos^2\\theta}\\) . Artillery : Targets require adjusted \\(R\\) . Space Launches : Early trajectories approximate projectiles. Uneven Terrain For landing height \\(h_f\\) : \\[ h_f = h + R \\tan\\theta - \\frac{g R^2}{2 v_0^2 \\cos^2\\theta}, \\] solve the quadratic for \\(R\\) . For \\(h > h_f\\) , \\(R\\) increases. Additional Factors Air Resistance : \\(F_d = -k v^2\\) reduces \\(R\\) , solved numerically. Wind : Adds \\(w t\\) to \\(x(t)\\) , shifting \\(R\\) . Adaptations Use numerical methods (e.g., Runge-Kutta) for drag; adjust \\(x(t) = (v_0 \\cos\\theta + w) t\\) for wind. 4. Implementation Simulation Tool Below are Python scripts simulating projectile motion. Code 1: Plotting the Trajectory for a Single Set of Parameters import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 20.0 # Initial velocity (m/s) theta_deg = 45 # Angle in degrees g = 9.81 # Gravitational acceleration (m/s^2) h = 0.0 # Initial height (m) # Convert angle to radians theta = np.radians(theta_deg) # Time of flight (for h = 0, adjust if h != 0) t_flight = 2 * v0 * np.sin(theta) / g t = np.linspace(0, t_flight, 100) # Position equations x = v0 * np.cos(theta) * t y = h + v0 * np.sin(theta) * t - 0.5 * g * t**2 # Plot plt.figure(figsize=(8, 6)) plt.plot(x, y, label=f'\u03b8 = {theta_deg}\u00b0', color='blue') plt.title('Projectile Trajectory') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Height (m)') plt.grid(True) plt.legend() plt.axhline(0, color='black', linewidth=0.5) plt.show() Code 2: Range vs. Angle for Different Initial Velocities import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 # Gravitational acceleration (m/s^2) angles_deg = np.linspace(0, 90, 91) # Angles from 0\u00b0 to 90\u00b0 angles_rad = np.radians(angles_deg) v0_values = [10, 20, 30] # Different initial velocities (m/s) # Plot plt.figure(figsize=(8, 6)) for v0 in v0_values: R = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles_deg, R, label=f'v\u2080 = {v0} m/s') plt.title('Range vs. Angle of Projection') plt.xlabel('Angle \u03b8 (degrees)') plt.ylabel('Range R (m)') plt.grid(True) plt.legend() plt.show() Code 3: Range vs. Angle for Different Gravitational Accelerations import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 20.0 # Initial velocity (m/s) angles_deg = np.linspace(0, 90, 91) # Angles from 0\u00b0 to 90\u00b0 angles_rad = np.radians(angles_deg) g_values = {'Earth': 9.81, 'Moon': 1.62, 'Mars': 3.72} # Gravity (m/s^2) # Plot plt.figure(figsize=(8, 6)) for planet, g in g_values.items(): R = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles_deg, R, label=f'{planet} (g = {g} m/s\u00b2)') plt.title('Range vs. Angle for Different Gravities') plt.xlabel('Angle \u03b8 (degrees)') plt.ylabel('Range R (m)') plt.grid(True) plt.legend() plt.show() Code 4: Trajectory with Non-Zero Initial Height import matplotlib.pyplot as plt import numpy as np # Constants g = 9.81 # gravity (m/s^2) v0 = 25 # initial speed (m/s) angle_deg = 45 # launch angle (degrees) angle_rad = np.radians(angle_deg) # Initial heights to test initial_heights = [0, 10, 20] # in meters labels = [f\"h0 = {h} m\" for h in initial_heights] # Time array t = np.linspace(0, 5, num=500) # simulate for 5 seconds # Plotting plt.figure(figsize=(10, 6)) for h0, label in zip(initial_heights, labels): # Equations of motion x = v0 * np.cos(angle_rad) * t y = h0 + v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 # Only keep points where y >= 0 (above ground) mask = y >= 0 plt.plot(x[mask], y[mask], label=label) plt.title(\"Projectile Motion for Different Initial Heights\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.legend() plt.grid(True) plt.show() Deliverables Equations : Derived \\(x(t)\\) , \\(y(t)\\) , and \\(R\\) . Graphs : Trajectory and \\(R\\) vs. \\(\\theta\\) plots. Limitations : Ideal model ignores drag; extend with numerical solvers. Conclusion The range \\(R = \\frac{v_0^2 \\sin 2\\theta}{g}\\) peaks at 45\u00b0, scales with \\(v_0^2\\) , and adapts to real-world factors via modifications, demonstrated through simulations. Colab Souce Code","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"Investigating the Range as a Function of the Angle of Projection Projectile motion provides a fundamental framework for understanding physics in two dimensions. This document derives the governing equations, analyzes the range as a function of the angle of projection, explores practical applications, and implements simulations to visualize key relationships.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-equations-of-motion","text":"Consider a projectile launched with initial velocity \\(v_0\\) at angle \\(\\theta\\) from height \\(h\\) , under gravity \\(g\\) as the sole force. Using Newton\u2019s second law, \\(\\vec{F} = m \\vec{a}\\) , with \\(F_x = 0\\) and \\(F_y = -mg\\) : Horizontal: \\(\\frac{d^2x}{dt^2} = 0\\) . Vertical: \\(\\frac{d^2y}{dt^2} = -g\\) . Initial conditions are \\(x(0) = 0\\) , \\(y(0) = h\\) , \\(\\frac{dx}{dt}(0) = v_{0x} = v_0 \\cos\\theta\\) , \\(\\frac{dy}{dt}(0) = v_{0y} = v_0 \\sin\\theta\\) . Solving: \\[ x(t) = (v_0 \\cos\\theta) t, \\] \\[ y(t) = h + (v_0 \\sin\\theta) t - \\frac{1}{2} g t^2. \\]","title":"Derivation of Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#trajectory-equation","text":"Eliminate \\(t\\) from \\(x(t)\\) : \\(t = \\frac{x}{v_0 \\cos\\theta}\\) . Substitute into \\(y(t)\\) : \\[ y = h + (v_0 \\sin\\theta) \\frac{x}{v_0 \\cos\\theta} - \\frac{1}{2} g \\left( \\frac{x}{v_0 \\cos\\theta} \\right)^2, \\] \\[ y = h + x \\tan\\theta - \\frac{g x^2}{2 v_0^2 \\cos^2\\theta}. \\] This parabolic form depends on \\(v_0\\) , \\(\\theta\\) , \\(h\\) , and \\(g\\) , defining a family of solutions.","title":"Trajectory Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"For \\(h = 0\\) , the range \\(R\\) (where \\(y = 0\\) ) is: \\[ 0 = R \\tan\\theta - \\frac{g R^2}{2 v_0^2 \\cos^2\\theta}, \\] \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g}. \\] Varying \\(v_0\\) , \\(\\theta\\) , \\(h\\) , or \\(g\\) generates distinct trajectories, e.g., higher \\(v_0\\) flattens the curve, while \\(h \\neq 0\\) shifts the landing point.","title":"Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-formula","text":"For \\(h = 0\\) : \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g}. \\]","title":"Range Formula"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-parameters","text":"\\(v_0\\) : Range scales as \\(v_0^2\\) . \\(g\\) : Inversely proportional to \\(R\\) . \\(\\theta\\) : \\(\\sin 2\\theta\\) peaks at 1, affecting \\(R\\) symmetrically about 45\u00b0.","title":"Key Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#parameter-effects","text":"Increasing \\(v_0\\) : If \\(v_0\\) doubles, \\(R\\) quadruples (e.g., from 10 m/s to 20 m/s, \\(R\\) increases by 4\u00d7). Changing \\(g\\) : On the Moon ( \\(g = 1.62 \\, \\text{m/s}^2\\) ), \\(R\\) is \\(9.81 / 1.62 \\approx 6\\) times larger than on Earth. Varying \\(\\theta\\) : \\(R = 0\\) at \\(\\theta = 0^\\circ, 90^\\circ\\) ; peaks at \\(\\theta = 45^\\circ\\) .","title":"Parameter Effects"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#optimal-angle","text":"Maximize \\(R = \\frac{v_0^2}{g} \\sin 2\\theta\\) : \\[ \\frac{dR}{d\\theta} = \\frac{v_0^2}{g} \\cdot 2 \\cos 2\\theta = 0, \\] \\[ \\theta = 45^\\circ, \\quad R_{\\text{max}} = \\frac{v_0^2}{g}. \\]","title":"Optimal Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#scenarios","text":"Basketball : Shots follow \\(y = x \\tan\\theta - \\frac{g x^2}{2 v_0^2 \\cos^2\\theta}\\) . Artillery : Targets require adjusted \\(R\\) . Space Launches : Early trajectories approximate projectiles.","title":"Scenarios"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#uneven-terrain","text":"For landing height \\(h_f\\) : \\[ h_f = h + R \\tan\\theta - \\frac{g R^2}{2 v_0^2 \\cos^2\\theta}, \\] solve the quadratic for \\(R\\) . For \\(h > h_f\\) , \\(R\\) increases.","title":"Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#additional-factors","text":"Air Resistance : \\(F_d = -k v^2\\) reduces \\(R\\) , solved numerically. Wind : Adds \\(w t\\) to \\(x(t)\\) , shifting \\(R\\) .","title":"Additional Factors"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#adaptations","text":"Use numerical methods (e.g., Runge-Kutta) for drag; adjust \\(x(t) = (v_0 \\cos\\theta + w) t\\) for wind.","title":"Adaptations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#simulation-tool","text":"Below are Python scripts simulating projectile motion.","title":"Simulation Tool"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#code-1-plotting-the-trajectory-for-a-single-set-of-parameters","text":"import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 20.0 # Initial velocity (m/s) theta_deg = 45 # Angle in degrees g = 9.81 # Gravitational acceleration (m/s^2) h = 0.0 # Initial height (m) # Convert angle to radians theta = np.radians(theta_deg) # Time of flight (for h = 0, adjust if h != 0) t_flight = 2 * v0 * np.sin(theta) / g t = np.linspace(0, t_flight, 100) # Position equations x = v0 * np.cos(theta) * t y = h + v0 * np.sin(theta) * t - 0.5 * g * t**2 # Plot plt.figure(figsize=(8, 6)) plt.plot(x, y, label=f'\u03b8 = {theta_deg}\u00b0', color='blue') plt.title('Projectile Trajectory') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Height (m)') plt.grid(True) plt.legend() plt.axhline(0, color='black', linewidth=0.5) plt.show()","title":"Code 1: Plotting the Trajectory for a Single Set of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#code-2-range-vs-angle-for-different-initial-velocities","text":"import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 # Gravitational acceleration (m/s^2) angles_deg = np.linspace(0, 90, 91) # Angles from 0\u00b0 to 90\u00b0 angles_rad = np.radians(angles_deg) v0_values = [10, 20, 30] # Different initial velocities (m/s) # Plot plt.figure(figsize=(8, 6)) for v0 in v0_values: R = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles_deg, R, label=f'v\u2080 = {v0} m/s') plt.title('Range vs. Angle of Projection') plt.xlabel('Angle \u03b8 (degrees)') plt.ylabel('Range R (m)') plt.grid(True) plt.legend() plt.show()","title":"Code 2: Range vs. Angle for Different Initial Velocities"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#code-3-range-vs-angle-for-different-gravitational-accelerations","text":"import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 20.0 # Initial velocity (m/s) angles_deg = np.linspace(0, 90, 91) # Angles from 0\u00b0 to 90\u00b0 angles_rad = np.radians(angles_deg) g_values = {'Earth': 9.81, 'Moon': 1.62, 'Mars': 3.72} # Gravity (m/s^2) # Plot plt.figure(figsize=(8, 6)) for planet, g in g_values.items(): R = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles_deg, R, label=f'{planet} (g = {g} m/s\u00b2)') plt.title('Range vs. Angle for Different Gravities') plt.xlabel('Angle \u03b8 (degrees)') plt.ylabel('Range R (m)') plt.grid(True) plt.legend() plt.show()","title":"Code 3: Range vs. Angle for Different Gravitational Accelerations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#code-4-trajectory-with-non-zero-initial-height","text":"import matplotlib.pyplot as plt import numpy as np # Constants g = 9.81 # gravity (m/s^2) v0 = 25 # initial speed (m/s) angle_deg = 45 # launch angle (degrees) angle_rad = np.radians(angle_deg) # Initial heights to test initial_heights = [0, 10, 20] # in meters labels = [f\"h0 = {h} m\" for h in initial_heights] # Time array t = np.linspace(0, 5, num=500) # simulate for 5 seconds # Plotting plt.figure(figsize=(10, 6)) for h0, label in zip(initial_heights, labels): # Equations of motion x = v0 * np.cos(angle_rad) * t y = h0 + v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 # Only keep points where y >= 0 (above ground) mask = y >= 0 plt.plot(x[mask], y[mask], label=label) plt.title(\"Projectile Motion for Different Initial Heights\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.legend() plt.grid(True) plt.show()","title":"Code 4: Trajectory with Non-Zero Initial Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#deliverables","text":"Equations : Derived \\(x(t)\\) , \\(y(t)\\) , and \\(R\\) . Graphs : Trajectory and \\(R\\) vs. \\(\\theta\\) plots. Limitations : Ideal model ignores drag; extend with numerical solvers.","title":"Deliverables"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"The range \\(R = \\frac{v_0^2 \\sin 2\\theta}{g}\\) peaks at 45\u00b0, scales with \\(v_0^2\\) , and adapts to real-world factors via modifications, demonstrated through simulations.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#colab","text":"Souce Code","title":"Colab"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation The forced damped pendulum is a nonlinear system governed by: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) $$ For small angles, \\(\\sin\\theta \\approx \\theta\\) , yielding a linear equation: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) $$ where \\(\\omega_0 = \\sqrt{g/L}\\) . Solutions include transient decay and a steady-state response: $$ \\theta_p(t) = D \\cos(\\omega t - \\phi), \\quad D = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (b \\omega)^2}} $$ Resonance occurs when \\(\\omega \\approx \\omega_0\\) , maximizing amplitude. 2. System Dynamics Damping \\((b)\\) : Higher \\(b\\) reduces oscillation amplitude and shifts resonance. Driving Amplitude \\((A)\\) : Larger \\(A\\) increases response, introducing nonlinear effects. Driving Frequency \\((\\omega)\\) : Controls synchronization and energy transfer. Chaos : Increasing \\(A\\) can induce period doubling and chaotic behavior. 3. Applications Energy Harvesting : Piezoelectric devices optimize energy capture by tuning \\(\\omega_0\\) . Bridges : Wind-induced oscillations (e.g., Tacoma Narrows) align with resonance behavior. Oscillating Circuits : Analogous to RLC circuits with \\(\\omega_0\\) and damping. 4. Implementation of the Forced Damped Pendulum Simulation This section demonstrates three different pendulum scenarios: 1. Pure pendulum (no damping, no external force) 2. Damped pendulum 3. Forced pendulum without damping 4.1 Pure Pendulum (No Damping, No External Force) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def pure_pendulum(state, t): theta, v = state dtheta_dt = v dv_dt = -np.sin(theta) # No damping (b=0) and no external force (A=0) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 50, 1000) # Time array initial_conditions = [0.1, 0] # [theta0, v0] # Solve sol = odeint(pure_pendulum, initial_conditions, t) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Pure Pendulum: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Pure Pendulum: Phase Space') ax2.grid(True) plt.tight_layout() plt.show() Output : Two plots showing the pure pendulum motion: 1. Left: Time series of angular displacement \u03b8(t) 2. Right: Phase space trajectory showing the conservation of energy (closed orbit) 4.2 Damped Pendulum import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def damped_pendulum(state, t, b): theta, v = state dtheta_dt = v dv_dt = -b * v - np.sin(theta) # With damping (b\u22600) but no external force (A=0) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 50, 1000) b = 0.5 # Damping coefficient initial_conditions = [0.1, 0] # Solve sol = odeint(damped_pendulum, initial_conditions, t, args=(b,)) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Damped Pendulum: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Damped Pendulum: Phase Space') ax2.grid(True) plt.tight_layout() plt.show() Output : Two plots showing the damped pendulum motion: 1. Left: Time series showing the decaying oscillations 2. Right: Phase space trajectory showing the energy dissipation (spiral trajectory) 4.3 Forced Pendulum without Damping import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def forced_pendulum(state, t, A, omega): theta, v = state dtheta_dt = v dv_dt = -np.sin(theta) + A * np.cos(omega * t) # No damping (b=0) but with external force (A\u22600) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 50, 1000) A = 0.5 # External force amplitude omega = 2/3 # Driving frequency initial_conditions = [0.1, 0] # Solve sol = odeint(forced_pendulum, initial_conditions, t, args=(A, omega)) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Forced Pendulum: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Forced Pendulum: Phase Space') ax2.grid(True) plt.tight_layout() plt.show() Output : Two plots showing the forced pendulum motion: 1. Left: Time series showing the driven oscillations 2. Right: Phase space trajectory showing the complex dynamics due to the external force 5. Colab Souce Code 6. Forced Damped Pendulum: Chaos & Resonance 6.1 Chaotic Motion in the Forced Damped Pendulum For certain values of the damping coefficient $ b $, driving amplitude $ A $, and driving frequency $ \\omega $, the forced damped pendulum exhibits chaotic behavior. A common set of parameters leading to chaos is: - $ b = 0.5 $ (moderate damping) - $ A = 1.2 $ (strong forcing) - $ \\omega = \\frac{2}{3} $ (driving frequency) Let's simulate the chaotic motion: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def chaotic_pendulum(state, t, b, A, omega): theta, v = state dtheta_dt = v dv_dt = -b * v - np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 100, 5000) # Extended time for chaotic behavior b = 0.5 A = 1.2 omega = 2/3 initial_conditions = [0.1, 0] # Solve sol = odeint(chaotic_pendulum, initial_conditions, t, args=(b, A, omega)) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Chaotic Pendulum: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Chaotic Pendulum: Phase Space') ax2.grid(True) plt.tight_layout() plt.show() Expected Output: Time Series Plot : Irregular oscillations with no periodic pattern. Phase Space Plot : A strange attractor instead of a closed orbit, characteristic of chaotic dynamics. 6.2 Resonance in the Forced Damped Pendulum Resonance occurs when the driving frequency $ \\omega $ is close to the system\u2019s natural frequency $ \\omega_0 = \\sqrt{g/L} $. This results in large oscillations. Let\u2019s simulate resonance by setting: - $ b = 0.1 $ (low damping) - $ A = 0.5 $ (moderate forcing) - $ \\omega = \\omega_0 \\approx 1 $ (resonance condition) # Define the system def resonance_pendulum(state, t, b, A, omega): theta, v = state dtheta_dt = v dv_dt = -b * v - np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 100, 5000) # Long simulation to see resonance effects b = 0.1 A = 0.5 omega = 1 # Resonance condition initial_conditions = [0.1, 0] # Solve sol = odeint(resonance_pendulum, initial_conditions, t, args=(b, A, omega)) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Resonance: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Resonance: Phase Space') ax2.grid(True) plt.tight_layout() plt.show() Expected Output: Time Series Plot : Oscillations with increasing amplitude over time. Phase Space Plot : Large periodic orbits, showing energy accumulation due to resonance.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"Investigating the Dynamics of a Forced Damped Pendulum","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The forced damped pendulum is a nonlinear system governed by: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) $$ For small angles, \\(\\sin\\theta \\approx \\theta\\) , yielding a linear equation: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) $$ where \\(\\omega_0 = \\sqrt{g/L}\\) . Solutions include transient decay and a steady-state response: $$ \\theta_p(t) = D \\cos(\\omega t - \\phi), \\quad D = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (b \\omega)^2}} $$ Resonance occurs when \\(\\omega \\approx \\omega_0\\) , maximizing amplitude.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-system-dynamics","text":"Damping \\((b)\\) : Higher \\(b\\) reduces oscillation amplitude and shifts resonance. Driving Amplitude \\((A)\\) : Larger \\(A\\) increases response, introducing nonlinear effects. Driving Frequency \\((\\omega)\\) : Controls synchronization and energy transfer. Chaos : Increasing \\(A\\) can induce period doubling and chaotic behavior.","title":"2. System Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-applications","text":"Energy Harvesting : Piezoelectric devices optimize energy capture by tuning \\(\\omega_0\\) . Bridges : Wind-induced oscillations (e.g., Tacoma Narrows) align with resonance behavior. Oscillating Circuits : Analogous to RLC circuits with \\(\\omega_0\\) and damping.","title":"3. Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-of-the-forced-damped-pendulum-simulation","text":"This section demonstrates three different pendulum scenarios: 1. Pure pendulum (no damping, no external force) 2. Damped pendulum 3. Forced pendulum without damping","title":"4. Implementation of the Forced Damped Pendulum Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#41-pure-pendulum-no-damping-no-external-force","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def pure_pendulum(state, t): theta, v = state dtheta_dt = v dv_dt = -np.sin(theta) # No damping (b=0) and no external force (A=0) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 50, 1000) # Time array initial_conditions = [0.1, 0] # [theta0, v0] # Solve sol = odeint(pure_pendulum, initial_conditions, t) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Pure Pendulum: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Pure Pendulum: Phase Space') ax2.grid(True) plt.tight_layout() plt.show() Output : Two plots showing the pure pendulum motion: 1. Left: Time series of angular displacement \u03b8(t) 2. Right: Phase space trajectory showing the conservation of energy (closed orbit)","title":"4.1 Pure Pendulum (No Damping, No External Force)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#42-damped-pendulum","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def damped_pendulum(state, t, b): theta, v = state dtheta_dt = v dv_dt = -b * v - np.sin(theta) # With damping (b\u22600) but no external force (A=0) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 50, 1000) b = 0.5 # Damping coefficient initial_conditions = [0.1, 0] # Solve sol = odeint(damped_pendulum, initial_conditions, t, args=(b,)) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Damped Pendulum: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Damped Pendulum: Phase Space') ax2.grid(True) plt.tight_layout() plt.show() Output : Two plots showing the damped pendulum motion: 1. Left: Time series showing the decaying oscillations 2. Right: Phase space trajectory showing the energy dissipation (spiral trajectory)","title":"4.2 Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#43-forced-pendulum-without-damping","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def forced_pendulum(state, t, A, omega): theta, v = state dtheta_dt = v dv_dt = -np.sin(theta) + A * np.cos(omega * t) # No damping (b=0) but with external force (A\u22600) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 50, 1000) A = 0.5 # External force amplitude omega = 2/3 # Driving frequency initial_conditions = [0.1, 0] # Solve sol = odeint(forced_pendulum, initial_conditions, t, args=(A, omega)) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Forced Pendulum: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Forced Pendulum: Phase Space') ax2.grid(True) plt.tight_layout() plt.show() Output : Two plots showing the forced pendulum motion: 1. Left: Time series showing the driven oscillations 2. Right: Phase space trajectory showing the complex dynamics due to the external force","title":"4.3 Forced Pendulum without Damping"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-colab","text":"Souce Code","title":"5. Colab"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-forced-damped-pendulum-chaos-resonance","text":"","title":"6. Forced Damped Pendulum: Chaos &amp; Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#61-chaotic-motion-in-the-forced-damped-pendulum","text":"For certain values of the damping coefficient $ b $, driving amplitude $ A $, and driving frequency $ \\omega $, the forced damped pendulum exhibits chaotic behavior. A common set of parameters leading to chaos is: - $ b = 0.5 $ (moderate damping) - $ A = 1.2 $ (strong forcing) - $ \\omega = \\frac{2}{3} $ (driving frequency) Let's simulate the chaotic motion: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def chaotic_pendulum(state, t, b, A, omega): theta, v = state dtheta_dt = v dv_dt = -b * v - np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 100, 5000) # Extended time for chaotic behavior b = 0.5 A = 1.2 omega = 2/3 initial_conditions = [0.1, 0] # Solve sol = odeint(chaotic_pendulum, initial_conditions, t, args=(b, A, omega)) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Chaotic Pendulum: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Chaotic Pendulum: Phase Space') ax2.grid(True) plt.tight_layout() plt.show()","title":"6.1 Chaotic Motion in the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#expected-output","text":"Time Series Plot : Irregular oscillations with no periodic pattern. Phase Space Plot : A strange attractor instead of a closed orbit, characteristic of chaotic dynamics.","title":"Expected Output:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#62-resonance-in-the-forced-damped-pendulum","text":"Resonance occurs when the driving frequency $ \\omega $ is close to the system\u2019s natural frequency $ \\omega_0 = \\sqrt{g/L} $. This results in large oscillations. Let\u2019s simulate resonance by setting: - $ b = 0.1 $ (low damping) - $ A = 0.5 $ (moderate forcing) - $ \\omega = \\omega_0 \\approx 1 $ (resonance condition) # Define the system def resonance_pendulum(state, t, b, A, omega): theta, v = state dtheta_dt = v dv_dt = -b * v - np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 100, 5000) # Long simulation to see resonance effects b = 0.1 A = 0.5 omega = 1 # Resonance condition initial_conditions = [0.1, 0] # Solve sol = odeint(resonance_pendulum, initial_conditions, t, args=(b, A, omega)) theta = sol[:, 0] v = sol[:, 1] # Create subplots fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5)) # Time series plot ax1.plot(t, theta, 'b-', label='\u03b8(t)') ax1.set_xlabel('Time (s)') ax1.set_ylabel('\u03b8 (rad)') ax1.set_title('Resonance: \u03b8 vs Time') ax1.grid(True) ax1.legend() # Phase space plot ax2.plot(theta, v, 'r-', lw=0.5) ax2.set_xlabel('\u03b8 (rad)') ax2.set_ylabel('\u03b8\u0307 (rad/s)') ax2.set_title('Resonance: Phase Space') ax2.grid(True) plt.tight_layout() plt.show()","title":"6.2 Resonance in the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#expected-output_1","text":"Time Series Plot : Oscillations with increasing amplitude over time. Phase Space Plot : Large periodic orbits, showing energy accumulation due to resonance.","title":"Expected Output:"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius 1. Theoretical Derivation of Kepler\u2019s Third Law 1.1 Newton's Law of Universal Gravitation The gravitational force between two masses is given by Newton\u2019s Law: \\[ F_g = G \\frac{Mm}{r^2} \\] Where: - \\(F_g\\) is the gravitational force, - \\(G\\) is the universal gravitational constant, - \\(M\\) is the mass of the central (larger) body (e.g., the Sun), - \\(m\\) is the mass of the orbiting body (e.g., a planet), - \\(r\\) is the orbital radius (distance between the centers of the two bodies). 1.2 Centripetal Force Requirement for Circular Motion For an object in circular motion, the centripetal force required to keep it in orbit is: \\[ F_c = \\frac{mv^2}{r} \\] Where: - \\(m\\) is the mass of the orbiting body, - \\(v\\) is its orbital speed, - \\(r\\) is the radius of the circular orbit. 1.3 Equating Gravitational and Centripetal Forces In a stable circular orbit, the gravitational force provides the necessary centripetal force: \\[ F_g = F_c \\] Thus: \\[ G \\frac{Mm}{r^2} = \\frac{mv^2}{r} \\] Cancel \\(m\\) from both sides: \\[ G \\frac{M}{r^2} = \\frac{v^2}{r} \\] Multiply both sides by \\(r\\) : \\[ G \\frac{M}{r} = v^2 \\] 1.4 Orbital Period and Velocity The orbital period \\(T\\) is the time taken to complete one full orbit. For a circular orbit of radius \\(r\\) , the orbital speed \\(v\\) is: \\[ v = \\frac{2\\pi r}{T} \\] Substitute this into the previous equation: \\[ G \\frac{M}{r} = \\left( \\frac{2\\pi r}{T} \\right)^2 \\] Simplify the right-hand side: \\[ G \\frac{M}{r} = \\frac{4\\pi^2 r^2}{T^2} \\] Multiply both sides by \\(T^2\\) : \\[ G M T^2 = 4\\pi^2 r^3 \\] Finally, solve for \\(T^2\\) : \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] 1.5 Result: Kepler\u2019s Third Law This shows the square of the orbital period is proportional to the cube of the orbital radius: \\[ T^2 \\propto r^3 \\] The constant of proportionality depends on the mass of the central object ( \\(M\\) ): \\[ T^2 = \\left( \\frac{4\\pi^2}{G M} \\right) r^3 \\] This is the mathematical expression of Kepler\u2019s Third Law for circular orbits, derived from Newtonian mechanics. 2. Conceptual Discussion: Significance of Kepler's Third Law 2.1 Importance in Astronomy Kepler\u2019s Third Law: \\[ T^2 \\propto r^3 \\] provides a foundational relationship between the orbital period ( \\(T\\) ) of a body and its average distance ( \\(r\\) ) from the object it orbits. When derived from Newtonian mechanics, this relationship becomes: \\[ T^2 = \\left( \\frac{4\\pi^2}{G M} \\right) r^3 \\] This is significant for several reasons: It connects orbital motion directly to the gravitational force and the mass of the central body . It allows astronomers to infer hidden properties of celestial systems using observable quantities like period and radius. It plays a key role in planetary science , stellar systems , exoplanet detection , and satellite engineering . 2.2 Determining Masses of Celestial Bodies Rearranging the Newtonian form of Kepler\u2019s Third Law: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] This equation enables us to calculate the mass ( \\(M\\) ) of the central object (e.g., Earth, the Sun, or a star), provided the orbital period ( \\(T\\) ) and orbital radius ( \\(r\\) ) of a satellite or planet are known. Example: Knowing the Moon\u2019s orbital radius and period allows us to compute Earth\u2019s mass. Observing the orbit of a moon around Jupiter allows astronomers to determine Jupiter\u2019s mass . 2.3 Measuring Distances Between Planets and Stars If the central mass \\(M\\) is already known (e.g., solar mass), then: \\[ r^3 = \\frac{G M T^2}{4\\pi^2} \\] This allows astronomers to compute orbital radii from observed periods. Applications: Calculating the average distances of planets from the Sun. Estimating the distances of exoplanets from their host stars (based on transit and radial velocity data). 2.4 Applications to Natural and Artificial Satellites Kepler's Third Law is universally valid for any object under gravitational orbit, whether natural or artificial. Natural Satellites: Describes the motion of moons around planets. Crucial for studying tidal locking , orbital resonances , and planetary system formation . Artificial Satellites: Essential for placing satellites in stable orbits around Earth (e.g., geostationary orbit ). Used to design communication satellites, GPS constellations, and space probes. For artificial satellites orbiting Earth: \\[ T^2 = \\left( \\frac{4\\pi^2}{G M_E} \\right) r^3 \\] where \\(M_E\\) is Earth's mass. Engineers use this to determine the required altitude ( \\(r\\) ) for a given orbital period ( \\(T\\) ). 2.5 Summary Kepler\u2019s Third Law is more than a mathematical curiosity\u2014it is a powerful tool for: Estimating masses and distances in the universe. Understanding both natural orbital mechanics and human-made satellite systems . Providing a bridge between observable orbital motion and invisible gravitational forces . 3. Real-World Applications of Kepler\u2019s Third Law Kepler\u2019s Third Law, in its Newtonian form: \\[ T^2 = \\left( \\frac{4\\pi^2}{G M} \\right) r^3 \\] can be tested and verified using real astronomical and artificial satellite data. The law enables calculations of orbital parameters across a wide range of systems\u2014from the Moon to distant planets, to GPS satellites. 3.1 The Moon Orbiting Earth Known values: - Orbital radius: \\(r \\approx 3.84 \\times 10^8 \\ \\text{m}\\) - Orbital period: \\(T \\approx 27.32 \\ \\text{days} \\approx 2.36 \\times 10^6 \\ \\text{s}\\) - Mass of Earth: \\(M_E \\approx 5.97 \\times 10^{24} \\ \\text{kg}\\) Prediction using Newtonian Kepler\u2019s Law: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M_E} \\] Plugging in values: \\[ T^2 \\approx \\frac{4\\pi^2 (3.84 \\times 10^8)^3}{6.674 \\times 10^{-11} \\cdot 5.97 \\times 10^{24}} \\approx 5.57 \\times 10^{12} \\ \\text{s}^2 \\] Taking square root: \\[ T \\approx \\sqrt{5.57 \\times 10^{12}} \\approx 2.36 \\times 10^6 \\ \\text{s} \\] \u2705 Match with observed period confirms validity. 3.2 Earth and Planets Orbiting the Sun Standard form using Astronomical Units (AU) and Earth years: If \\(T\\) is in Earth years and \\(r\\) in AU (Astronomical Units), then: \\[ T^2 = r^3 \\] Planet Orbital Radius \\(r\\) (AU) Period \\(T\\) (years) \\(T^2\\) \\(r^3\\) Earth 1.00 1.00 1.00 1.00 Mars 1.52 1.88 3.53 3.51 Jupiter 5.20 11.86 140.7 140.6 Saturn 9.58 29.46 867.9 880.3 \u2705 Close agreement of \\(T^2\\) and \\(r^3\\) supports Kepler's Law. 3.3 Artificial Satellites (e.g., GPS Satellites) GPS satellite parameters: - Orbital radius: \\(r \\approx 2.66 \\times 10^7 \\ \\text{m}\\) - Orbital period: \\(T \\approx 12 \\ \\text{hours} \\approx 4.32 \\times 10^4 \\ \\text{s}\\) - Mass of Earth: \\(M_E = 5.97 \\times 10^{24} \\ \\text{kg}\\) Use Kepler\u2019s Law: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M_E} \\] Calculate predicted \\(T\\) : \\[ T \\approx \\sqrt{ \\frac{4\\pi^2 (2.66 \\times 10^7)^3}{6.674 \\times 10^{-11} \\cdot 5.97 \\times 10^{24}} } \\approx 4.32 \\times 10^4 \\ \\text{s} \\] \u2705 Prediction matches design specification for GPS satellites. Comparison Summary Kepler\u2019s Third Law accurately predicts orbital behavior across: Natural satellites (e.g., Moon, planetary moons). Planetary orbits (in both AU and SI units). Artificial satellites (critical for telecommunications and navigation). This universality confirms the power and elegance of Kepler\u2019s Third Law when paired with Newton\u2019s laws of motion and gravitation. 4. Visualization and Verification 4.1 Real Data Plot: \\(T^2\\) vs \\(r^3\\) for Planets To test Kepler\u2019s Third Law using Solar System planets, we compute \\(T^2\\) and \\(r^3\\) using known orbital data: \\(r\\) : orbital radius in AU \\(T\\) : orbital period in Earth years We expect: \\[ T^2 = r^3 \\] import matplotlib.pyplot as plt import numpy as np # Planetary data planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'] r = np.array([0.39, 0.72, 1.00, 1.52, 5.20, 9.58]) # AU T = np.array([0.24, 0.62, 1.00, 1.88, 11.86, 29.46]) # years T_squared = T**2 r_cubed = r**3 plt.figure(figsize=(8, 5)) plt.scatter(r_cubed, T_squared, color='teal', s=70, edgecolor='black') for i, planet in enumerate(planets): plt.annotate(planet, (r_cubed[i], T_squared[i]), textcoords=\"offset points\", xytext=(5,5)) plt.title(\"$T^2$ vs $r^3$ for Planets in the Solar System\", fontsize=14) plt.xlabel(\"$r^3$ (AU\u00b3)\") plt.ylabel(\"$T^2$ (years\u00b2)\") plt.grid(True, linestyle='--', alpha=0.6) plt.tight_layout() plt.show() import matplotlib.pyplot as plt import numpy as np # Planetary data planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'] r = np.array([0.39, 0.72, 1.00, 1.52, 5.20, 9.58]) # AU T = np.array([0.24, 0.62, 1.00, 1.88, 11.86, 29.46]) # years # Compute T^2 and r^3 T_squared = T**2 r_cubed = r**3 # Plot in log-log scale plt.figure(figsize=(8, 5)) plt.loglog(r_cubed, T_squared, 'o', color='teal', markersize=8, markeredgecolor='black') # Annotations for i, planet in enumerate(planets): plt.annotate(planet, (r_cubed[i], T_squared[i]), textcoords=\"offset points\", xytext=(6,4)) plt.title(\"Log-Log Plot: $T^2$ vs $r^3$ for Planets\", fontsize=14) plt.xlabel(\"$r^3$ (AU\u00b3)\", fontsize=12) plt.ylabel(\"$T^2$ (years\u00b2)\", fontsize=12) plt.grid(True, which='both', linestyle='--', alpha=0.6) plt.tight_layout() plt.show() 4.2 Real Data: Log-Log Plot and Slope Verification To avoid compression near the origin and test proportionality: Transform both sides to logarithmic scale. Fit a line to the log-log data. Slope \\(\\approx 1\\) confirms \\(T^2 \\propto r^3\\) . from scipy.stats import linregress log_r3 = np.log10(r_cubed) log_T2 = np.log10(T_squared) slope, intercept, r_value, _, _ = linregress(log_r3, log_T2) plt.figure(figsize=(8, 5)) plt.plot(log_r3, log_T2, 'o-', color='darkgreen') plt.title(\"Log-Log Plot: $\\\\log(T^2)$ vs $\\\\log(r^3)$\", fontsize=14) plt.xlabel(\"$\\\\log(r^3)$\") plt.ylabel(\"$\\\\log(T^2)$\") plt.grid(True, which='both', linestyle='--', alpha=0.6) plt.text(min(log_r3), max(log_T2)-0.2, f\"Slope \u2248 {slope:.3f}\", color='red', fontsize=12) plt.tight_layout() plt.show() 4.3 Simulated Data: Verifying \\(T^2 \\propto r^3\\) Using Newton\u2019s formulation: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Simulate orbits for different radii and verify \\(T^2\\) vs \\(r^3\\) . # Simulate a system with Sun-like central mass G = 6.674e-11 # m^3 kg^-1 s^-2 M = 1.989e30 # kg (Sun's mass) r_vals = np.linspace(0.5e11, 2.5e11, 6) # meters T_vals = 2 * np.pi * np.sqrt(r_vals**3 / (G * M)) # seconds # Convert to AU and years AU = 1.496e11 year = 3.154e7 r_AU = r_vals / AU T_years = T_vals / year plt.figure(figsize=(8, 5)) plt.plot(r_AU**3, T_years**2, 'o-', color='darkorange') plt.title(\"Simulated: $T^2$ vs $r^3$\", fontsize=14) plt.xlabel(\"$r^3$ (AU\u00b3)\") plt.ylabel(\"$T^2$ (years\u00b2)\") plt.grid(True, linestyle='--', alpha=0.6) plt.tight_layout() plt.show() 4.4 Simulated Log-Log Plot and Slope Check log_r_sim = np.log10(r_AU**3) log_T_sim = np.log10(T_years**2) slope_sim, _, _, _, _ = linregress(log_r_sim, log_T_sim) plt.figure(figsize=(8, 5)) plt.plot(log_r_sim, log_T_sim, 'o-', color='purple') plt.title(\"Simulated: Log-Log Plot\", fontsize=14) plt.xlabel(\"$\\\\log(r^3)$\") plt.ylabel(\"$\\\\log(T^2)$\") plt.grid(True, which='both', linestyle='--', alpha=0.6) plt.text(min(log_r_sim), max(log_T_sim)-0.2, f\"Slope \u2248 {slope_sim:.3f}\", color='red', fontsize=12) plt.tight_layout() plt.show() 4.5 Simulated Orbit Animation: Earth Orbiting the Sun To enhance visual understanding, we simulate the circular orbit of Earth around the Sun using matplotlib.animation . This helps demonstrate: Constant radius motion in a circular orbit Uniform angular speed Central gravitational attraction (Sun remains at the focus) import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation from IPython.display import HTML # Constants G = 6.674e-11 # Gravitational constant (m^3/kg/s^2) M = 1.989e30 # Mass of the Sun (kg) r = 1.5e11 # Orbital radius (1 AU in meters) # Generate orbital positions theta = np.linspace(0, 2 * np.pi, 360) x = r * np.cos(theta) y = r * np.sin(theta) # Set up the figure fig, ax = plt.subplots(figsize=(6,6)) planet, = ax.plot([], [], 'bo', markersize=8) # Earth sun, = ax.plot(0, 0, 'yo', markersize=12) # Sun orbit, = ax.plot(x, y, 'k--', linewidth=0.5) # Orbit path ax.set_xlim(-r * 1.2, r * 1.2) ax.set_ylim(-r * 1.2, r * 1.2) ax.set_aspect('equal') ax.set_title('Earth Orbiting the Sun') # Animation update function def update(frame): planet.set_data([x[frame]], [y[frame]]) return planet, # Create animation ani = animation.FuncAnimation(fig, update, frames=len(theta), interval=20) # Display animation (for Jupyter/Colab) HTML(ani.to_jshtml()) 5. Conclusion Kepler\u2019s Third Law, which relates the square of the orbital period to the cube of the orbital radius ( \\(T^2 \\propto r^3\\) ), stands as a cornerstone of classical and celestial mechanics. Through theoretical derivation from Newton\u2019s laws, conceptual interpretation, real-world validation, and computational modeling, we have demonstrated its universality and predictive power. Theoretically , we derived the law from Newton's law of gravitation and circular motion, showing how gravitational interactions dictate orbital dynamics. Conceptually , we discussed its significance in astronomy, especially in calculating the masses of celestial bodies and determining distances in planetary systems. Empirically , we validated the law using real astronomical data from the Solar System and artificial satellites, all of which confirm the \\(T^2 \\propto r^3\\) relationship with high precision. Computationally , we simulated orbits using Newtonian mechanics and verified the proportionality through numerical data and log-log analysis. This multifaceted approach not only reinforces the law\u2019s correctness but also showcases its essential role in both scientific understanding and modern technological applications. Kepler\u2019s Third Law exemplifies the profound connection between simple mathematical relationships and the grand structure of the cosmos. 6. Colab Souce Code","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"Orbital Period and Orbital Radius","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-derivation-of-keplers-third-law","text":"","title":"1. Theoretical Derivation of Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#11-newtons-law-of-universal-gravitation","text":"The gravitational force between two masses is given by Newton\u2019s Law: \\[ F_g = G \\frac{Mm}{r^2} \\] Where: - \\(F_g\\) is the gravitational force, - \\(G\\) is the universal gravitational constant, - \\(M\\) is the mass of the central (larger) body (e.g., the Sun), - \\(m\\) is the mass of the orbiting body (e.g., a planet), - \\(r\\) is the orbital radius (distance between the centers of the two bodies).","title":"1.1 Newton's Law of Universal Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#12-centripetal-force-requirement-for-circular-motion","text":"For an object in circular motion, the centripetal force required to keep it in orbit is: \\[ F_c = \\frac{mv^2}{r} \\] Where: - \\(m\\) is the mass of the orbiting body, - \\(v\\) is its orbital speed, - \\(r\\) is the radius of the circular orbit.","title":"1.2 Centripetal Force Requirement for Circular Motion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#13-equating-gravitational-and-centripetal-forces","text":"In a stable circular orbit, the gravitational force provides the necessary centripetal force: \\[ F_g = F_c \\] Thus: \\[ G \\frac{Mm}{r^2} = \\frac{mv^2}{r} \\] Cancel \\(m\\) from both sides: \\[ G \\frac{M}{r^2} = \\frac{v^2}{r} \\] Multiply both sides by \\(r\\) : \\[ G \\frac{M}{r} = v^2 \\]","title":"1.3 Equating Gravitational and Centripetal Forces"},{"location":"1%20Physics/2%20Gravity/Problem_1/#14-orbital-period-and-velocity","text":"The orbital period \\(T\\) is the time taken to complete one full orbit. For a circular orbit of radius \\(r\\) , the orbital speed \\(v\\) is: \\[ v = \\frac{2\\pi r}{T} \\] Substitute this into the previous equation: \\[ G \\frac{M}{r} = \\left( \\frac{2\\pi r}{T} \\right)^2 \\] Simplify the right-hand side: \\[ G \\frac{M}{r} = \\frac{4\\pi^2 r^2}{T^2} \\] Multiply both sides by \\(T^2\\) : \\[ G M T^2 = 4\\pi^2 r^3 \\] Finally, solve for \\(T^2\\) : \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\]","title":"1.4 Orbital Period and Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_1/#15-result-keplers-third-law","text":"This shows the square of the orbital period is proportional to the cube of the orbital radius: \\[ T^2 \\propto r^3 \\] The constant of proportionality depends on the mass of the central object ( \\(M\\) ): \\[ T^2 = \\left( \\frac{4\\pi^2}{G M} \\right) r^3 \\] This is the mathematical expression of Kepler\u2019s Third Law for circular orbits, derived from Newtonian mechanics.","title":"1.5 Result: Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-conceptual-discussion-significance-of-keplers-third-law","text":"","title":"2. Conceptual Discussion: Significance of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#21-importance-in-astronomy","text":"Kepler\u2019s Third Law: \\[ T^2 \\propto r^3 \\] provides a foundational relationship between the orbital period ( \\(T\\) ) of a body and its average distance ( \\(r\\) ) from the object it orbits. When derived from Newtonian mechanics, this relationship becomes: \\[ T^2 = \\left( \\frac{4\\pi^2}{G M} \\right) r^3 \\] This is significant for several reasons: It connects orbital motion directly to the gravitational force and the mass of the central body . It allows astronomers to infer hidden properties of celestial systems using observable quantities like period and radius. It plays a key role in planetary science , stellar systems , exoplanet detection , and satellite engineering .","title":"2.1 Importance in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#22-determining-masses-of-celestial-bodies","text":"Rearranging the Newtonian form of Kepler\u2019s Third Law: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] This equation enables us to calculate the mass ( \\(M\\) ) of the central object (e.g., Earth, the Sun, or a star), provided the orbital period ( \\(T\\) ) and orbital radius ( \\(r\\) ) of a satellite or planet are known.","title":"2.2 Determining Masses of Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example","text":"Knowing the Moon\u2019s orbital radius and period allows us to compute Earth\u2019s mass. Observing the orbit of a moon around Jupiter allows astronomers to determine Jupiter\u2019s mass .","title":"Example:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#23-measuring-distances-between-planets-and-stars","text":"If the central mass \\(M\\) is already known (e.g., solar mass), then: \\[ r^3 = \\frac{G M T^2}{4\\pi^2} \\] This allows astronomers to compute orbital radii from observed periods.","title":"2.3 Measuring Distances Between Planets and Stars"},{"location":"1%20Physics/2%20Gravity/Problem_1/#applications","text":"Calculating the average distances of planets from the Sun. Estimating the distances of exoplanets from their host stars (based on transit and radial velocity data).","title":"Applications:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#24-applications-to-natural-and-artificial-satellites","text":"Kepler's Third Law is universally valid for any object under gravitational orbit, whether natural or artificial.","title":"2.4 Applications to Natural and Artificial Satellites"},{"location":"1%20Physics/2%20Gravity/Problem_1/#natural-satellites","text":"Describes the motion of moons around planets. Crucial for studying tidal locking , orbital resonances , and planetary system formation .","title":"Natural Satellites:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#artificial-satellites","text":"Essential for placing satellites in stable orbits around Earth (e.g., geostationary orbit ). Used to design communication satellites, GPS constellations, and space probes. For artificial satellites orbiting Earth: \\[ T^2 = \\left( \\frac{4\\pi^2}{G M_E} \\right) r^3 \\] where \\(M_E\\) is Earth's mass. Engineers use this to determine the required altitude ( \\(r\\) ) for a given orbital period ( \\(T\\) ).","title":"Artificial Satellites:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#25-summary","text":"Kepler\u2019s Third Law is more than a mathematical curiosity\u2014it is a powerful tool for: Estimating masses and distances in the universe. Understanding both natural orbital mechanics and human-made satellite systems . Providing a bridge between observable orbital motion and invisible gravitational forces .","title":"2.5 Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-applications-of-keplers-third-law","text":"Kepler\u2019s Third Law, in its Newtonian form: \\[ T^2 = \\left( \\frac{4\\pi^2}{G M} \\right) r^3 \\] can be tested and verified using real astronomical and artificial satellite data. The law enables calculations of orbital parameters across a wide range of systems\u2014from the Moon to distant planets, to GPS satellites.","title":"3. Real-World Applications of Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#31-the-moon-orbiting-earth","text":"Known values: - Orbital radius: \\(r \\approx 3.84 \\times 10^8 \\ \\text{m}\\) - Orbital period: \\(T \\approx 27.32 \\ \\text{days} \\approx 2.36 \\times 10^6 \\ \\text{s}\\) - Mass of Earth: \\(M_E \\approx 5.97 \\times 10^{24} \\ \\text{kg}\\) Prediction using Newtonian Kepler\u2019s Law: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M_E} \\] Plugging in values: \\[ T^2 \\approx \\frac{4\\pi^2 (3.84 \\times 10^8)^3}{6.674 \\times 10^{-11} \\cdot 5.97 \\times 10^{24}} \\approx 5.57 \\times 10^{12} \\ \\text{s}^2 \\] Taking square root: \\[ T \\approx \\sqrt{5.57 \\times 10^{12}} \\approx 2.36 \\times 10^6 \\ \\text{s} \\] \u2705 Match with observed period confirms validity.","title":"3.1 The Moon Orbiting Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#32-earth-and-planets-orbiting-the-sun","text":"Standard form using Astronomical Units (AU) and Earth years: If \\(T\\) is in Earth years and \\(r\\) in AU (Astronomical Units), then: \\[ T^2 = r^3 \\] Planet Orbital Radius \\(r\\) (AU) Period \\(T\\) (years) \\(T^2\\) \\(r^3\\) Earth 1.00 1.00 1.00 1.00 Mars 1.52 1.88 3.53 3.51 Jupiter 5.20 11.86 140.7 140.6 Saturn 9.58 29.46 867.9 880.3 \u2705 Close agreement of \\(T^2\\) and \\(r^3\\) supports Kepler's Law.","title":"3.2 Earth and Planets Orbiting the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#33-artificial-satellites-eg-gps-satellites","text":"GPS satellite parameters: - Orbital radius: \\(r \\approx 2.66 \\times 10^7 \\ \\text{m}\\) - Orbital period: \\(T \\approx 12 \\ \\text{hours} \\approx 4.32 \\times 10^4 \\ \\text{s}\\) - Mass of Earth: \\(M_E = 5.97 \\times 10^{24} \\ \\text{kg}\\) Use Kepler\u2019s Law: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M_E} \\] Calculate predicted \\(T\\) : \\[ T \\approx \\sqrt{ \\frac{4\\pi^2 (2.66 \\times 10^7)^3}{6.674 \\times 10^{-11} \\cdot 5.97 \\times 10^{24}} } \\approx 4.32 \\times 10^4 \\ \\text{s} \\] \u2705 Prediction matches design specification for GPS satellites.","title":"3.3 Artificial Satellites (e.g., GPS Satellites)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#comparison-summary","text":"Kepler\u2019s Third Law accurately predicts orbital behavior across: Natural satellites (e.g., Moon, planetary moons). Planetary orbits (in both AU and SI units). Artificial satellites (critical for telecommunications and navigation). This universality confirms the power and elegance of Kepler\u2019s Third Law when paired with Newton\u2019s laws of motion and gravitation.","title":"Comparison Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-visualization-and-verification","text":"","title":"4. Visualization and Verification"},{"location":"1%20Physics/2%20Gravity/Problem_1/#41-real-data-plot-t2-vs-r3-for-planets","text":"To test Kepler\u2019s Third Law using Solar System planets, we compute \\(T^2\\) and \\(r^3\\) using known orbital data: \\(r\\) : orbital radius in AU \\(T\\) : orbital period in Earth years We expect: \\[ T^2 = r^3 \\] import matplotlib.pyplot as plt import numpy as np # Planetary data planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'] r = np.array([0.39, 0.72, 1.00, 1.52, 5.20, 9.58]) # AU T = np.array([0.24, 0.62, 1.00, 1.88, 11.86, 29.46]) # years T_squared = T**2 r_cubed = r**3 plt.figure(figsize=(8, 5)) plt.scatter(r_cubed, T_squared, color='teal', s=70, edgecolor='black') for i, planet in enumerate(planets): plt.annotate(planet, (r_cubed[i], T_squared[i]), textcoords=\"offset points\", xytext=(5,5)) plt.title(\"$T^2$ vs $r^3$ for Planets in the Solar System\", fontsize=14) plt.xlabel(\"$r^3$ (AU\u00b3)\") plt.ylabel(\"$T^2$ (years\u00b2)\") plt.grid(True, linestyle='--', alpha=0.6) plt.tight_layout() plt.show() import matplotlib.pyplot as plt import numpy as np # Planetary data planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'] r = np.array([0.39, 0.72, 1.00, 1.52, 5.20, 9.58]) # AU T = np.array([0.24, 0.62, 1.00, 1.88, 11.86, 29.46]) # years # Compute T^2 and r^3 T_squared = T**2 r_cubed = r**3 # Plot in log-log scale plt.figure(figsize=(8, 5)) plt.loglog(r_cubed, T_squared, 'o', color='teal', markersize=8, markeredgecolor='black') # Annotations for i, planet in enumerate(planets): plt.annotate(planet, (r_cubed[i], T_squared[i]), textcoords=\"offset points\", xytext=(6,4)) plt.title(\"Log-Log Plot: $T^2$ vs $r^3$ for Planets\", fontsize=14) plt.xlabel(\"$r^3$ (AU\u00b3)\", fontsize=12) plt.ylabel(\"$T^2$ (years\u00b2)\", fontsize=12) plt.grid(True, which='both', linestyle='--', alpha=0.6) plt.tight_layout() plt.show()","title":"4.1 Real Data Plot: \\(T^2\\) vs \\(r^3\\) for Planets"},{"location":"1%20Physics/2%20Gravity/Problem_1/#42-real-data-log-log-plot-and-slope-verification","text":"To avoid compression near the origin and test proportionality: Transform both sides to logarithmic scale. Fit a line to the log-log data. Slope \\(\\approx 1\\) confirms \\(T^2 \\propto r^3\\) . from scipy.stats import linregress log_r3 = np.log10(r_cubed) log_T2 = np.log10(T_squared) slope, intercept, r_value, _, _ = linregress(log_r3, log_T2) plt.figure(figsize=(8, 5)) plt.plot(log_r3, log_T2, 'o-', color='darkgreen') plt.title(\"Log-Log Plot: $\\\\log(T^2)$ vs $\\\\log(r^3)$\", fontsize=14) plt.xlabel(\"$\\\\log(r^3)$\") plt.ylabel(\"$\\\\log(T^2)$\") plt.grid(True, which='both', linestyle='--', alpha=0.6) plt.text(min(log_r3), max(log_T2)-0.2, f\"Slope \u2248 {slope:.3f}\", color='red', fontsize=12) plt.tight_layout() plt.show()","title":"4.2 Real Data: Log-Log Plot and Slope Verification"},{"location":"1%20Physics/2%20Gravity/Problem_1/#43-simulated-data-verifying-t2-propto-r3","text":"Using Newton\u2019s formulation: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Simulate orbits for different radii and verify \\(T^2\\) vs \\(r^3\\) . # Simulate a system with Sun-like central mass G = 6.674e-11 # m^3 kg^-1 s^-2 M = 1.989e30 # kg (Sun's mass) r_vals = np.linspace(0.5e11, 2.5e11, 6) # meters T_vals = 2 * np.pi * np.sqrt(r_vals**3 / (G * M)) # seconds # Convert to AU and years AU = 1.496e11 year = 3.154e7 r_AU = r_vals / AU T_years = T_vals / year plt.figure(figsize=(8, 5)) plt.plot(r_AU**3, T_years**2, 'o-', color='darkorange') plt.title(\"Simulated: $T^2$ vs $r^3$\", fontsize=14) plt.xlabel(\"$r^3$ (AU\u00b3)\") plt.ylabel(\"$T^2$ (years\u00b2)\") plt.grid(True, linestyle='--', alpha=0.6) plt.tight_layout() plt.show()","title":"4.3 Simulated Data: Verifying \\(T^2 \\propto r^3\\)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#44-simulated-log-log-plot-and-slope-check","text":"log_r_sim = np.log10(r_AU**3) log_T_sim = np.log10(T_years**2) slope_sim, _, _, _, _ = linregress(log_r_sim, log_T_sim) plt.figure(figsize=(8, 5)) plt.plot(log_r_sim, log_T_sim, 'o-', color='purple') plt.title(\"Simulated: Log-Log Plot\", fontsize=14) plt.xlabel(\"$\\\\log(r^3)$\") plt.ylabel(\"$\\\\log(T^2)$\") plt.grid(True, which='both', linestyle='--', alpha=0.6) plt.text(min(log_r_sim), max(log_T_sim)-0.2, f\"Slope \u2248 {slope_sim:.3f}\", color='red', fontsize=12) plt.tight_layout() plt.show()","title":"4.4 Simulated Log-Log Plot and Slope Check"},{"location":"1%20Physics/2%20Gravity/Problem_1/#45-simulated-orbit-animation-earth-orbiting-the-sun","text":"To enhance visual understanding, we simulate the circular orbit of Earth around the Sun using matplotlib.animation . This helps demonstrate: Constant radius motion in a circular orbit Uniform angular speed Central gravitational attraction (Sun remains at the focus) import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation from IPython.display import HTML # Constants G = 6.674e-11 # Gravitational constant (m^3/kg/s^2) M = 1.989e30 # Mass of the Sun (kg) r = 1.5e11 # Orbital radius (1 AU in meters) # Generate orbital positions theta = np.linspace(0, 2 * np.pi, 360) x = r * np.cos(theta) y = r * np.sin(theta) # Set up the figure fig, ax = plt.subplots(figsize=(6,6)) planet, = ax.plot([], [], 'bo', markersize=8) # Earth sun, = ax.plot(0, 0, 'yo', markersize=12) # Sun orbit, = ax.plot(x, y, 'k--', linewidth=0.5) # Orbit path ax.set_xlim(-r * 1.2, r * 1.2) ax.set_ylim(-r * 1.2, r * 1.2) ax.set_aspect('equal') ax.set_title('Earth Orbiting the Sun') # Animation update function def update(frame): planet.set_data([x[frame]], [y[frame]]) return planet, # Create animation ani = animation.FuncAnimation(fig, update, frames=len(theta), interval=20) # Display animation (for Jupyter/Colab) HTML(ani.to_jshtml())","title":"4.5 Simulated Orbit Animation: Earth Orbiting the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-conclusion","text":"Kepler\u2019s Third Law, which relates the square of the orbital period to the cube of the orbital radius ( \\(T^2 \\propto r^3\\) ), stands as a cornerstone of classical and celestial mechanics. Through theoretical derivation from Newton\u2019s laws, conceptual interpretation, real-world validation, and computational modeling, we have demonstrated its universality and predictive power. Theoretically , we derived the law from Newton's law of gravitation and circular motion, showing how gravitational interactions dictate orbital dynamics. Conceptually , we discussed its significance in astronomy, especially in calculating the masses of celestial bodies and determining distances in planetary systems. Empirically , we validated the law using real astronomical data from the Solar System and artificial satellites, all of which confirm the \\(T^2 \\propto r^3\\) relationship with high precision. Computationally , we simulated orbits using Newtonian mechanics and verified the proportionality through numerical data and log-log analysis. This multifaceted approach not only reinforces the law\u2019s correctness but also showcases its essential role in both scientific understanding and modern technological applications. Kepler\u2019s Third Law exemplifies the profound connection between simple mathematical relationships and the grand structure of the cosmos.","title":"5. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#6-colab","text":"Souce Code","title":"6. Colab"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities 1. Definitions & Concepts 1.1 Escape Velocity Escape velocity is the minimum speed an object must reach to break free from the gravitational pull of a celestial body, without any further propulsion. The general formula for escape velocity is derived from the conservation of energy: \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{r} \\] Solving for velocity: \\[ v_{esc} = \\sqrt{\\frac{2GM}{r}} \\] Where: - \\(v_{esc}\\) is the escape velocity, - \\(G\\) is the gravitational constant \\((6.674 \\times 10^{-11}\\,\\text{m}^3\\,\\text{kg}^{-1}\\,\\text{s}^{-2})\\) , - \\(M\\) is the mass of the celestial body, - \\(r\\) is the distance from the center of the body to the point of escape (typically the planet\u2019s radius). 1.2 First Cosmic Velocity (Orbital Velocity) The first cosmic velocity refers to the minimum horizontal speed an object must have to remain in a stable, circular orbit just above the surface of a celestial body, without falling back to the surface. It is derived by equating gravitational force to centripetal force: \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Solving for \\(v\\) : \\[ v_{orb} = \\sqrt{\\frac{GM}{r}} \\] This is also called the orbital velocity , and it is lower than escape velocity: \\[ v_{orb} = \\frac{v_{esc}}{\\sqrt{2}} \\] 1.3 Second Cosmic Velocity The second cosmic velocity is simply another term for escape velocity from a planetary body. It is the minimum speed required to completely escape the gravitational influence of the planet and enter into space, assuming no further propulsion. Thus: \\[ v_{2nd} = v_{esc} = \\sqrt{\\frac{2GM}{r}} \\] 1.4 Third Cosmic Velocity The third cosmic velocity is the speed required for a spacecraft to escape not only Earth\u2019s gravity, but also the Sun\u2019s gravity, starting from Earth\u2019s orbit. This is relevant for interstellar missions. This involves both Earth\u2019s orbital velocity around the Sun and the Sun\u2019s gravitational influence. It can be approximated by: \\[ v_{3rd} = \\sqrt{v_{esc,\\odot}^2 + v_{orb,\\oplus}^2} \\] Where: - \\(v_{esc,\\odot}\\) is the escape velocity from the Sun at Earth\u2019s distance, - \\(v_{orb,\\oplus}\\) is Earth\u2019s orbital speed around the Sun ( \\(\\approx 29.78\\,\\text{km/s}\\) ). A simplified expression (ignoring Earth's gravity) for escaping the Solar System from Earth\u2019s orbit: \\[ v_{3rd} \\approx \\sqrt{\\frac{2GM_{\\odot}}{r_{\\oplus}}} \\] Where: - \\(M_{\\odot}\\) is the mass of the Sun, - \\(r_{\\oplus}\\) is the average distance from Earth to the Sun ( \\(\\approx 1.496 \\times 10^{11}\\,\\text{m}\\) ). 1.5 Physical Meaning in Space Exploration First Cosmic Velocity is the target speed for launching satellites into low Earth orbit. It represents the threshold for achieving continuous free-fall around Earth. Second Cosmic Velocity is critical for missions intending to leave Earth's orbit \u2014 such as lunar missions or probes bound for other planets. Third Cosmic Velocity pertains to missions aiming to exit the Solar System, such as the Voyager and Pioneer spacecraft. Achieving this velocity allows an object to overcome the Sun\u2019s gravitational hold. Understanding these velocities is fundamental for determining fuel requirements, launch windows, and mission design in astrodynamics and interplanetary navigation . 2. Mathematical Derivations 2.1 Escape Velocity To derive the escape velocity, we equate the kinetic energy of an object to the gravitational potential energy required to escape the gravitational field of a body. Kinetic energy of the object: $$ KE = \\frac{1}{2}mv^2 $$ Gravitational potential energy of the object (at distance \\(r\\) from the center of mass \\(M\\) ): $$ U = -\\frac{GMm}{r} $$ For escape, the total mechanical energy must be zero: \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{r} = 0 \\] Solving for \\(v\\) : \\[ v_{esc} = \\sqrt{\\frac{2GM}{r}} \\] This velocity is independent of the mass of the escaping object and depends only on the mass and radius of the celestial body. 2.2 First Cosmic Velocity (Orbital Velocity) This is the velocity required to keep an object in circular orbit just above the surface of a planet. It is derived by balancing the gravitational force and the required centripetal force: Gravitational force: $$ F_g = \\frac{GMm}{r^2} $$ Centripetal force: $$ F_c = \\frac{mv^2}{r} $$ Setting \\(F_g = F_c\\) : \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Cancelling \\(m\\) and solving for \\(v\\) : \\[ v_{orb} = \\sqrt{\\frac{GM}{r}} \\] This is the first cosmic velocity and is precisely the speed needed for stable circular orbit at altitude zero (neglecting atmosphere). 2.3 Third Cosmic Velocity The third cosmic velocity is the speed required to escape the Sun\u2019s gravitational field from Earth\u2019s orbit. The Sun\u2019s gravitational potential energy at Earth\u2019s orbital distance: \\[ U = -\\frac{GM_{\\odot}m}{r_{\\oplus}} \\] Kinetic energy needed to escape from the Sun\u2019s gravity: \\[ \\frac{1}{2}mv^2 = \\frac{GM_{\\odot}m}{r_{\\oplus}} \\] Solving for \\(v\\) : \\[ v_{3rd} = \\sqrt{\\frac{2GM_{\\odot}}{r_{\\oplus}}} \\] However, since Earth is already moving at orbital velocity \\(v_{\\oplus} \\approx 29.78\\) km/s, the spacecraft only needs additional velocity beyond this: \\[ v_{3rd,\\,launch} = \\sqrt{v_{esc,\\odot}^2 + v_{\\oplus}^2} \\] In practice, this value is adjusted depending on the spacecraft's launch trajectory and timing (e.g., gravity assists). 2.4 Influence of Mass and Radius From the escape velocity formula: \\[ v_{esc} = \\sqrt{\\frac{2GM}{r}}, \\quad v_{orb} = \\sqrt{\\frac{GM}{r}} \\] We can draw the following conclusions: Mass ( \\(M\\) ) : As the mass of the celestial body increases, both escape and orbital velocities increase. Radius ( \\(r\\) ) : As the radius increases, the velocities decrease. This is because the gravitational potential becomes weaker farther from the center of mass. Thus, denser and more massive planets like Jupiter have significantly higher escape velocities than Mars . 2.5 Assumptions in Derivations These derivations rely on several simplifying assumptions: The celestial body is a perfect sphere with mass concentrated at the center (i.e., it behaves as a point mass). No atmospheric drag or air resistance is considered (ideal vacuum conditions). No rotational effects (e.g., Coriolis force or frame-dragging from planet spin). The motion is assumed to be purely radial (for escape) or circular (for orbit). The object has no propulsion after initial velocity is imparted (i.e., ballistic motion). These assumptions allow for clean analytical expressions but differ from real-world engineering, where rocket burns, drag, and non-uniform mass distributions are considered. 3. Calculations 3.1 Constants and Celestial Parameters We begin by defining the necessary physical constants and planetary data: Universal Constants Gravitational constant: $$ G = 6.674 \\times 10^{-11}\\,\\text{m}^3\\,\\text{kg}^{-1}\\,\\text{s}^{-2} $$ Planetary Data Planet Mass \\((M)\\) [kg] Radius \\((r)\\) [m] Distance from Sun \\((r_{\\odot})\\) [m] Earth \\(5.972 \\times 10^{24}\\) \\(6.371 \\times 10^6\\) \\(1.496 \\times 10^{11}\\) Mars \\(6.417 \\times 10^{23}\\) \\(3.390 \\times 10^6\\) \\(2.279 \\times 10^{11}\\) Jupiter \\(1.898 \\times 10^{27}\\) \\(6.9911 \\times 10^7\\) \\(7.785 \\times 10^{11}\\) Solar Mass Mass of the Sun: $$ M_{\\odot} = 1.989 \\times 10^{30}\\,\\text{kg} $$ 3.2 Formulas First Cosmic Velocity (Orbital): $$ v_{orb} = \\sqrt{\\frac{GM}{r}} $$ Second Cosmic Velocity (Escape): $$ v_{esc} = \\sqrt{\\frac{2GM}{r}} $$ Third Cosmic Velocity (Escape from the Sun at planetary orbit): $$ v_{3rd} = \\sqrt{\\frac{2GM_{\\odot}}{r_{\\odot}}} $$ Note: We assume these are launched directly from the surface or orbital path with negligible atmospheric drag and no propulsion. 3.3 Numerical Calculations Earth \\(v_{orb,\\oplus} = \\sqrt{\\frac{6.674 \\times 10^{-11} \\cdot 5.972 \\times 10^{24}}{6.371 \\times 10^6}} \\approx 7.91\\,\\text{km/s}\\) \\(v_{esc,\\oplus} = \\sqrt{2} \\cdot v_{orb,\\oplus} \\approx 11.19\\,\\text{km/s}\\) \\(v_{3rd,\\oplus} = \\sqrt{\\frac{2 \\cdot 6.674 \\times 10^{-11} \\cdot 1.989 \\times 10^{30}}{1.496 \\times 10^{11}}} \\approx 42.1\\,\\text{km/s}\\) Mars \\(v_{orb,\\text{Mars}} \\approx \\sqrt{\\frac{6.674 \\times 10^{-11} \\cdot 6.417 \\times 10^{23}}{3.390 \\times 10^6}} \\approx 3.56\\,\\text{km/s}\\) \\(v_{esc,\\text{Mars}} \\approx \\sqrt{2} \\cdot v_{orb,\\text{Mars}} \\approx 5.03\\,\\text{km/s}\\) \\(v_{3rd,\\text{Mars}} \\approx \\sqrt{\\frac{2 \\cdot 6.674 \\times 10^{-11} \\cdot 1.989 \\times 10^{30}}{2.279 \\times 10^{11}}} \\approx 38.5\\,\\text{km/s}\\) Jupiter \\(v_{orb,\\text{Jup}} \\approx \\sqrt{\\frac{6.674 \\times 10^{-11} \\cdot 1.898 \\times 10^{27}}{6.9911 \\times 10^7}} \\approx 42.1\\,\\text{km/s}\\) \\(v_{esc,\\text{Jup}} \\approx \\sqrt{2} \\cdot v_{orb,\\text{Jup}} \\approx 59.5\\,\\text{km/s}\\) \\(v_{3rd,\\text{Jup}} \\approx \\sqrt{\\frac{2 \\cdot 6.674 \\times 10^{-11} \\cdot 1.989 \\times 10^{30}}{7.785 \\times 10^{11}}} \\approx 18.5\\,\\text{km/s}\\) 3.4 Summary Table Planet \\(v_{orb}\\) [km/s] \\(v_{esc}\\) [km/s] \\(v_{3rd}\\) [km/s] Earth 7.91 11.19 42.1 Mars 3.56 5.03 38.5 Jupiter 42.1 59.5 18.5 Remarks Earth has a balanced gravity well and a moderately high third cosmic velocity. Mars , due to its smaller mass and radius, has the lowest escape velocities \u2014 making it a practical target for missions. Jupiter has extreme gravitational requirements for launching from the surface, but its position farther from the Sun reduces the third cosmic velocity needed for solar escape. These values are foundational for mission planning and propulsion calculations in aerospace engineering. 4. Visualization and Verification 4.1 Kepler's Third Law Verification: \\(T^2 \\propto r^3\\) import numpy as np import matplotlib.pyplot as plt # Semi-major axes in AU and periods in years (data from real planets) r = np.array([0.39, 0.72, 1.00, 1.52, 5.20, 9.58]) # Mercury to Saturn T = np.array([0.24, 0.62, 1.00, 1.88, 11.86, 29.46]) plt.figure() plt.plot(r**3, T**2, 'o-', label=\"$T^2$ vs $r^3$\") plt.xlabel(\"$r^3$ (AU$^3$)\") plt.ylabel(\"$T^2$ (years$^2$)\") plt.title(\"Verification of Kepler's Third Law\") plt.grid(True) plt.legend() plt.annotate(\"Linear relationship confirms $T^2 \\\\propto r^3$\", xy=(1,1), xytext=(5, 500), arrowprops=dict(arrowstyle=\"->\")) plt.show() 4.2 Log-Log Plot to Check the Slope (Expected \u2248 1) plt.figure() plt.loglog(r, T, 'o-', label=\"Log-Log Plot\") plt.xlabel(\"log($r$) [AU]\") plt.ylabel(\"log($T$) [years]\") plt.title(\"Log-Log Plot of Kepler's Third Law\") plt.grid(True, which='both') # Fit and show slope slope, intercept = np.polyfit(np.log10(r), np.log10(T), 1) plt.text(0.1, 0.3, f\"Slope \u2248 {slope:.2f}\", transform=plt.gca().transAxes) plt.legend() plt.show() 4.3 Comparison of Cosmic Velocities Across Planets import matplotlib.pyplot as plt planets = ['Earth', 'Mars', 'Jupiter'] v_orb = [7.91, 3.56, 42.1] v_esc = [11.19, 5.03, 59.5] v_3rd = [42.1, 38.5, 18.5] x = np.arange(len(planets)) width = 0.25 plt.figure() plt.bar(x - width, v_orb, width, label='1st Cosmic (Orbital)') plt.bar(x, v_esc, width, label='2nd Cosmic (Escape)') plt.bar(x + width, v_3rd, width, label='3rd Cosmic (Solar Escape)') plt.xticks(x, planets) plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Earth, Mars, and Jupiter') plt.legend() plt.grid(axis='y') plt.show() 4.4 Mass/Radius vs Escape Velocity Relationship mass = np.array([5.972e24, 6.417e23, 1.898e27]) # kg radius = np.array([6.371e6, 3.390e6, 6.9911e7]) # m labels = ['Earth', 'Mars', 'Jupiter'] G = 6.674e-11 v_esc = np.sqrt(2 * G * mass / radius) / 1000 # km/s plt.figure() plt.scatter(mass/radius, v_esc) for i, label in enumerate(labels): plt.annotate(label, (mass[i]/radius[i], v_esc[i])) plt.xlabel('Mass/Radius (kg/m)') plt.ylabel('Escape Velocity (km/s)') plt.title('Escape Velocity vs Mass/Radius') plt.grid(True) plt.show() 4.5 Simulated Escape Trajectory (Ballistic Approx.) (Optional) from scipy.integrate import solve_ivp G = 6.674e-11 M_earth = 5.972e24 R_earth = 6.371e6 def trajectory(t, y): r, v = y a = -G * M_earth / r**2 return [v, a] # Initial condition: just above Earth's surface with v_esc v0 = np.sqrt(2 * G * M_earth / R_earth) sol = solve_ivp(trajectory, [0, 10000], [R_earth, v0], t_eval=np.linspace(0, 10000, 1000)) plt.figure() plt.plot(sol.t, (sol.y[0] - R_earth)/1000) plt.xlabel(\"Time (s)\") plt.ylabel(\"Altitude above surface (km)\") plt.title(\"Escape Trajectory from Earth\") plt.grid(True) plt.show() Colab Souce Code 5. Applications & Discussion 5.1 Relevance of Cosmic Velocities in Space Missions a. Satellite Launches For a satellite to maintain a stable low Earth orbit (LEO) , it must achieve the first cosmic velocity , i.e., the orbital velocity: \\[ v_{orb} = \\sqrt{\\frac{GM}{r}} \\] For Earth, this corresponds to approximately \\(7.91\\,\\text{km/s}\\) just above the surface. Rockets are designed to deliver payloads into this velocity band with high precision. Failing to reach this speed causes the satellite to re-enter the atmosphere; exceeding it without further control may lead to escape trajectories. Launch profiles often include a vertical ascent phase (to clear the atmosphere), followed by a gravity turn to achieve horizontal velocity for orbit. b. Planetary Missions To send a spacecraft to Mars , Jupiter , or any other planet, it must at minimum achieve the second cosmic velocity : \\[ v_{esc} = \\sqrt{\\frac{2GM}{r}} \\approx 11.19\\,\\text{km/s} \\quad \\text{(for Earth)} \\] However, this speed only places the spacecraft on a heliocentric (Sun-centered) trajectory. To intercept another planet, precise Hohmann transfer orbits are computed, often using gravitational slingshots for energy efficiency. The launch window is crucial, since planets move in elliptical orbits. Delta-v budgets are carefully calculated to ensure the spacecraft escapes Earth's gravity and enters the correct interplanetary trajectory. c. Interstellar Travel To escape the Solar System , a spacecraft must reach or exceed the third cosmic velocity : \\[ v_{3rd} = \\sqrt{\\frac{2GM_{\\odot}}{r_{\\oplus}}} \\approx 42.1\\,\\text{km/s} \\] This is far beyond the capacity of conventional chemical rockets for direct launch. Missions such as Voyager 1 achieved this by combining multiple gravity assists (Jupiter, Saturn) to boost their velocity incrementally. Interstellar travel requires either: - High-efficiency propulsion (e.g., ion drives, solar sails), - Long mission durations (decades or centuries), - Or breakthrough physics (e.g., nuclear or fusion propulsion). 5.2 Engineering and Fuel Implications Achieving each velocity level involves substantial energy expenditure , and the relationship is non-linear due to the rocket equation : \\[ \\Delta v = v_e \\ln\\left( \\frac{m_0}{m_f} \\right) \\] Where: - \\(\\Delta v\\) is the required change in velocity, - \\(v_e\\) is the effective exhaust velocity of the propulsion system, - \\(m_0\\) and \\(m_f\\) are the initial and final mass of the rocket. Implications: Achieving higher \\(\\Delta v\\) requires either: Extremely efficient engines (high \\(v_e\\) ), Large fuel-to-payload ratios (increasing \\(m_0/m_f\\) ), Or staging : discarding parts of the rocket after burnout. For LEO satellites , small rockets or reusable launchers suffice. For planetary missions , multi-stage rockets like the Saturn V or SLS are necessary. For interstellar probes , current propulsion is inadequate without significant advances in fuel efficiency or entirely new energy sources. Summary Understanding and overcoming the thresholds set by the first, second, and third cosmic velocities is at the core of mission planning in astrodynamics. Each level defines a new frontier: \\(v_{orb}\\) enables orbiting , \\(v_{esc}\\) enables exploration , \\(v_{3rd}\\) hints at the possibility of escape from our solar neighborhood. Each requires innovation in both physics and engineering \u2014 combining mathematical precision, materials science, and propulsion technologies to make the cosmos accessible.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"Escape Velocities and Cosmic Velocities","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-definitions-concepts","text":"","title":"1. Definitions &amp; Concepts"},{"location":"1%20Physics/2%20Gravity/Problem_2/#11-escape-velocity","text":"Escape velocity is the minimum speed an object must reach to break free from the gravitational pull of a celestial body, without any further propulsion. The general formula for escape velocity is derived from the conservation of energy: \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{r} \\] Solving for velocity: \\[ v_{esc} = \\sqrt{\\frac{2GM}{r}} \\] Where: - \\(v_{esc}\\) is the escape velocity, - \\(G\\) is the gravitational constant \\((6.674 \\times 10^{-11}\\,\\text{m}^3\\,\\text{kg}^{-1}\\,\\text{s}^{-2})\\) , - \\(M\\) is the mass of the celestial body, - \\(r\\) is the distance from the center of the body to the point of escape (typically the planet\u2019s radius).","title":"1.1 Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#12-first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity refers to the minimum horizontal speed an object must have to remain in a stable, circular orbit just above the surface of a celestial body, without falling back to the surface. It is derived by equating gravitational force to centripetal force: \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Solving for \\(v\\) : \\[ v_{orb} = \\sqrt{\\frac{GM}{r}} \\] This is also called the orbital velocity , and it is lower than escape velocity: \\[ v_{orb} = \\frac{v_{esc}}{\\sqrt{2}} \\]","title":"1.2 First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#13-second-cosmic-velocity","text":"The second cosmic velocity is simply another term for escape velocity from a planetary body. It is the minimum speed required to completely escape the gravitational influence of the planet and enter into space, assuming no further propulsion. Thus: \\[ v_{2nd} = v_{esc} = \\sqrt{\\frac{2GM}{r}} \\]","title":"1.3 Second Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#14-third-cosmic-velocity","text":"The third cosmic velocity is the speed required for a spacecraft to escape not only Earth\u2019s gravity, but also the Sun\u2019s gravity, starting from Earth\u2019s orbit. This is relevant for interstellar missions. This involves both Earth\u2019s orbital velocity around the Sun and the Sun\u2019s gravitational influence. It can be approximated by: \\[ v_{3rd} = \\sqrt{v_{esc,\\odot}^2 + v_{orb,\\oplus}^2} \\] Where: - \\(v_{esc,\\odot}\\) is the escape velocity from the Sun at Earth\u2019s distance, - \\(v_{orb,\\oplus}\\) is Earth\u2019s orbital speed around the Sun ( \\(\\approx 29.78\\,\\text{km/s}\\) ). A simplified expression (ignoring Earth's gravity) for escaping the Solar System from Earth\u2019s orbit: \\[ v_{3rd} \\approx \\sqrt{\\frac{2GM_{\\odot}}{r_{\\oplus}}} \\] Where: - \\(M_{\\odot}\\) is the mass of the Sun, - \\(r_{\\oplus}\\) is the average distance from Earth to the Sun ( \\(\\approx 1.496 \\times 10^{11}\\,\\text{m}\\) ).","title":"1.4 Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#15-physical-meaning-in-space-exploration","text":"First Cosmic Velocity is the target speed for launching satellites into low Earth orbit. It represents the threshold for achieving continuous free-fall around Earth. Second Cosmic Velocity is critical for missions intending to leave Earth's orbit \u2014 such as lunar missions or probes bound for other planets. Third Cosmic Velocity pertains to missions aiming to exit the Solar System, such as the Voyager and Pioneer spacecraft. Achieving this velocity allows an object to overcome the Sun\u2019s gravitational hold. Understanding these velocities is fundamental for determining fuel requirements, launch windows, and mission design in astrodynamics and interplanetary navigation .","title":"1.5 Physical Meaning in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-mathematical-derivations","text":"","title":"2. Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-escape-velocity","text":"To derive the escape velocity, we equate the kinetic energy of an object to the gravitational potential energy required to escape the gravitational field of a body. Kinetic energy of the object: $$ KE = \\frac{1}{2}mv^2 $$ Gravitational potential energy of the object (at distance \\(r\\) from the center of mass \\(M\\) ): $$ U = -\\frac{GMm}{r} $$ For escape, the total mechanical energy must be zero: \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{r} = 0 \\] Solving for \\(v\\) : \\[ v_{esc} = \\sqrt{\\frac{2GM}{r}} \\] This velocity is independent of the mass of the escaping object and depends only on the mass and radius of the celestial body.","title":"2.1 Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-first-cosmic-velocity-orbital-velocity","text":"This is the velocity required to keep an object in circular orbit just above the surface of a planet. It is derived by balancing the gravitational force and the required centripetal force: Gravitational force: $$ F_g = \\frac{GMm}{r^2} $$ Centripetal force: $$ F_c = \\frac{mv^2}{r} $$ Setting \\(F_g = F_c\\) : \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Cancelling \\(m\\) and solving for \\(v\\) : \\[ v_{orb} = \\sqrt{\\frac{GM}{r}} \\] This is the first cosmic velocity and is precisely the speed needed for stable circular orbit at altitude zero (neglecting atmosphere).","title":"2.2 First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#23-third-cosmic-velocity","text":"The third cosmic velocity is the speed required to escape the Sun\u2019s gravitational field from Earth\u2019s orbit. The Sun\u2019s gravitational potential energy at Earth\u2019s orbital distance: \\[ U = -\\frac{GM_{\\odot}m}{r_{\\oplus}} \\] Kinetic energy needed to escape from the Sun\u2019s gravity: \\[ \\frac{1}{2}mv^2 = \\frac{GM_{\\odot}m}{r_{\\oplus}} \\] Solving for \\(v\\) : \\[ v_{3rd} = \\sqrt{\\frac{2GM_{\\odot}}{r_{\\oplus}}} \\] However, since Earth is already moving at orbital velocity \\(v_{\\oplus} \\approx 29.78\\) km/s, the spacecraft only needs additional velocity beyond this: \\[ v_{3rd,\\,launch} = \\sqrt{v_{esc,\\odot}^2 + v_{\\oplus}^2} \\] In practice, this value is adjusted depending on the spacecraft's launch trajectory and timing (e.g., gravity assists).","title":"2.3 Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#24-influence-of-mass-and-radius","text":"From the escape velocity formula: \\[ v_{esc} = \\sqrt{\\frac{2GM}{r}}, \\quad v_{orb} = \\sqrt{\\frac{GM}{r}} \\] We can draw the following conclusions: Mass ( \\(M\\) ) : As the mass of the celestial body increases, both escape and orbital velocities increase. Radius ( \\(r\\) ) : As the radius increases, the velocities decrease. This is because the gravitational potential becomes weaker farther from the center of mass. Thus, denser and more massive planets like Jupiter have significantly higher escape velocities than Mars .","title":"2.4 Influence of Mass and Radius"},{"location":"1%20Physics/2%20Gravity/Problem_2/#25-assumptions-in-derivations","text":"These derivations rely on several simplifying assumptions: The celestial body is a perfect sphere with mass concentrated at the center (i.e., it behaves as a point mass). No atmospheric drag or air resistance is considered (ideal vacuum conditions). No rotational effects (e.g., Coriolis force or frame-dragging from planet spin). The motion is assumed to be purely radial (for escape) or circular (for orbit). The object has no propulsion after initial velocity is imparted (i.e., ballistic motion). These assumptions allow for clean analytical expressions but differ from real-world engineering, where rocket burns, drag, and non-uniform mass distributions are considered.","title":"2.5 Assumptions in Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-calculations","text":"","title":"3. Calculations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#31-constants-and-celestial-parameters","text":"We begin by defining the necessary physical constants and planetary data:","title":"3.1 Constants and Celestial Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#universal-constants","text":"Gravitational constant: $$ G = 6.674 \\times 10^{-11}\\,\\text{m}^3\\,\\text{kg}^{-1}\\,\\text{s}^{-2} $$","title":"Universal Constants"},{"location":"1%20Physics/2%20Gravity/Problem_2/#planetary-data","text":"Planet Mass \\((M)\\) [kg] Radius \\((r)\\) [m] Distance from Sun \\((r_{\\odot})\\) [m] Earth \\(5.972 \\times 10^{24}\\) \\(6.371 \\times 10^6\\) \\(1.496 \\times 10^{11}\\) Mars \\(6.417 \\times 10^{23}\\) \\(3.390 \\times 10^6\\) \\(2.279 \\times 10^{11}\\) Jupiter \\(1.898 \\times 10^{27}\\) \\(6.9911 \\times 10^7\\) \\(7.785 \\times 10^{11}\\)","title":"Planetary Data"},{"location":"1%20Physics/2%20Gravity/Problem_2/#solar-mass","text":"Mass of the Sun: $$ M_{\\odot} = 1.989 \\times 10^{30}\\,\\text{kg} $$","title":"Solar Mass"},{"location":"1%20Physics/2%20Gravity/Problem_2/#32-formulas","text":"First Cosmic Velocity (Orbital): $$ v_{orb} = \\sqrt{\\frac{GM}{r}} $$ Second Cosmic Velocity (Escape): $$ v_{esc} = \\sqrt{\\frac{2GM}{r}} $$ Third Cosmic Velocity (Escape from the Sun at planetary orbit): $$ v_{3rd} = \\sqrt{\\frac{2GM_{\\odot}}{r_{\\odot}}} $$ Note: We assume these are launched directly from the surface or orbital path with negligible atmospheric drag and no propulsion.","title":"3.2 Formulas"},{"location":"1%20Physics/2%20Gravity/Problem_2/#33-numerical-calculations","text":"","title":"3.3 Numerical Calculations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#earth","text":"\\(v_{orb,\\oplus} = \\sqrt{\\frac{6.674 \\times 10^{-11} \\cdot 5.972 \\times 10^{24}}{6.371 \\times 10^6}} \\approx 7.91\\,\\text{km/s}\\) \\(v_{esc,\\oplus} = \\sqrt{2} \\cdot v_{orb,\\oplus} \\approx 11.19\\,\\text{km/s}\\) \\(v_{3rd,\\oplus} = \\sqrt{\\frac{2 \\cdot 6.674 \\times 10^{-11} \\cdot 1.989 \\times 10^{30}}{1.496 \\times 10^{11}}} \\approx 42.1\\,\\text{km/s}\\)","title":"Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mars","text":"\\(v_{orb,\\text{Mars}} \\approx \\sqrt{\\frac{6.674 \\times 10^{-11} \\cdot 6.417 \\times 10^{23}}{3.390 \\times 10^6}} \\approx 3.56\\,\\text{km/s}\\) \\(v_{esc,\\text{Mars}} \\approx \\sqrt{2} \\cdot v_{orb,\\text{Mars}} \\approx 5.03\\,\\text{km/s}\\) \\(v_{3rd,\\text{Mars}} \\approx \\sqrt{\\frac{2 \\cdot 6.674 \\times 10^{-11} \\cdot 1.989 \\times 10^{30}}{2.279 \\times 10^{11}}} \\approx 38.5\\,\\text{km/s}\\)","title":"Mars"},{"location":"1%20Physics/2%20Gravity/Problem_2/#jupiter","text":"\\(v_{orb,\\text{Jup}} \\approx \\sqrt{\\frac{6.674 \\times 10^{-11} \\cdot 1.898 \\times 10^{27}}{6.9911 \\times 10^7}} \\approx 42.1\\,\\text{km/s}\\) \\(v_{esc,\\text{Jup}} \\approx \\sqrt{2} \\cdot v_{orb,\\text{Jup}} \\approx 59.5\\,\\text{km/s}\\) \\(v_{3rd,\\text{Jup}} \\approx \\sqrt{\\frac{2 \\cdot 6.674 \\times 10^{-11} \\cdot 1.989 \\times 10^{30}}{7.785 \\times 10^{11}}} \\approx 18.5\\,\\text{km/s}\\)","title":"Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#34-summary-table","text":"Planet \\(v_{orb}\\) [km/s] \\(v_{esc}\\) [km/s] \\(v_{3rd}\\) [km/s] Earth 7.91 11.19 42.1 Mars 3.56 5.03 38.5 Jupiter 42.1 59.5 18.5","title":"3.4 Summary Table"},{"location":"1%20Physics/2%20Gravity/Problem_2/#remarks","text":"Earth has a balanced gravity well and a moderately high third cosmic velocity. Mars , due to its smaller mass and radius, has the lowest escape velocities \u2014 making it a practical target for missions. Jupiter has extreme gravitational requirements for launching from the surface, but its position farther from the Sun reduces the third cosmic velocity needed for solar escape. These values are foundational for mission planning and propulsion calculations in aerospace engineering.","title":"Remarks"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-visualization-and-verification","text":"","title":"4. Visualization and Verification"},{"location":"1%20Physics/2%20Gravity/Problem_2/#41-keplers-third-law-verification-t2-propto-r3","text":"import numpy as np import matplotlib.pyplot as plt # Semi-major axes in AU and periods in years (data from real planets) r = np.array([0.39, 0.72, 1.00, 1.52, 5.20, 9.58]) # Mercury to Saturn T = np.array([0.24, 0.62, 1.00, 1.88, 11.86, 29.46]) plt.figure() plt.plot(r**3, T**2, 'o-', label=\"$T^2$ vs $r^3$\") plt.xlabel(\"$r^3$ (AU$^3$)\") plt.ylabel(\"$T^2$ (years$^2$)\") plt.title(\"Verification of Kepler's Third Law\") plt.grid(True) plt.legend() plt.annotate(\"Linear relationship confirms $T^2 \\\\propto r^3$\", xy=(1,1), xytext=(5, 500), arrowprops=dict(arrowstyle=\"->\")) plt.show()","title":"4.1 Kepler's Third Law Verification: \\(T^2 \\propto r^3\\)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#42-log-log-plot-to-check-the-slope-expected-1","text":"plt.figure() plt.loglog(r, T, 'o-', label=\"Log-Log Plot\") plt.xlabel(\"log($r$) [AU]\") plt.ylabel(\"log($T$) [years]\") plt.title(\"Log-Log Plot of Kepler's Third Law\") plt.grid(True, which='both') # Fit and show slope slope, intercept = np.polyfit(np.log10(r), np.log10(T), 1) plt.text(0.1, 0.3, f\"Slope \u2248 {slope:.2f}\", transform=plt.gca().transAxes) plt.legend() plt.show()","title":"4.2 Log-Log Plot to Check the Slope (Expected \u2248 1)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#43-comparison-of-cosmic-velocities-across-planets","text":"import matplotlib.pyplot as plt planets = ['Earth', 'Mars', 'Jupiter'] v_orb = [7.91, 3.56, 42.1] v_esc = [11.19, 5.03, 59.5] v_3rd = [42.1, 38.5, 18.5] x = np.arange(len(planets)) width = 0.25 plt.figure() plt.bar(x - width, v_orb, width, label='1st Cosmic (Orbital)') plt.bar(x, v_esc, width, label='2nd Cosmic (Escape)') plt.bar(x + width, v_3rd, width, label='3rd Cosmic (Solar Escape)') plt.xticks(x, planets) plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Earth, Mars, and Jupiter') plt.legend() plt.grid(axis='y') plt.show()","title":"4.3 Comparison of Cosmic Velocities Across Planets"},{"location":"1%20Physics/2%20Gravity/Problem_2/#44-massradius-vs-escape-velocity-relationship","text":"mass = np.array([5.972e24, 6.417e23, 1.898e27]) # kg radius = np.array([6.371e6, 3.390e6, 6.9911e7]) # m labels = ['Earth', 'Mars', 'Jupiter'] G = 6.674e-11 v_esc = np.sqrt(2 * G * mass / radius) / 1000 # km/s plt.figure() plt.scatter(mass/radius, v_esc) for i, label in enumerate(labels): plt.annotate(label, (mass[i]/radius[i], v_esc[i])) plt.xlabel('Mass/Radius (kg/m)') plt.ylabel('Escape Velocity (km/s)') plt.title('Escape Velocity vs Mass/Radius') plt.grid(True) plt.show()","title":"4.4 Mass/Radius vs Escape Velocity Relationship"},{"location":"1%20Physics/2%20Gravity/Problem_2/#45-simulated-escape-trajectory-ballistic-approx-optional","text":"from scipy.integrate import solve_ivp G = 6.674e-11 M_earth = 5.972e24 R_earth = 6.371e6 def trajectory(t, y): r, v = y a = -G * M_earth / r**2 return [v, a] # Initial condition: just above Earth's surface with v_esc v0 = np.sqrt(2 * G * M_earth / R_earth) sol = solve_ivp(trajectory, [0, 10000], [R_earth, v0], t_eval=np.linspace(0, 10000, 1000)) plt.figure() plt.plot(sol.t, (sol.y[0] - R_earth)/1000) plt.xlabel(\"Time (s)\") plt.ylabel(\"Altitude above surface (km)\") plt.title(\"Escape Trajectory from Earth\") plt.grid(True) plt.show()","title":"4.5 Simulated Escape Trajectory (Ballistic Approx.) (Optional)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#colab","text":"Souce Code","title":"Colab"},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-applications-discussion","text":"","title":"5. Applications &amp; Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_2/#51-relevance-of-cosmic-velocities-in-space-missions","text":"","title":"5.1 Relevance of Cosmic Velocities in Space Missions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#a-satellite-launches","text":"For a satellite to maintain a stable low Earth orbit (LEO) , it must achieve the first cosmic velocity , i.e., the orbital velocity: \\[ v_{orb} = \\sqrt{\\frac{GM}{r}} \\] For Earth, this corresponds to approximately \\(7.91\\,\\text{km/s}\\) just above the surface. Rockets are designed to deliver payloads into this velocity band with high precision. Failing to reach this speed causes the satellite to re-enter the atmosphere; exceeding it without further control may lead to escape trajectories. Launch profiles often include a vertical ascent phase (to clear the atmosphere), followed by a gravity turn to achieve horizontal velocity for orbit.","title":"a. Satellite Launches"},{"location":"1%20Physics/2%20Gravity/Problem_2/#b-planetary-missions","text":"To send a spacecraft to Mars , Jupiter , or any other planet, it must at minimum achieve the second cosmic velocity : \\[ v_{esc} = \\sqrt{\\frac{2GM}{r}} \\approx 11.19\\,\\text{km/s} \\quad \\text{(for Earth)} \\] However, this speed only places the spacecraft on a heliocentric (Sun-centered) trajectory. To intercept another planet, precise Hohmann transfer orbits are computed, often using gravitational slingshots for energy efficiency. The launch window is crucial, since planets move in elliptical orbits. Delta-v budgets are carefully calculated to ensure the spacecraft escapes Earth's gravity and enters the correct interplanetary trajectory.","title":"b. Planetary Missions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#c-interstellar-travel","text":"To escape the Solar System , a spacecraft must reach or exceed the third cosmic velocity : \\[ v_{3rd} = \\sqrt{\\frac{2GM_{\\odot}}{r_{\\oplus}}} \\approx 42.1\\,\\text{km/s} \\] This is far beyond the capacity of conventional chemical rockets for direct launch. Missions such as Voyager 1 achieved this by combining multiple gravity assists (Jupiter, Saturn) to boost their velocity incrementally. Interstellar travel requires either: - High-efficiency propulsion (e.g., ion drives, solar sails), - Long mission durations (decades or centuries), - Or breakthrough physics (e.g., nuclear or fusion propulsion).","title":"c. Interstellar Travel"},{"location":"1%20Physics/2%20Gravity/Problem_2/#52-engineering-and-fuel-implications","text":"Achieving each velocity level involves substantial energy expenditure , and the relationship is non-linear due to the rocket equation : \\[ \\Delta v = v_e \\ln\\left( \\frac{m_0}{m_f} \\right) \\] Where: - \\(\\Delta v\\) is the required change in velocity, - \\(v_e\\) is the effective exhaust velocity of the propulsion system, - \\(m_0\\) and \\(m_f\\) are the initial and final mass of the rocket.","title":"5.2 Engineering and Fuel Implications"},{"location":"1%20Physics/2%20Gravity/Problem_2/#implications","text":"Achieving higher \\(\\Delta v\\) requires either: Extremely efficient engines (high \\(v_e\\) ), Large fuel-to-payload ratios (increasing \\(m_0/m_f\\) ), Or staging : discarding parts of the rocket after burnout. For LEO satellites , small rockets or reusable launchers suffice. For planetary missions , multi-stage rockets like the Saturn V or SLS are necessary. For interstellar probes , current propulsion is inadequate without significant advances in fuel efficiency or entirely new energy sources.","title":"Implications:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#summary","text":"Understanding and overcoming the thresholds set by the first, second, and third cosmic velocities is at the core of mission planning in astrodynamics. Each level defines a new frontier: \\(v_{orb}\\) enables orbiting , \\(v_{esc}\\) enables exploration , \\(v_{3rd}\\) hints at the possibility of escape from our solar neighborhood. Each requires innovation in both physics and engineering \u2014 combining mathematical precision, materials science, and propulsion technologies to make the cosmos accessible.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth 1. Physics and Mathematical Foundations 1.1 Newton\u2019s Law of Gravitation Newton\u2019s Law of Gravitation states that every mass attracts every other mass with a force \\(F\\) given by: \\[ F = G \\frac{m_1 m_2}{r^2} \\] where: - \\(F\\) is the gravitational force, - \\(G\\) is the gravitational constant ( \\(G \\approx 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ), - \\(m_1\\) and \\(m_2\\) are the masses of the two objects, - \\(r\\) is the distance between the centers of the two masses. The gravitational force acts along the line joining the two masses. 1.2 Newton\u2019s Second Law Applied to Gravity Newton's Second Law states that the force on an object is proportional to its acceleration: \\[ \\vec{F} = m \\vec{a} \\] Applying this to gravitational force: \\[ m \\vec{a} = -G \\frac{M m}{r^2} \\hat{r} \\] Simplifying: \\[ \\vec{a} = -G \\frac{M}{r^2} \\hat{r} \\] where: - \\(\\vec{a}\\) is the acceleration vector, - \\(M\\) is the mass of the Earth, - \\(\\hat{r}\\) is the unit vector pointing from the payload to the Earth's center. This acceleration governs the motion of a freely falling payload near Earth. 1.3 Conic Sections and Trajectory Classification The path followed by the payload is a conic section determined by the total specific mechanical energy \\(\\varepsilon\\) : \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] where: - \\(v\\) is the magnitude of velocity, - \\(r\\) is the radial distance from Earth's center. The type of trajectory depends on \\(\\varepsilon\\) : - If \\(\\varepsilon < 0\\) , the trajectory is elliptical (bound orbit). - If \\(\\varepsilon = 0\\) , the trajectory is parabolic (escape at exactly escape velocity). - If \\(\\varepsilon > 0\\) , the trajectory is hyperbolic (escape with surplus energy). The general equation for conic sections in polar coordinates: \\[ r(\\theta) = \\frac{p}{1 + e \\cos(\\theta)} \\] where: - \\(p\\) is the semi-latus rectum, - \\(e\\) is the eccentricity: - \\(0 \\leq e < 1\\) for an ellipse, - \\(e = 1\\) for a parabola, - \\(e > 1\\) for a hyperbola. 1.4 Orbital Energy (Specific Mechanical Energy) Specific mechanical energy \\(\\varepsilon\\) combines kinetic and potential energy per unit mass: \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] where: - Positive \\(\\varepsilon\\) implies unbound (hyperbolic) motion, - Zero \\(\\varepsilon\\) corresponds to parabolic escape, - Negative \\(\\varepsilon\\) indicates a bound (elliptical) orbit. The escape velocity \\(v_{\\text{esc}}\\) is derived by setting \\(\\varepsilon = 0\\) : \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] Thus, if the initial velocity \\(v > v_{\\text{esc}}\\) , the payload will escape Earth\u2019s gravity. 1.5 Kepler\u2019s Laws of Planetary Motion First Law (Law of Ellipses) : Every orbit of a planet or object is an ellipse with the center of mass at one of the two foci. Second Law (Law of Equal Areas) : A line joining a planet and the Sun sweeps out equal areas during equal intervals of time. Mathematically: $$ \\frac{dA}{dt} = \\text{constant} $$ where \\(A\\) is the area swept out. Third Law (Law of Harmonies) : The square of the orbital period \\(T\\) is proportional to the cube of the semi-major axis \\(a\\) : $$ T^2 \\propto a^3 $$ or more precisely: $$ T^2 = \\frac{4\\pi^2}{GM} a^3 $$ These laws govern the orbital behavior of payloads near Earth and help predict future positions and velocities. 2. Identify and Define Initial Conditions To model and simulate the trajectory of a payload released near Earth, it is essential to specify the initial conditions precisely. These parameters determine the entire motion under gravitational forces. 2.1 Initial Position (Vector Relative to Earth\u2019s Center) The initial position \\(\\vec{r}_0\\) of the payload is given relative to the center of Earth: \\[ \\vec{r}_0 = (x_0, y_0, z_0) \\] where: - \\(x_0\\) , \\(y_0\\) , and \\(z_0\\) are the Cartesian coordinates of the payload in an inertial reference frame, - Alternatively, the position can be expressed in polar coordinates \\((r_0, \\theta_0, \\phi_0)\\) : - \\(r_0\\) is the radial distance from Earth's center, - \\(\\theta_0\\) is the azimuthal angle (longitude), - \\(\\phi_0\\) is the polar angle (colatitude). For many problems, assuming motion in a plane (e.g., equatorial plane) simplifies calculations by setting \\(z_0 = 0\\) . 2.2 Initial Velocity (Vector at Release) The initial velocity \\(\\vec{v}_0\\) of the payload must be defined with both magnitude and direction: \\[ \\vec{v}_0 = (v_{x,0}, v_{y,0}, v_{z,0}) \\] or alternatively in polar terms: \\[ \\vec{v}_0 = v_{r,0} \\hat{r} + v_{\\theta,0} \\hat{\\theta} \\] where: - \\(v_{r,0}\\) is the radial component (along \\(\\hat{r}\\) ), - \\(v_{\\theta,0}\\) is the transverse component (perpendicular to \\(\\hat{r}\\) in the orbital plane). The initial velocity vector relative to the local horizontal critically determines the type of trajectory: - Purely radial launch ( \\(v_{\\theta,0} = 0\\) ) results in a straight path, - Purely tangential launch ( \\(v_{r,0} = 0\\) ) can lead to circular or elliptical orbits, - Mixed radial and tangential velocities create general elliptical, hyperbolic, or parabolic paths. 2.3 Initial Altitude Above Earth\u2019s Surface The altitude \\(h_0\\) is the height of the payload above the Earth's surface: \\[ h_0 = r_0 - R_E \\] where: - \\(r_0\\) is the distance from the Earth's center, - \\(R_E\\) is the radius of the Earth ( \\(R_E \\approx 6371 \\, \\text{km}\\) ). The altitude is crucial because it influences the local gravitational force magnitude. The local gravitational acceleration \\(g(h)\\) at altitude \\(h\\) is given by: \\[ g(h) = \\frac{GM}{(R_E + h)^2} \\] 2.4 Gravitational Parameter of Earth (GM Value) The gravitational parameter \\(\\mu\\) (also called standard gravitational parameter) is defined as: \\[ \\mu = GM \\] where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the Earth. Numerically: \\[ \\mu \\approx 3.986 \\times 10^{14} \\, \\text{m}^3 \\, \\text{s}^{-2} \\] Using \\(\\mu\\) simplifies many orbital mechanics equations, for instance: Specific mechanical energy: \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{\\mu}{r} \\] Orbital velocity at a distance \\(r\\) for circular orbit: \\[ v_{\\text{circ}} = \\sqrt{\\frac{\\mu}{r}} \\] Escape velocity from distance \\(r\\) : \\[ v_{\\text{esc}} = \\sqrt{\\frac{2\\mu}{r}} \\] Knowledge of \\(\\mu\\) enables precise calculations of the payload\u2019s motion and trajectory classification. 3. Trajectory Analysis Understanding the trajectory of a payload released near Earth involves deriving its equations of motion under gravitational forces, analyzing specific orbital energy, and considering the influence of initial velocity magnitude and direction. 3.1 Equations of Motion (Second-Order Differential Equations) The motion of a payload under Earth's gravity is governed by Newton\u2019s Second Law: \\[ \\vec{F} = m \\vec{a} \\] Substituting the gravitational force: \\[ m \\vec{a} = -G \\frac{Mm}{r^2} \\hat{r} \\] Simplifying: \\[ \\vec{a} = -\\frac{\\mu}{r^2} \\hat{r} \\] where \\(\\mu = GM\\) is the standard gravitational parameter. In Cartesian coordinates \\((x, y, z)\\) , the second-order differential equations of motion are: \\[ \\ddot{x} = -\\frac{\\mu x}{(x^2 + y^2 + z^2)^{3/2}} \\] \\[ \\ddot{y} = -\\frac{\\mu y}{(x^2 + y^2 + z^2)^{3/2}} \\] \\[ \\ddot{z} = -\\frac{\\mu z}{(x^2 + y^2 + z^2)^{3/2}} \\] where \\(\\ddot{x}\\) , \\(\\ddot{y}\\) , and \\(\\ddot{z}\\) are the second derivatives of position with respect to time (accelerations). These equations describe the continuous motion of the payload influenced solely by Earth's gravitational field. 3.2 Specific Orbital Energy and Trajectory Classification The specific mechanical energy \\(\\varepsilon\\) is the sum of the specific kinetic and specific potential energies: \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{\\mu}{r} \\] where: - \\(v\\) is the magnitude of the velocity vector, - \\(r\\) is the radial distance from Earth's center. Classification based on \\(\\varepsilon\\) : - Elliptical Orbit (Bound) : $$ \\varepsilon < 0 $$ The payload remains gravitationally bound to Earth, following a closed, elliptical path. Parabolic Trajectory (Escape at Minimum Energy) : $$ \\varepsilon = 0 $$ The payload reaches exactly escape velocity and follows a parabolic trajectory, escaping Earth's gravity without excess energy. Hyperbolic Trajectory (Escape with Excess Energy) : $$ \\varepsilon > 0 $$ The payload escapes Earth's gravity with surplus kinetic energy, following an open hyperbolic path. 3.3 Effect of Initial Velocity Direction and Magnitude The initial velocity \\(\\vec{v}_0\\) relative to the local horizontal plane significantly influences the resulting trajectory: Purely Horizontal Launch : When the velocity is tangential to the surface (local horizontal), Enables orbital motion (circular or elliptical) if the speed is appropriate. Purely Radial Launch : When the velocity is directed straight outward or inward, Leads to vertical ascent or descent, If \\(v_0 \\geq v_{\\text{esc}}\\) , the object escapes along a parabolic or hyperbolic path. Mixed Direction Launch : A combination of radial and tangential components, Creates general elliptical or hyperbolic trajectories, The trajectory\u2019s shape and energy depend on the proportion of radial versus tangential velocity components. Decomposition of Initial Velocity: Given an angle \\(\\alpha\\) between the initial velocity vector and the local horizontal: \\[ v_{r,0} = v_0 \\sin(\\alpha) \\] \\[ v_{\\theta,0} = v_0 \\cos(\\alpha) \\] where: - \\(v_{r,0}\\) is the initial radial velocity component, - \\(v_{\\theta,0}\\) is the initial tangential (horizontal) velocity component. The effective orbital behavior thus depends on both the magnitude and the angle of the initial velocity. 3.4 Summary Accurately setting up the equations of motion and understanding specific orbital energy are fundamental for classifying the payload\u2019s trajectory after release. The initial velocity vector\u2019s magnitude and direction relative to the local horizontal critically determine whether the payload will: - Remain in orbit, - Fall back to Earth, - Escape Earth's gravitational influence entirely. 4. Numerical Simulation Setup Numerical simulations are essential for modeling the trajectory of a payload released near Earth. Due to the nonlinear nature of gravitational acceleration, analytical solutions are often impractical for general initial conditions, necessitating the use of numerical integration techniques. 4.1 Choosing a Numerical Integration Method The equations of motion derived earlier form a system of second-order ordinary differential equations (ODEs). To solve them numerically, it is standard practice to transform them into a system of first-order ODEs by introducing velocity components as independent variables. Let: \\[ \\vec{r} = (x, y, z), \\quad \\vec{v} = (\\dot{x}, \\dot{y}, \\dot{z}) \\] Then the system becomes: \\[ \\dot{\\vec{r}} = \\vec{v} \\] \\[ \\dot{\\vec{v}} = -\\frac{\\mu}{r^3} \\vec{r} \\] where \\(r = \\|\\vec{r}\\|\\) . Recommended Numerical Methods: Euler's Method (First-order accuracy): Simple but prone to large errors over time. Only suitable for very small time steps. Runge-Kutta Methods : Runge-Kutta 2nd Order (RK2) : Moderate accuracy, relatively easy to implement. Runge-Kutta 4th Order (RK4) : High accuracy, widely used for orbit simulations. Runge-Kutta 4th Order (RK4) algorithm for advancing from \\(t_n\\) to \\(t_{n+1} = t_n + \\Delta t\\) : \\[ \\begin{aligned} k_1 &= f(t_n, y_n) \\\\ k_2 &= f\\left(t_n + \\frac{\\Delta t}{2}, y_n + \\frac{\\Delta t}{2}k_1\\right) \\\\ k_3 &= f\\left(t_n + \\frac{\\Delta t}{2}, y_n + \\frac{\\Delta t}{2}k_2\\right) \\\\ k_4 &= f\\left(t_n + \\Delta t, y_n + \\Delta t \\, k_3\\right) \\\\ y_{n+1} &= y_n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4) \\end{aligned} \\] where \\(y\\) represents the state vector containing both \\(\\vec{r}\\) and \\(\\vec{v}\\) . 4.2 Time-Stepping and Tolerances for Numerical Accuracy The choice of time step \\(\\Delta t\\) is crucial: - If \\(\\Delta t\\) is too large, the simulation will suffer from significant numerical errors (e.g., energy drift). - If \\(\\Delta t\\) is too small, the simulation will be accurate but computationally expensive. Typical considerations: - Adaptive time-stepping can be employed, adjusting \\(\\Delta t\\) based on local truncation error estimates. - Otherwise, use a fixed \\(\\Delta t\\) small enough to accurately resolve the motion: Rule of thumb: \\(\\Delta t\\) should be at least \\(1000\\) times smaller than the orbital period for stable simulations. Tolerance settings (if using adaptive methods like Runge-Kutta-Fehlberg): - Relative Tolerance \\(\\sim 10^{-9}\\) - Absolute Tolerance \\(\\sim 10^{-12}\\) Maintaining energy conservation can serve as a good diagnostic for checking numerical accuracy. 4.3 Simplifications: Accounting Only for Earth's Gravity In this model: - Only central gravitational force from Earth is considered. - Atmospheric drag , solar radiation pressure , third-body effects (e.g., Moon, Sun) are ignored unless specified otherwise. The governing acceleration thus remains: \\[ \\vec{a} = -\\frac{\\mu}{r^3} \\vec{r} \\] Assumptions: - Earth is treated as a perfect sphere. - Earth's rotation effects (like Coriolis or centrifugal forces) are neglected unless explicitly modeled in a rotating reference frame. - No oblateness (no \\(J_2\\) perturbation). This simplifies the dynamics to a classic two-body problem under Newtonian gravity. 4.4 Summary For accurate simulation of a payload\u2019s trajectory near Earth: - Use Runge-Kutta 4th order method for numerical integration. - Choose appropriate time step sizes and consider adaptive time-stepping for high accuracy. - Focus solely on Earth\u2019s gravitational attraction unless additional forces are explicitly required. Proper numerical setup ensures reliable, physically consistent simulations essential for analyzing orbital dynamics. 5. Computational Tool and Visualization Calculate \\(v_{\\text{circ}}\\) and \\(v_{\\text{esc}}\\) for 1000 km altitude once and print/display them: r0 = R_earth + 1_000_000 # 1000 km altitude v_circ = np.sqrt(G*M_earth/r0) v_esc = np.sqrt(2*G*M_earth/r0) print(f\"Circular orbital velocity at 1000 km: {v_circ/1000:.2f} km/s\") print(f\"Escape velocity at 1000 km: {v_esc/1000:.2f} km/s\") 5.1 Crashing or Suborbital Trajectories import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M_earth = 5.972e24 R_earth = 6.371e6 # Simulation function def simulate_orbit(v0, steps=100000, dt=1): r0 = R_earth + 1_000_000 # 1000 km above surface x, y = r0, 0 vx, vy = 0, v0 pos = [] r_min, r_max = float('inf'), 0 escaped = False for _ in range(steps): r = np.sqrt(x**2 + y**2) if r < R_earth: break pos.append((x, y)) a = -G * M_earth / r**2 ax = a * x / r ay = a * y / r vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt r_min = min(r_min, r) r_max = max(r_max, r) if r > 20 * R_earth: escaped = True break return np.array(pos), r_min, r_max, escaped # Part 1: Low velocities (crash back) velocities = [4000, 5000, 6000, 7000, 8000] # m/s plt.figure(figsize=(8,8)) theta = np.linspace(0, 2*np.pi, 100) # plt.fill(R_earth*np.cos(theta), R_earth*np.sin(theta), color='lightblue', label='Earth') plt.fill(R_earth*np.cos(theta)/1000, R_earth*np.sin(theta)/1000, color='lightblue', label='Earth') plt.plot(0, 0, 'oy', label='Center of Earth') for v0 in velocities: traj, r_min, r_max, escaped = simulate_orbit(v0) x, y = traj[:,0], traj[:,1] # plt.plot(x, y, label=f'{v0/1000:.1f} km/s') plt.plot(x/1000, y/1000, label=f'{v0/1000:.1f} km/s') print(f\"v0={v0/1000:.1f} km/s | Perigee: {r_min/1000:.1f} km | Apogee: {r_max/1000:.1f} km | Escaped: {escaped}\") plt.title('Low Velocities: Crashing/Short Trajectories') plt.xlabel('x [km]') plt.ylabel('y [km]') plt.legend() plt.grid() plt.axis('equal') plt.show() 5.2 Circular and Elliptical Orbits (Bounded) import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M_earth = 5.972e24 R_earth = 6.371e6 # Simulation function def simulate_orbit(v0, steps=100000, dt=1): r0 = R_earth + 1_000_000 # 1000 km above surface x, y = r0, 0 vx, vy = 0, v0 pos = [] r_min, r_max = float('inf'), 0 escaped = False for _ in range(steps): r = np.sqrt(x**2 + y**2) if r < R_earth: break pos.append((x, y)) a = -G * M_earth / r**2 ax = a * x / r ay = a * y / r vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt r_min = min(r_min, r) r_max = max(r_max, r) if r > 20 * R_earth: escaped = True break return np.array(pos), r_min, r_max, escaped # Part 2: Medium velocities (orbiting) velocities = [9000, 9100, 9200, 9300, 9400, 9500, 9600, 9700, 9800, 9900, 10000] # m/s plt.figure(figsize=(8,8)) theta = np.linspace(0, 2*np.pi, 100) # plt.fill(R_earth*np.cos(theta), R_earth*np.sin(theta), color='lightblue', label='Earth') plt.fill(R_earth*np.cos(theta)/1000, R_earth*np.sin(theta)/1000, color='lightblue', label='Earth') plt.plot(0, 0, 'oy', label='Center of Earth') for v0 in velocities: traj, r_min, r_max, escaped = simulate_orbit(v0) x, y = traj[:,0], traj[:,1] # plt.plot(x, y, label=f'{v0/1000:.1f} km/s') plt.plot(x/1000, y/1000, label=f'{v0/1000:.1f} km/s') print(f\"v0={v0/1000:.1f} km/s | Perigee: {r_min/1000:.1f} km | Apogee: {r_max/1000:.1f} km | Escaped: {escaped}\") plt.title('Medium Velocities: Circular/Elliptical Orbits') plt.xlabel('x [km]') plt.ylabel('y [km]') plt.legend() plt.grid() plt.axis('equal') plt.show() 5.3 Escape Trajectories import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M_earth = 5.972e24 R_earth = 6.371e6 # Simulation function def simulate_orbit(v0, steps=100000, dt=1): r0 = R_earth + 1_000_000 # 1000 km above surface x, y = r0, 0 vx, vy = 0, v0 pos = [] r_min, r_max = float('inf'), 0 escaped = False for _ in range(steps): r = np.sqrt(x**2 + y**2) if r < R_earth: break pos.append((x, y)) a = -G * M_earth / r**2 ax = a * x / r ay = a * y / r vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt r_min = min(r_min, r) r_max = max(r_max, r) if r > 20 * R_earth: escaped = True break return np.array(pos), r_min, r_max, escaped # Part 3: High velocities (escape trajectories) velocities = [11000, 12000, 13000, 14000, 15000, 16000, 17000, 18000, 19000, 20000] # m/s plt.figure(figsize=(8,8)) theta = np.linspace(0, 2*np.pi, 100) # plt.fill(R_earth*np.cos(theta), R_earth*np.sin(theta), color='lightblue', label='Earth') plt.fill(R_earth*np.cos(theta)/1000, R_earth*np.sin(theta)/1000, color='lightblue', label='Earth') plt.plot(0, 0, 'oy', label='Center of Earth') for v0 in velocities: traj, r_min, r_max, escaped = simulate_orbit(v0) x, y = traj[:,0], traj[:,1] # plt.plot(x, y, label=f'{v0/1000:.1f} km/s') plt.plot(x/1000, y/1000, label=f'{v0/1000:.1f} km/s') print(f\"v0={v0/1000:.1f} km/s | Perigee: {r_min/1000:.1f} km | Apogee: {r_max/1000:.1f} km | Escaped: {escaped}\") plt.title('High Velocities: Escape Trajectories') plt.xlabel('x [km]') plt.ylabel('y [km]') plt.legend() plt.grid() plt.axis('equal') plt.show() 5.4 3D View from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(figsize=(10, 8)) ax = fig.add_subplot(111, projection='3d') ax.plot(x/1000, y/1000, np.zeros_like(x), label='Payload Trajectory') ax.scatter(0, 0, 0, color='blue', s=500, label='Earth') ax.set_xlabel('x (km)') ax.set_ylabel('y (km)') ax.set_zlabel('z (km)') ax.set_title('3D Trajectory Plot (Flat Plane)') ax.legend() plt.show() 5.5 Colab Souce Code 6. Discussion and Interpretation The trajectory of a payload released near Earth is determined primarily by its initial speed relative to the local horizontal direction. Different regimes of initial speed result in fundamentally different behaviors, each with important implications for space missions and engineering. 6.1 Physical Behavior at Different Initial Speeds 1. Below Orbital Speed If the initial speed \\(v_0\\) is less than the required orbital speed \\(v_{\\text{circ}}\\) , the payload does not achieve a stable orbit. Instead, gravitational attraction dominates and the payload: Follows a suborbital or ballistic trajectory, Ascends to a maximum altitude and then falls back toward Earth, Example: Suborbital flights like early test rockets or ballistic missile paths. Mathematically: \\[ v_0 < \\sqrt{\\frac{\\mu}{r_0}} \\] where: - \\(\\mu\\) is the Earth's gravitational parameter, - \\(r_0\\) is the initial distance from Earth's center. 2. At Orbital Speed If \\(v_0\\) is equal to the circular orbital speed: \\[ v_0 = \\sqrt{\\frac{\\mu}{r_0}} \\] then the payload enters a circular orbit around Earth, maintaining a constant altitude. If the launch is at a different angle or slightly different magnitude, the payload can enter an elliptical orbit instead, characterized by varying altitude between perigee (closest approach) and apogee (farthest point). Characteristics: - Circular orbit : constant radius \\(r\\) . - Elliptical orbit : varying radius, energy still negative ( \\(\\varepsilon < 0\\) ). 3. Above Escape Speed If the initial speed \\(v_0\\) exceeds the escape velocity \\(v_{\\text{esc}}\\) , the payload overcomes Earth's gravitational binding energy. Escape velocity: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2\\mu}{r_0}} \\] Two cases arise: - Exactly at escape velocity : - The payload follows a parabolic trajectory ( \\(\\varepsilon = 0\\) ). - It barely escapes, reaching infinite distance with zero residual velocity. Above escape velocity : The payload follows a hyperbolic trajectory ( \\(\\varepsilon > 0\\) ). It escapes Earth with surplus kinetic energy and continues moving indefinitely. 6.2 Real-World Applications Understanding the link between initial speed and trajectory is crucial in space engineering and operations: 1. Satellite Deployment Precise insertion into orbit requires achieving the correct orbital velocity. Slight deviations result in elliptical or unstable orbits. Low Earth Orbit (LEO) satellites typically require speeds around \\(7.8 \\, \\text{km/s}\\) at an altitude of about \\(300 \\, \\text{km}\\) . 2. Spacecraft Reentry Planning For reentry missions (e.g., returning astronauts or probes): Controlled reduction of orbital speed ensures the spacecraft descends safely. Reentry corridors must be carefully calculated to avoid burning up or bouncing off the atmosphere. 3. Space Escape Maneuvers Missions escaping Earth (e.g., missions to the Moon, Mars) must achieve escape velocity. Upper rocket stages are used to provide the additional speed required beyond orbital velocity. Example: Apollo missions required a Trans-Lunar Injection (TLI) maneuver to leave Earth's gravitational influence. 6.3 Summary The initial velocity of a released payload dictates whether it: - Falls back to Earth , - Enters stable orbit , - Escapes Earth's gravity . Mastering these relationships is fundamental for designing satellite deployments, planning space missions, and ensuring the success of reentry and escape trajectories. 7. Conclusion In this study, we explored the dynamics of payloads released near Earth under the influence of gravitational forces. Through theoretical analysis, numerical simulations, and visualizations, we classified possible trajectories into ballistic, orbital, and escape paths. The results underscore the critical dependence of trajectory type on initial velocity magnitude and direction. These findings have direct applications in satellite deployment, reentry planning, and interplanetary mission design, highlighting the importance of precise velocity control in space operations.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"Trajectories of a Freely Released Payload Near Earth","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-physics-and-mathematical-foundations","text":"","title":"1. Physics and Mathematical Foundations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#11-newtons-law-of-gravitation","text":"Newton\u2019s Law of Gravitation states that every mass attracts every other mass with a force \\(F\\) given by: \\[ F = G \\frac{m_1 m_2}{r^2} \\] where: - \\(F\\) is the gravitational force, - \\(G\\) is the gravitational constant ( \\(G \\approx 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ), - \\(m_1\\) and \\(m_2\\) are the masses of the two objects, - \\(r\\) is the distance between the centers of the two masses. The gravitational force acts along the line joining the two masses.","title":"1.1 Newton\u2019s Law of Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#12-newtons-second-law-applied-to-gravity","text":"Newton's Second Law states that the force on an object is proportional to its acceleration: \\[ \\vec{F} = m \\vec{a} \\] Applying this to gravitational force: \\[ m \\vec{a} = -G \\frac{M m}{r^2} \\hat{r} \\] Simplifying: \\[ \\vec{a} = -G \\frac{M}{r^2} \\hat{r} \\] where: - \\(\\vec{a}\\) is the acceleration vector, - \\(M\\) is the mass of the Earth, - \\(\\hat{r}\\) is the unit vector pointing from the payload to the Earth's center. This acceleration governs the motion of a freely falling payload near Earth.","title":"1.2 Newton\u2019s Second Law Applied to Gravity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#13-conic-sections-and-trajectory-classification","text":"The path followed by the payload is a conic section determined by the total specific mechanical energy \\(\\varepsilon\\) : \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] where: - \\(v\\) is the magnitude of velocity, - \\(r\\) is the radial distance from Earth's center. The type of trajectory depends on \\(\\varepsilon\\) : - If \\(\\varepsilon < 0\\) , the trajectory is elliptical (bound orbit). - If \\(\\varepsilon = 0\\) , the trajectory is parabolic (escape at exactly escape velocity). - If \\(\\varepsilon > 0\\) , the trajectory is hyperbolic (escape with surplus energy). The general equation for conic sections in polar coordinates: \\[ r(\\theta) = \\frac{p}{1 + e \\cos(\\theta)} \\] where: - \\(p\\) is the semi-latus rectum, - \\(e\\) is the eccentricity: - \\(0 \\leq e < 1\\) for an ellipse, - \\(e = 1\\) for a parabola, - \\(e > 1\\) for a hyperbola.","title":"1.3 Conic Sections and Trajectory Classification"},{"location":"1%20Physics/2%20Gravity/Problem_3/#14-orbital-energy-specific-mechanical-energy","text":"Specific mechanical energy \\(\\varepsilon\\) combines kinetic and potential energy per unit mass: \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] where: - Positive \\(\\varepsilon\\) implies unbound (hyperbolic) motion, - Zero \\(\\varepsilon\\) corresponds to parabolic escape, - Negative \\(\\varepsilon\\) indicates a bound (elliptical) orbit. The escape velocity \\(v_{\\text{esc}}\\) is derived by setting \\(\\varepsilon = 0\\) : \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] Thus, if the initial velocity \\(v > v_{\\text{esc}}\\) , the payload will escape Earth\u2019s gravity.","title":"1.4 Orbital Energy (Specific Mechanical Energy)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#15-keplers-laws-of-planetary-motion","text":"First Law (Law of Ellipses) : Every orbit of a planet or object is an ellipse with the center of mass at one of the two foci. Second Law (Law of Equal Areas) : A line joining a planet and the Sun sweeps out equal areas during equal intervals of time. Mathematically: $$ \\frac{dA}{dt} = \\text{constant} $$ where \\(A\\) is the area swept out. Third Law (Law of Harmonies) : The square of the orbital period \\(T\\) is proportional to the cube of the semi-major axis \\(a\\) : $$ T^2 \\propto a^3 $$ or more precisely: $$ T^2 = \\frac{4\\pi^2}{GM} a^3 $$ These laws govern the orbital behavior of payloads near Earth and help predict future positions and velocities.","title":"1.5 Kepler\u2019s Laws of Planetary Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-identify-and-define-initial-conditions","text":"To model and simulate the trajectory of a payload released near Earth, it is essential to specify the initial conditions precisely. These parameters determine the entire motion under gravitational forces.","title":"2. Identify and Define Initial Conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#21-initial-position-vector-relative-to-earths-center","text":"The initial position \\(\\vec{r}_0\\) of the payload is given relative to the center of Earth: \\[ \\vec{r}_0 = (x_0, y_0, z_0) \\] where: - \\(x_0\\) , \\(y_0\\) , and \\(z_0\\) are the Cartesian coordinates of the payload in an inertial reference frame, - Alternatively, the position can be expressed in polar coordinates \\((r_0, \\theta_0, \\phi_0)\\) : - \\(r_0\\) is the radial distance from Earth's center, - \\(\\theta_0\\) is the azimuthal angle (longitude), - \\(\\phi_0\\) is the polar angle (colatitude). For many problems, assuming motion in a plane (e.g., equatorial plane) simplifies calculations by setting \\(z_0 = 0\\) .","title":"2.1 Initial Position (Vector Relative to Earth\u2019s Center)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#22-initial-velocity-vector-at-release","text":"The initial velocity \\(\\vec{v}_0\\) of the payload must be defined with both magnitude and direction: \\[ \\vec{v}_0 = (v_{x,0}, v_{y,0}, v_{z,0}) \\] or alternatively in polar terms: \\[ \\vec{v}_0 = v_{r,0} \\hat{r} + v_{\\theta,0} \\hat{\\theta} \\] where: - \\(v_{r,0}\\) is the radial component (along \\(\\hat{r}\\) ), - \\(v_{\\theta,0}\\) is the transverse component (perpendicular to \\(\\hat{r}\\) in the orbital plane). The initial velocity vector relative to the local horizontal critically determines the type of trajectory: - Purely radial launch ( \\(v_{\\theta,0} = 0\\) ) results in a straight path, - Purely tangential launch ( \\(v_{r,0} = 0\\) ) can lead to circular or elliptical orbits, - Mixed radial and tangential velocities create general elliptical, hyperbolic, or parabolic paths.","title":"2.2 Initial Velocity (Vector at Release)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#23-initial-altitude-above-earths-surface","text":"The altitude \\(h_0\\) is the height of the payload above the Earth's surface: \\[ h_0 = r_0 - R_E \\] where: - \\(r_0\\) is the distance from the Earth's center, - \\(R_E\\) is the radius of the Earth ( \\(R_E \\approx 6371 \\, \\text{km}\\) ). The altitude is crucial because it influences the local gravitational force magnitude. The local gravitational acceleration \\(g(h)\\) at altitude \\(h\\) is given by: \\[ g(h) = \\frac{GM}{(R_E + h)^2} \\]","title":"2.3 Initial Altitude Above Earth\u2019s Surface"},{"location":"1%20Physics/2%20Gravity/Problem_3/#24-gravitational-parameter-of-earth-gm-value","text":"The gravitational parameter \\(\\mu\\) (also called standard gravitational parameter) is defined as: \\[ \\mu = GM \\] where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the Earth. Numerically: \\[ \\mu \\approx 3.986 \\times 10^{14} \\, \\text{m}^3 \\, \\text{s}^{-2} \\] Using \\(\\mu\\) simplifies many orbital mechanics equations, for instance: Specific mechanical energy: \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{\\mu}{r} \\] Orbital velocity at a distance \\(r\\) for circular orbit: \\[ v_{\\text{circ}} = \\sqrt{\\frac{\\mu}{r}} \\] Escape velocity from distance \\(r\\) : \\[ v_{\\text{esc}} = \\sqrt{\\frac{2\\mu}{r}} \\] Knowledge of \\(\\mu\\) enables precise calculations of the payload\u2019s motion and trajectory classification.","title":"2.4 Gravitational Parameter of Earth (GM Value)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-trajectory-analysis","text":"Understanding the trajectory of a payload released near Earth involves deriving its equations of motion under gravitational forces, analyzing specific orbital energy, and considering the influence of initial velocity magnitude and direction.","title":"3. Trajectory Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_3/#31-equations-of-motion-second-order-differential-equations","text":"The motion of a payload under Earth's gravity is governed by Newton\u2019s Second Law: \\[ \\vec{F} = m \\vec{a} \\] Substituting the gravitational force: \\[ m \\vec{a} = -G \\frac{Mm}{r^2} \\hat{r} \\] Simplifying: \\[ \\vec{a} = -\\frac{\\mu}{r^2} \\hat{r} \\] where \\(\\mu = GM\\) is the standard gravitational parameter. In Cartesian coordinates \\((x, y, z)\\) , the second-order differential equations of motion are: \\[ \\ddot{x} = -\\frac{\\mu x}{(x^2 + y^2 + z^2)^{3/2}} \\] \\[ \\ddot{y} = -\\frac{\\mu y}{(x^2 + y^2 + z^2)^{3/2}} \\] \\[ \\ddot{z} = -\\frac{\\mu z}{(x^2 + y^2 + z^2)^{3/2}} \\] where \\(\\ddot{x}\\) , \\(\\ddot{y}\\) , and \\(\\ddot{z}\\) are the second derivatives of position with respect to time (accelerations). These equations describe the continuous motion of the payload influenced solely by Earth's gravitational field.","title":"3.1 Equations of Motion (Second-Order Differential Equations)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#32-specific-orbital-energy-and-trajectory-classification","text":"The specific mechanical energy \\(\\varepsilon\\) is the sum of the specific kinetic and specific potential energies: \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{\\mu}{r} \\] where: - \\(v\\) is the magnitude of the velocity vector, - \\(r\\) is the radial distance from Earth's center. Classification based on \\(\\varepsilon\\) : - Elliptical Orbit (Bound) : $$ \\varepsilon < 0 $$ The payload remains gravitationally bound to Earth, following a closed, elliptical path. Parabolic Trajectory (Escape at Minimum Energy) : $$ \\varepsilon = 0 $$ The payload reaches exactly escape velocity and follows a parabolic trajectory, escaping Earth's gravity without excess energy. Hyperbolic Trajectory (Escape with Excess Energy) : $$ \\varepsilon > 0 $$ The payload escapes Earth's gravity with surplus kinetic energy, following an open hyperbolic path.","title":"3.2 Specific Orbital Energy and Trajectory Classification"},{"location":"1%20Physics/2%20Gravity/Problem_3/#33-effect-of-initial-velocity-direction-and-magnitude","text":"The initial velocity \\(\\vec{v}_0\\) relative to the local horizontal plane significantly influences the resulting trajectory: Purely Horizontal Launch : When the velocity is tangential to the surface (local horizontal), Enables orbital motion (circular or elliptical) if the speed is appropriate. Purely Radial Launch : When the velocity is directed straight outward or inward, Leads to vertical ascent or descent, If \\(v_0 \\geq v_{\\text{esc}}\\) , the object escapes along a parabolic or hyperbolic path. Mixed Direction Launch : A combination of radial and tangential components, Creates general elliptical or hyperbolic trajectories, The trajectory\u2019s shape and energy depend on the proportion of radial versus tangential velocity components.","title":"3.3 Effect of Initial Velocity Direction and Magnitude"},{"location":"1%20Physics/2%20Gravity/Problem_3/#decomposition-of-initial-velocity","text":"Given an angle \\(\\alpha\\) between the initial velocity vector and the local horizontal: \\[ v_{r,0} = v_0 \\sin(\\alpha) \\] \\[ v_{\\theta,0} = v_0 \\cos(\\alpha) \\] where: - \\(v_{r,0}\\) is the initial radial velocity component, - \\(v_{\\theta,0}\\) is the initial tangential (horizontal) velocity component. The effective orbital behavior thus depends on both the magnitude and the angle of the initial velocity.","title":"Decomposition of Initial Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#34-summary","text":"Accurately setting up the equations of motion and understanding specific orbital energy are fundamental for classifying the payload\u2019s trajectory after release. The initial velocity vector\u2019s magnitude and direction relative to the local horizontal critically determine whether the payload will: - Remain in orbit, - Fall back to Earth, - Escape Earth's gravitational influence entirely.","title":"3.4 Summary"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-numerical-simulation-setup","text":"Numerical simulations are essential for modeling the trajectory of a payload released near Earth. Due to the nonlinear nature of gravitational acceleration, analytical solutions are often impractical for general initial conditions, necessitating the use of numerical integration techniques.","title":"4. Numerical Simulation Setup"},{"location":"1%20Physics/2%20Gravity/Problem_3/#41-choosing-a-numerical-integration-method","text":"The equations of motion derived earlier form a system of second-order ordinary differential equations (ODEs). To solve them numerically, it is standard practice to transform them into a system of first-order ODEs by introducing velocity components as independent variables. Let: \\[ \\vec{r} = (x, y, z), \\quad \\vec{v} = (\\dot{x}, \\dot{y}, \\dot{z}) \\] Then the system becomes: \\[ \\dot{\\vec{r}} = \\vec{v} \\] \\[ \\dot{\\vec{v}} = -\\frac{\\mu}{r^3} \\vec{r} \\] where \\(r = \\|\\vec{r}\\|\\) .","title":"4.1 Choosing a Numerical Integration Method"},{"location":"1%20Physics/2%20Gravity/Problem_3/#recommended-numerical-methods","text":"Euler's Method (First-order accuracy): Simple but prone to large errors over time. Only suitable for very small time steps. Runge-Kutta Methods : Runge-Kutta 2nd Order (RK2) : Moderate accuracy, relatively easy to implement. Runge-Kutta 4th Order (RK4) : High accuracy, widely used for orbit simulations. Runge-Kutta 4th Order (RK4) algorithm for advancing from \\(t_n\\) to \\(t_{n+1} = t_n + \\Delta t\\) : \\[ \\begin{aligned} k_1 &= f(t_n, y_n) \\\\ k_2 &= f\\left(t_n + \\frac{\\Delta t}{2}, y_n + \\frac{\\Delta t}{2}k_1\\right) \\\\ k_3 &= f\\left(t_n + \\frac{\\Delta t}{2}, y_n + \\frac{\\Delta t}{2}k_2\\right) \\\\ k_4 &= f\\left(t_n + \\Delta t, y_n + \\Delta t \\, k_3\\right) \\\\ y_{n+1} &= y_n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4) \\end{aligned} \\] where \\(y\\) represents the state vector containing both \\(\\vec{r}\\) and \\(\\vec{v}\\) .","title":"Recommended Numerical Methods:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#42-time-stepping-and-tolerances-for-numerical-accuracy","text":"The choice of time step \\(\\Delta t\\) is crucial: - If \\(\\Delta t\\) is too large, the simulation will suffer from significant numerical errors (e.g., energy drift). - If \\(\\Delta t\\) is too small, the simulation will be accurate but computationally expensive. Typical considerations: - Adaptive time-stepping can be employed, adjusting \\(\\Delta t\\) based on local truncation error estimates. - Otherwise, use a fixed \\(\\Delta t\\) small enough to accurately resolve the motion: Rule of thumb: \\(\\Delta t\\) should be at least \\(1000\\) times smaller than the orbital period for stable simulations. Tolerance settings (if using adaptive methods like Runge-Kutta-Fehlberg): - Relative Tolerance \\(\\sim 10^{-9}\\) - Absolute Tolerance \\(\\sim 10^{-12}\\) Maintaining energy conservation can serve as a good diagnostic for checking numerical accuracy.","title":"4.2 Time-Stepping and Tolerances for Numerical Accuracy"},{"location":"1%20Physics/2%20Gravity/Problem_3/#43-simplifications-accounting-only-for-earths-gravity","text":"In this model: - Only central gravitational force from Earth is considered. - Atmospheric drag , solar radiation pressure , third-body effects (e.g., Moon, Sun) are ignored unless specified otherwise. The governing acceleration thus remains: \\[ \\vec{a} = -\\frac{\\mu}{r^3} \\vec{r} \\] Assumptions: - Earth is treated as a perfect sphere. - Earth's rotation effects (like Coriolis or centrifugal forces) are neglected unless explicitly modeled in a rotating reference frame. - No oblateness (no \\(J_2\\) perturbation). This simplifies the dynamics to a classic two-body problem under Newtonian gravity.","title":"4.3 Simplifications: Accounting Only for Earth's Gravity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#44-summary","text":"For accurate simulation of a payload\u2019s trajectory near Earth: - Use Runge-Kutta 4th order method for numerical integration. - Choose appropriate time step sizes and consider adaptive time-stepping for high accuracy. - Focus solely on Earth\u2019s gravitational attraction unless additional forces are explicitly required. Proper numerical setup ensures reliable, physically consistent simulations essential for analyzing orbital dynamics.","title":"4.4 Summary"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-computational-tool-and-visualization","text":"Calculate \\(v_{\\text{circ}}\\) and \\(v_{\\text{esc}}\\) for 1000 km altitude once and print/display them: r0 = R_earth + 1_000_000 # 1000 km altitude v_circ = np.sqrt(G*M_earth/r0) v_esc = np.sqrt(2*G*M_earth/r0) print(f\"Circular orbital velocity at 1000 km: {v_circ/1000:.2f} km/s\") print(f\"Escape velocity at 1000 km: {v_esc/1000:.2f} km/s\")","title":"5. Computational Tool and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_3/#51-crashing-or-suborbital-trajectories","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M_earth = 5.972e24 R_earth = 6.371e6 # Simulation function def simulate_orbit(v0, steps=100000, dt=1): r0 = R_earth + 1_000_000 # 1000 km above surface x, y = r0, 0 vx, vy = 0, v0 pos = [] r_min, r_max = float('inf'), 0 escaped = False for _ in range(steps): r = np.sqrt(x**2 + y**2) if r < R_earth: break pos.append((x, y)) a = -G * M_earth / r**2 ax = a * x / r ay = a * y / r vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt r_min = min(r_min, r) r_max = max(r_max, r) if r > 20 * R_earth: escaped = True break return np.array(pos), r_min, r_max, escaped # Part 1: Low velocities (crash back) velocities = [4000, 5000, 6000, 7000, 8000] # m/s plt.figure(figsize=(8,8)) theta = np.linspace(0, 2*np.pi, 100) # plt.fill(R_earth*np.cos(theta), R_earth*np.sin(theta), color='lightblue', label='Earth') plt.fill(R_earth*np.cos(theta)/1000, R_earth*np.sin(theta)/1000, color='lightblue', label='Earth') plt.plot(0, 0, 'oy', label='Center of Earth') for v0 in velocities: traj, r_min, r_max, escaped = simulate_orbit(v0) x, y = traj[:,0], traj[:,1] # plt.plot(x, y, label=f'{v0/1000:.1f} km/s') plt.plot(x/1000, y/1000, label=f'{v0/1000:.1f} km/s') print(f\"v0={v0/1000:.1f} km/s | Perigee: {r_min/1000:.1f} km | Apogee: {r_max/1000:.1f} km | Escaped: {escaped}\") plt.title('Low Velocities: Crashing/Short Trajectories') plt.xlabel('x [km]') plt.ylabel('y [km]') plt.legend() plt.grid() plt.axis('equal') plt.show()","title":"5.1 Crashing or Suborbital Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#52-circular-and-elliptical-orbits-bounded","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M_earth = 5.972e24 R_earth = 6.371e6 # Simulation function def simulate_orbit(v0, steps=100000, dt=1): r0 = R_earth + 1_000_000 # 1000 km above surface x, y = r0, 0 vx, vy = 0, v0 pos = [] r_min, r_max = float('inf'), 0 escaped = False for _ in range(steps): r = np.sqrt(x**2 + y**2) if r < R_earth: break pos.append((x, y)) a = -G * M_earth / r**2 ax = a * x / r ay = a * y / r vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt r_min = min(r_min, r) r_max = max(r_max, r) if r > 20 * R_earth: escaped = True break return np.array(pos), r_min, r_max, escaped # Part 2: Medium velocities (orbiting) velocities = [9000, 9100, 9200, 9300, 9400, 9500, 9600, 9700, 9800, 9900, 10000] # m/s plt.figure(figsize=(8,8)) theta = np.linspace(0, 2*np.pi, 100) # plt.fill(R_earth*np.cos(theta), R_earth*np.sin(theta), color='lightblue', label='Earth') plt.fill(R_earth*np.cos(theta)/1000, R_earth*np.sin(theta)/1000, color='lightblue', label='Earth') plt.plot(0, 0, 'oy', label='Center of Earth') for v0 in velocities: traj, r_min, r_max, escaped = simulate_orbit(v0) x, y = traj[:,0], traj[:,1] # plt.plot(x, y, label=f'{v0/1000:.1f} km/s') plt.plot(x/1000, y/1000, label=f'{v0/1000:.1f} km/s') print(f\"v0={v0/1000:.1f} km/s | Perigee: {r_min/1000:.1f} km | Apogee: {r_max/1000:.1f} km | Escaped: {escaped}\") plt.title('Medium Velocities: Circular/Elliptical Orbits') plt.xlabel('x [km]') plt.ylabel('y [km]') plt.legend() plt.grid() plt.axis('equal') plt.show()","title":"5.2 Circular and Elliptical Orbits (Bounded)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#53-escape-trajectories","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M_earth = 5.972e24 R_earth = 6.371e6 # Simulation function def simulate_orbit(v0, steps=100000, dt=1): r0 = R_earth + 1_000_000 # 1000 km above surface x, y = r0, 0 vx, vy = 0, v0 pos = [] r_min, r_max = float('inf'), 0 escaped = False for _ in range(steps): r = np.sqrt(x**2 + y**2) if r < R_earth: break pos.append((x, y)) a = -G * M_earth / r**2 ax = a * x / r ay = a * y / r vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt r_min = min(r_min, r) r_max = max(r_max, r) if r > 20 * R_earth: escaped = True break return np.array(pos), r_min, r_max, escaped # Part 3: High velocities (escape trajectories) velocities = [11000, 12000, 13000, 14000, 15000, 16000, 17000, 18000, 19000, 20000] # m/s plt.figure(figsize=(8,8)) theta = np.linspace(0, 2*np.pi, 100) # plt.fill(R_earth*np.cos(theta), R_earth*np.sin(theta), color='lightblue', label='Earth') plt.fill(R_earth*np.cos(theta)/1000, R_earth*np.sin(theta)/1000, color='lightblue', label='Earth') plt.plot(0, 0, 'oy', label='Center of Earth') for v0 in velocities: traj, r_min, r_max, escaped = simulate_orbit(v0) x, y = traj[:,0], traj[:,1] # plt.plot(x, y, label=f'{v0/1000:.1f} km/s') plt.plot(x/1000, y/1000, label=f'{v0/1000:.1f} km/s') print(f\"v0={v0/1000:.1f} km/s | Perigee: {r_min/1000:.1f} km | Apogee: {r_max/1000:.1f} km | Escaped: {escaped}\") plt.title('High Velocities: Escape Trajectories') plt.xlabel('x [km]') plt.ylabel('y [km]') plt.legend() plt.grid() plt.axis('equal') plt.show()","title":"5.3 Escape Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#54-3d-view","text":"from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(figsize=(10, 8)) ax = fig.add_subplot(111, projection='3d') ax.plot(x/1000, y/1000, np.zeros_like(x), label='Payload Trajectory') ax.scatter(0, 0, 0, color='blue', s=500, label='Earth') ax.set_xlabel('x (km)') ax.set_ylabel('y (km)') ax.set_zlabel('z (km)') ax.set_title('3D Trajectory Plot (Flat Plane)') ax.legend() plt.show()","title":"5.4 3D View"},{"location":"1%20Physics/2%20Gravity/Problem_3/#55-colab","text":"Souce Code","title":"5.5 Colab"},{"location":"1%20Physics/2%20Gravity/Problem_3/#6-discussion-and-interpretation","text":"The trajectory of a payload released near Earth is determined primarily by its initial speed relative to the local horizontal direction. Different regimes of initial speed result in fundamentally different behaviors, each with important implications for space missions and engineering.","title":"6. Discussion and Interpretation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#61-physical-behavior-at-different-initial-speeds","text":"","title":"6.1 Physical Behavior at Different Initial Speeds"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-below-orbital-speed","text":"If the initial speed \\(v_0\\) is less than the required orbital speed \\(v_{\\text{circ}}\\) , the payload does not achieve a stable orbit. Instead, gravitational attraction dominates and the payload: Follows a suborbital or ballistic trajectory, Ascends to a maximum altitude and then falls back toward Earth, Example: Suborbital flights like early test rockets or ballistic missile paths. Mathematically: \\[ v_0 < \\sqrt{\\frac{\\mu}{r_0}} \\] where: - \\(\\mu\\) is the Earth's gravitational parameter, - \\(r_0\\) is the initial distance from Earth's center.","title":"1. Below Orbital Speed"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-at-orbital-speed","text":"If \\(v_0\\) is equal to the circular orbital speed: \\[ v_0 = \\sqrt{\\frac{\\mu}{r_0}} \\] then the payload enters a circular orbit around Earth, maintaining a constant altitude. If the launch is at a different angle or slightly different magnitude, the payload can enter an elliptical orbit instead, characterized by varying altitude between perigee (closest approach) and apogee (farthest point). Characteristics: - Circular orbit : constant radius \\(r\\) . - Elliptical orbit : varying radius, energy still negative ( \\(\\varepsilon < 0\\) ).","title":"2. At Orbital Speed"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-above-escape-speed","text":"If the initial speed \\(v_0\\) exceeds the escape velocity \\(v_{\\text{esc}}\\) , the payload overcomes Earth's gravitational binding energy. Escape velocity: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2\\mu}{r_0}} \\] Two cases arise: - Exactly at escape velocity : - The payload follows a parabolic trajectory ( \\(\\varepsilon = 0\\) ). - It barely escapes, reaching infinite distance with zero residual velocity. Above escape velocity : The payload follows a hyperbolic trajectory ( \\(\\varepsilon > 0\\) ). It escapes Earth with surplus kinetic energy and continues moving indefinitely.","title":"3. Above Escape Speed"},{"location":"1%20Physics/2%20Gravity/Problem_3/#62-real-world-applications","text":"Understanding the link between initial speed and trajectory is crucial in space engineering and operations:","title":"6.2 Real-World Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-satellite-deployment","text":"Precise insertion into orbit requires achieving the correct orbital velocity. Slight deviations result in elliptical or unstable orbits. Low Earth Orbit (LEO) satellites typically require speeds around \\(7.8 \\, \\text{km/s}\\) at an altitude of about \\(300 \\, \\text{km}\\) .","title":"1. Satellite Deployment"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-spacecraft-reentry-planning","text":"For reentry missions (e.g., returning astronauts or probes): Controlled reduction of orbital speed ensures the spacecraft descends safely. Reentry corridors must be carefully calculated to avoid burning up or bouncing off the atmosphere.","title":"2. Spacecraft Reentry Planning"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-space-escape-maneuvers","text":"Missions escaping Earth (e.g., missions to the Moon, Mars) must achieve escape velocity. Upper rocket stages are used to provide the additional speed required beyond orbital velocity. Example: Apollo missions required a Trans-Lunar Injection (TLI) maneuver to leave Earth's gravitational influence.","title":"3. Space Escape Maneuvers"},{"location":"1%20Physics/2%20Gravity/Problem_3/#63-summary","text":"The initial velocity of a released payload dictates whether it: - Falls back to Earth , - Enters stable orbit , - Escapes Earth's gravity . Mastering these relationships is fundamental for designing satellite deployments, planning space missions, and ensuring the success of reentry and escape trajectories.","title":"6.3 Summary"},{"location":"1%20Physics/2%20Gravity/Problem_3/#7-conclusion","text":"In this study, we explored the dynamics of payloads released near Earth under the influence of gravitational forces. Through theoretical analysis, numerical simulations, and visualizations, we classified possible trajectories into ballistic, orbital, and escape paths. The results underscore the critical dependence of trajectory type on initial velocity magnitude and direction. These findings have direct applications in satellite deployment, reentry planning, and interplanetary mission design, highlighting the importance of precise velocity control in space operations.","title":"7. Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a water surface 1. Geometry Setup To study interference patterns, we start by placing point sources at the vertices of a regular polygon. 1.1 Regular Polygon A regular polygon has equal sides and angles. Let the number of sources be: $$ N \\geq 3 $$ 1.2 Vertex Coordinates Assume the polygon is inscribed in a circle centered at the origin with radius \\(R\\) . The angle between adjacent vertices is: $$ \\Delta \\theta = \\frac{2\\pi}{N}, \\quad \\theta_i = i \\Delta \\theta $$ Coordinates of the \\(i\\) -th vertex: $$ x_{0i} = R \\cos(\\theta_i), \\quad y_{0i} = R \\sin(\\theta_i) $$ 1.3 Choosing Radius \\(R\\) Radius \\(R\\) determines source spacing and pattern scale. A chord length of: $$ d = 2R \\sin\\left(\\frac{\\pi}{N}\\right) $$ Choosing \\(d \\sim (2-5) \\lambda\\) gives rich interference. 2. Wave Definition Each source emits a circular wave described by: $$ \\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t + \\phi) $$ Where \\(r_i = \\sqrt{(x - x_{0i})^2 + (y - y_{0i})^2}\\) is the distance from source \\(i\\) to point \\((x, y)\\) . Common assumptions: - All sources have same \\(A, k, \\omega, \\phi\\) . - Initial phase \\(\\phi = 0\\) . - Non-dispersive medium. 3. Superposition Principle Total displacement: $$ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t + \\phi) $$ Interference Conditions Constructive : \\(k(r_i - r_j) = 2n\\pi\\) Destructive : \\(k(r_i - r_j) = (2n + 1)\\pi\\) Patterns arise from the geometry and wave interactions. 4. Wave Parameters Amplitude ( \\(A\\) ) : maximum surface displacement. Wavelength ( \\(\\lambda\\) ) : defines wave number \\(k = 2\\pi/\\lambda\\) . Frequency ( \\(f\\) ) : defines \\(\\omega = 2\\pi f\\) . Phase ( \\(\\phi\\) ) : typically zero for all sources. These define wave behavior and interference scale. 5. Simulation Grid 5.1 Domain Choose spatial domain \\([x_{\\min}, x_{\\max}], [y_{\\min}, y_{\\max}]\\) large enough to capture wave effects: $$ (x_{\\max} - x_{\\min}) \\gtrsim 6\\lambda, \\quad (y_{\\max} - y_{\\min}) \\gtrsim 6\\lambda $$ 5.2 Resolution Grid spacing: $$ \\Delta x, \\Delta y \\leq \\frac{\\lambda}{10} $$ Construct grid using meshgrid in Python. 5.3 Boundary Effects Keep sources away from edges. Use absorbing or periodic boundaries as needed. 6. Time Component Each wave evolves in time: $$ \\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t + \\phi) $$ Visualization Modes Snapshot : Fixed \\(t = t_0\\) . Shows static interference. Animation : Vary \\(t\\) over interval with step \\(\\Delta t \\leq 1/(20f)\\) . Use animations or contour plots to show dynamics. 7. Visualization 7.1 Single Source \u2013 Static Wavefronts import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Wave parameters A = 1 lambda_ = 1 k = 2 * np.pi / lambda_ f = 1 omega = 2 * np.pi * f phi = 0 # Grid x = np.linspace(-5, 5, 400) y = np.linspace(-5, 5, 400) X, Y = np.meshgrid(x, y) r = np.sqrt((X - 0)**2 + (Y - 0)**2) # Setup plot fig, ax = plt.subplots() img = ax.imshow(np.zeros_like(X), extent=[-5, 5, -5, 5], cmap='viridis', origin='lower') plt.colorbar(img, ax=ax) ax.set_title(\"Single Source Wavefronts\") # Animation function def update(frame): t = frame / 20 eta = A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) img.set_data(eta) return [img] ani = animation.FuncAnimation(fig, update, frames=100, interval=50, blit=True) ani.save(\"single_source.gif\", writer=\"pillow\") plt.close() import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation # Parameters A = 1 lambda_ = 1 k = 2 * np.pi / lambda_ f = 1 omega = 2 * np.pi * f phi = 0 # Grid x = np.linspace(-5, 5, 150) y = np.linspace(-5, 5, 150) X, Y = np.meshgrid(x, y) r = np.sqrt((X - 0)**2 + (Y - 0)**2) # Setup plot fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') # Initialize the surface plot surf = ax.plot_surface(X, Y, np.zeros_like(X), cmap='viridis', edgecolor='none') ax.set_zlim(-2, 2) ax.set_title(\"Single Source \u2013 3D Animated Surface\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"Displacement\") def update(frame): global surf # Make surf accessible within the function t = frame / 20 eta = A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) # Remove the previous surface plot surf.remove() # Plot the new surface surf = ax.plot_surface(X, Y, eta, cmap='viridis', edgecolor='none') return [surf] # Return the updated surface ani = FuncAnimation(fig, update, frames=60, interval=100, blit=False) # blit=False is recommended for 3D animations ani.save(\"single_source_3d.gif\", writer=\"pillow\") plt.close() 7.2 Two Sources \u2013 Interference Pattern import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Wave parameters A = 1 lambda_ = 1 k = 2 * np.pi / lambda_ f = 1 omega = 2 * np.pi * f phi = 0 # Grid x = np.linspace(-5, 5, 400) y = np.linspace(-5, 5, 400) X, Y = np.meshgrid(x, y) # Two sources sources = [(-1.5, 0), (1.5, 0)] # Setup plot fig, ax = plt.subplots() img = ax.imshow(np.zeros_like(X), extent=[-5, 5, -5, 5], cmap='plasma', origin='lower') plt.colorbar(img, ax=ax) ax.set_title(\"Two Source Interference\") def update(frame): t = frame / 20 eta_sum = np.zeros_like(X) for x0, y0 in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_sum += A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) img.set_data(eta_sum) return [img] ani = animation.FuncAnimation(fig, update, frames=100, interval=50, blit=True) ani.save(\"two_sources.gif\", writer=\"pillow\") plt.close() import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation # Parameters A = 1 lambda_ = 1 k = 2 * np.pi / lambda_ f = 1 omega = 2 * np.pi * f phi = 0 # Grid x = np.linspace(-5, 5, 150) y = np.linspace(-5, 5, 150) X, Y = np.meshgrid(x, y) # Two source coordinates sources = [(-1.5, 0), (1.5, 0)] fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.set_zlim(-3, 3) ax.set_title(\"Two Sources \u2013 3D Animated Surface\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"Displacement\") # Initialize the surface plot outside the update function surf = ax.plot_surface(X, Y, np.zeros_like(X), cmap='plasma', edgecolor='none') def update(frame): global surf # Make surf accessible within the function t = frame / 20 eta_sum = np.zeros_like(X) for x0, y0 in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_sum += A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) # Remove the previous surface plot surf.remove() # Plot the new surface surf = ax.plot_surface(X, Y, eta_sum, cmap='plasma', edgecolor='none') return [surf] # Return the updated surface ani = FuncAnimation(fig, update, frames=60, interval=100, blit=False) # blit=False is recommended for 3D animations ani.save(\"two_sources_3d.gif\", writer=\"pillow\") plt.close() 7.3 Three Sources \u2013 Interference from Triangle Configuration import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Wave parameters A = 1 lambda_ = 1 k = 2 * np.pi / lambda_ f = 1 omega = 2 * np.pi * f phi = 0 # Grid x = np.linspace(-5, 5, 400) y = np.linspace(-5, 5, 400) X, Y = np.meshgrid(x, y) # Triangle config R = 2 sources = [(R * np.cos(2*np.pi*i/3), R * np.sin(2*np.pi*i/3)) for i in range(3)] fig, ax = plt.subplots() img = ax.imshow(np.zeros_like(X), extent=[-5, 5, -5, 5], cmap='inferno', origin='lower') plt.colorbar(img, ax=ax) ax.set_title(\"Triangle Interference \u2013 Three Sources\") def update(frame): t = frame / 20 eta_sum = np.zeros_like(X) for x0, y0 in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_sum += A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) img.set_data(eta_sum) return [img] ani = animation.FuncAnimation(fig, update, frames=100, interval=50, blit=True) ani.save(\"three_sources.gif\", writer=\"pillow\") plt.close() import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation # Parameters A = 1 lambda_ = 1 k = 2 * np.pi / lambda_ f = 1 omega = 2 * np.pi * f phi = 0 # Grid x = np.linspace(-5, 5, 150) y = np.linspace(-5, 5, 150) X, Y = np.meshgrid(x, y) # Triangle configuration R = 2 sources = [(R * np.cos(2 * np.pi * i / 3), R * np.sin(2 * np.pi * i / 3)) for i in range(3)] fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.set_zlim(-3, 3) ax.set_title(\"Three Sources \u2013 3D Animated Surface\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"Displacement\") # Initialize surface plot surf = ax.plot_surface(X, Y, np.zeros_like(X), cmap='inferno', edgecolor='none') def update(frame): global surf # Make surf accessible within the function t = frame / 20 eta_sum = np.zeros_like(X) for x0, y0 in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_sum += A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) # Remove the previous surface plot surf.remove() # Plot the new surface surf = ax.plot_surface(X, Y, eta_sum, cmap='inferno', edgecolor='none') return [surf] ani = FuncAnimation(fig, update, frames=60, interval=100, blit=False) # blit=False is important for 3D animations ani.save(\"three_sources_3d.gif\", writer=\"pillow\") plt.close() Colab: Waves Problem 1 Souce Code 8. Analysis Analyzing the resulting interference pattern reveals regions of amplification and cancellation. 8.1 Constructive Interference Occurs when waves are in phase: $$ k(r_i - r_j) = 2\\pi n $$ Leads to high displacement regions (bright fringes or peaks). 8.2 Destructive Interference Occurs when waves are out of phase: $$ k(r_i - r_j) = (2n + 1)\\pi $$ Leads to wave cancellation (dark zones or troughs). 8.3 Pattern Symmetry Pattern symmetry follows the polygon's geometry: - Two sources: symmetry about midpoint. - Three (triangle): \\(120^\\circ\\) rotational symmetry. - Four or more: increasing complexity, matching polygonal symmetry. 8.4 Visual Cues Bright ridges = constructive zones Dark lines = destructive zones Radial or rotational motifs reflect geometric layout Contours or threshold filters can aid interpretation.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"Interference Patterns on a water surface","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-geometry-setup","text":"To study interference patterns, we start by placing point sources at the vertices of a regular polygon.","title":"1. Geometry Setup"},{"location":"1%20Physics/3%20Waves/Problem_1/#11-regular-polygon","text":"A regular polygon has equal sides and angles. Let the number of sources be: $$ N \\geq 3 $$","title":"1.1 Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#12-vertex-coordinates","text":"Assume the polygon is inscribed in a circle centered at the origin with radius \\(R\\) . The angle between adjacent vertices is: $$ \\Delta \\theta = \\frac{2\\pi}{N}, \\quad \\theta_i = i \\Delta \\theta $$ Coordinates of the \\(i\\) -th vertex: $$ x_{0i} = R \\cos(\\theta_i), \\quad y_{0i} = R \\sin(\\theta_i) $$","title":"1.2 Vertex Coordinates"},{"location":"1%20Physics/3%20Waves/Problem_1/#13-choosing-radius-r","text":"Radius \\(R\\) determines source spacing and pattern scale. A chord length of: $$ d = 2R \\sin\\left(\\frac{\\pi}{N}\\right) $$ Choosing \\(d \\sim (2-5) \\lambda\\) gives rich interference.","title":"1.3 Choosing Radius \\(R\\)"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-wave-definition","text":"Each source emits a circular wave described by: $$ \\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t + \\phi) $$ Where \\(r_i = \\sqrt{(x - x_{0i})^2 + (y - y_{0i})^2}\\) is the distance from source \\(i\\) to point \\((x, y)\\) . Common assumptions: - All sources have same \\(A, k, \\omega, \\phi\\) . - Initial phase \\(\\phi = 0\\) . - Non-dispersive medium.","title":"2. Wave Definition"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-superposition-principle","text":"Total displacement: $$ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t + \\phi) $$","title":"3. Superposition Principle"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-conditions","text":"Constructive : \\(k(r_i - r_j) = 2n\\pi\\) Destructive : \\(k(r_i - r_j) = (2n + 1)\\pi\\) Patterns arise from the geometry and wave interactions.","title":"Interference Conditions"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-wave-parameters","text":"Amplitude ( \\(A\\) ) : maximum surface displacement. Wavelength ( \\(\\lambda\\) ) : defines wave number \\(k = 2\\pi/\\lambda\\) . Frequency ( \\(f\\) ) : defines \\(\\omega = 2\\pi f\\) . Phase ( \\(\\phi\\) ) : typically zero for all sources. These define wave behavior and interference scale.","title":"4. Wave Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-simulation-grid","text":"","title":"5. Simulation Grid"},{"location":"1%20Physics/3%20Waves/Problem_1/#51-domain","text":"Choose spatial domain \\([x_{\\min}, x_{\\max}], [y_{\\min}, y_{\\max}]\\) large enough to capture wave effects: $$ (x_{\\max} - x_{\\min}) \\gtrsim 6\\lambda, \\quad (y_{\\max} - y_{\\min}) \\gtrsim 6\\lambda $$","title":"5.1 Domain"},{"location":"1%20Physics/3%20Waves/Problem_1/#52-resolution","text":"Grid spacing: $$ \\Delta x, \\Delta y \\leq \\frac{\\lambda}{10} $$ Construct grid using meshgrid in Python.","title":"5.2 Resolution"},{"location":"1%20Physics/3%20Waves/Problem_1/#53-boundary-effects","text":"Keep sources away from edges. Use absorbing or periodic boundaries as needed.","title":"5.3 Boundary Effects"},{"location":"1%20Physics/3%20Waves/Problem_1/#6-time-component","text":"Each wave evolves in time: $$ \\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t + \\phi) $$","title":"6. Time Component"},{"location":"1%20Physics/3%20Waves/Problem_1/#visualization-modes","text":"Snapshot : Fixed \\(t = t_0\\) . Shows static interference. Animation : Vary \\(t\\) over interval with step \\(\\Delta t \\leq 1/(20f)\\) . Use animations or contour plots to show dynamics.","title":"Visualization Modes"},{"location":"1%20Physics/3%20Waves/Problem_1/#7-visualization","text":"","title":"7. Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#71-single-source-static-wavefronts","text":"import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Wave parameters A = 1 lambda_ = 1 k = 2 * np.pi / lambda_ f = 1 omega = 2 * np.pi * f phi = 0 # Grid x = np.linspace(-5, 5, 400) y = np.linspace(-5, 5, 400) X, Y = np.meshgrid(x, y) r = np.sqrt((X - 0)**2 + (Y - 0)**2) # Setup plot fig, ax = plt.subplots() img = ax.imshow(np.zeros_like(X), extent=[-5, 5, -5, 5], cmap='viridis', origin='lower') plt.colorbar(img, ax=ax) ax.set_title(\"Single Source Wavefronts\") # Animation function def update(frame): t = frame / 20 eta = A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) img.set_data(eta) return [img] ani = animation.FuncAnimation(fig, update, frames=100, interval=50, blit=True) ani.save(\"single_source.gif\", writer=\"pillow\") plt.close() import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation # Parameters A = 1 lambda_ = 1 k = 2 * np.pi / lambda_ f = 1 omega = 2 * np.pi * f phi = 0 # Grid x = np.linspace(-5, 5, 150) y = np.linspace(-5, 5, 150) X, Y = np.meshgrid(x, y) r = np.sqrt((X - 0)**2 + (Y - 0)**2) # Setup plot fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') # Initialize the surface plot surf = ax.plot_surface(X, Y, np.zeros_like(X), cmap='viridis', edgecolor='none') ax.set_zlim(-2, 2) ax.set_title(\"Single Source \u2013 3D Animated Surface\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"Displacement\") def update(frame): global surf # Make surf accessible within the function t = frame / 20 eta = A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) # Remove the previous surface plot surf.remove() # Plot the new surface surf = ax.plot_surface(X, Y, eta, cmap='viridis', edgecolor='none') return [surf] # Return the updated surface ani = FuncAnimation(fig, update, frames=60, interval=100, blit=False) # blit=False is recommended for 3D animations ani.save(\"single_source_3d.gif\", writer=\"pillow\") plt.close()","title":"7.1 Single Source \u2013 Static Wavefronts"},{"location":"1%20Physics/3%20Waves/Problem_1/#72-two-sources-interference-pattern","text":"import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Wave parameters A = 1 lambda_ = 1 k = 2 * np.pi / lambda_ f = 1 omega = 2 * np.pi * f phi = 0 # Grid x = np.linspace(-5, 5, 400) y = np.linspace(-5, 5, 400) X, Y = np.meshgrid(x, y) # Two sources sources = [(-1.5, 0), (1.5, 0)] # Setup plot fig, ax = plt.subplots() img = ax.imshow(np.zeros_like(X), extent=[-5, 5, -5, 5], cmap='plasma', origin='lower') plt.colorbar(img, ax=ax) ax.set_title(\"Two Source Interference\") def update(frame): t = frame / 20 eta_sum = np.zeros_like(X) for x0, y0 in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_sum += A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) img.set_data(eta_sum) return [img] ani = animation.FuncAnimation(fig, update, frames=100, interval=50, blit=True) ani.save(\"two_sources.gif\", writer=\"pillow\") plt.close() import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation # Parameters A = 1 lambda_ = 1 k = 2 * np.pi / lambda_ f = 1 omega = 2 * np.pi * f phi = 0 # Grid x = np.linspace(-5, 5, 150) y = np.linspace(-5, 5, 150) X, Y = np.meshgrid(x, y) # Two source coordinates sources = [(-1.5, 0), (1.5, 0)] fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.set_zlim(-3, 3) ax.set_title(\"Two Sources \u2013 3D Animated Surface\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"Displacement\") # Initialize the surface plot outside the update function surf = ax.plot_surface(X, Y, np.zeros_like(X), cmap='plasma', edgecolor='none') def update(frame): global surf # Make surf accessible within the function t = frame / 20 eta_sum = np.zeros_like(X) for x0, y0 in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_sum += A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) # Remove the previous surface plot surf.remove() # Plot the new surface surf = ax.plot_surface(X, Y, eta_sum, cmap='plasma', edgecolor='none') return [surf] # Return the updated surface ani = FuncAnimation(fig, update, frames=60, interval=100, blit=False) # blit=False is recommended for 3D animations ani.save(\"two_sources_3d.gif\", writer=\"pillow\") plt.close()","title":"7.2 Two Sources \u2013 Interference Pattern"},{"location":"1%20Physics/3%20Waves/Problem_1/#73-three-sources-interference-from-triangle-configuration","text":"import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Wave parameters A = 1 lambda_ = 1 k = 2 * np.pi / lambda_ f = 1 omega = 2 * np.pi * f phi = 0 # Grid x = np.linspace(-5, 5, 400) y = np.linspace(-5, 5, 400) X, Y = np.meshgrid(x, y) # Triangle config R = 2 sources = [(R * np.cos(2*np.pi*i/3), R * np.sin(2*np.pi*i/3)) for i in range(3)] fig, ax = plt.subplots() img = ax.imshow(np.zeros_like(X), extent=[-5, 5, -5, 5], cmap='inferno', origin='lower') plt.colorbar(img, ax=ax) ax.set_title(\"Triangle Interference \u2013 Three Sources\") def update(frame): t = frame / 20 eta_sum = np.zeros_like(X) for x0, y0 in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_sum += A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) img.set_data(eta_sum) return [img] ani = animation.FuncAnimation(fig, update, frames=100, interval=50, blit=True) ani.save(\"three_sources.gif\", writer=\"pillow\") plt.close() import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation # Parameters A = 1 lambda_ = 1 k = 2 * np.pi / lambda_ f = 1 omega = 2 * np.pi * f phi = 0 # Grid x = np.linspace(-5, 5, 150) y = np.linspace(-5, 5, 150) X, Y = np.meshgrid(x, y) # Triangle configuration R = 2 sources = [(R * np.cos(2 * np.pi * i / 3), R * np.sin(2 * np.pi * i / 3)) for i in range(3)] fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.set_zlim(-3, 3) ax.set_title(\"Three Sources \u2013 3D Animated Surface\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"Displacement\") # Initialize surface plot surf = ax.plot_surface(X, Y, np.zeros_like(X), cmap='inferno', edgecolor='none') def update(frame): global surf # Make surf accessible within the function t = frame / 20 eta_sum = np.zeros_like(X) for x0, y0 in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_sum += A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) # Remove the previous surface plot surf.remove() # Plot the new surface surf = ax.plot_surface(X, Y, eta_sum, cmap='inferno', edgecolor='none') return [surf] ani = FuncAnimation(fig, update, frames=60, interval=100, blit=False) # blit=False is important for 3D animations ani.save(\"three_sources_3d.gif\", writer=\"pillow\") plt.close()","title":"7.3 Three Sources \u2013 Interference from Triangle Configuration"},{"location":"1%20Physics/3%20Waves/Problem_1/#colab-waves-problem-1","text":"Souce Code","title":"Colab: Waves Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#8-analysis","text":"Analyzing the resulting interference pattern reveals regions of amplification and cancellation.","title":"8. Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#81-constructive-interference","text":"Occurs when waves are in phase: $$ k(r_i - r_j) = 2\\pi n $$ Leads to high displacement regions (bright fringes or peaks).","title":"8.1 Constructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#82-destructive-interference","text":"Occurs when waves are out of phase: $$ k(r_i - r_j) = (2n + 1)\\pi $$ Leads to wave cancellation (dark zones or troughs).","title":"8.2 Destructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#83-pattern-symmetry","text":"Pattern symmetry follows the polygon's geometry: - Two sources: symmetry about midpoint. - Three (triangle): \\(120^\\circ\\) rotational symmetry. - Four or more: increasing complexity, matching polygonal symmetry.","title":"8.3 Pattern Symmetry"},{"location":"1%20Physics/3%20Waves/Problem_1/#84-visual-cues","text":"Bright ridges = constructive zones Dark lines = destructive zones Radial or rotational motifs reflect geometric layout Contours or threshold filters can aid interpretation.","title":"8.4 Visual Cues"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/","text":"Problem 1 Simulating the Lorentz Force 1. Exploration of Applications The Lorentz force describes the motion of a charged particle under the influence of electric and magnetic fields , and is one of the cornerstones of classical and modern electromagnetism. 1.1 Fundamental Equation The Lorentz force acting on a particle of charge \\(q\\) moving with velocity \\(\\mathbf{v}\\) in an electric field \\(\\mathbf{E}\\) and magnetic field \\(\\mathbf{B}\\) is given by: \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] This vector equation has two key components: The electric force : \\(q\\mathbf{E}\\) , which acts in the direction of the electric field. The magnetic force : \\(q\\mathbf{v} \\times \\mathbf{B}\\) , which acts perpendicular to both the velocity of the particle and the magnetic field. 1.2 Real-World Applications The Lorentz force plays a pivotal role in several technological and scientific domains: \u2022 Particle Accelerators In cyclotrons , synchrotrons , and linear accelerators , particles are steered and accelerated using electromagnetic fields. Magnetic fields enforce circular or helical motion: $$ r = \\frac{mv}{|q|B} $$ Electric fields provide kinetic energy: $$ \\Delta K = qEd $$ \u2022 Mass Spectrometers Used in chemistry and physics to identify atoms and molecules based on their mass-to-charge ratio. \u2022 Plasma Confinement (Fusion Reactors) In tokamaks and stellarators , magnetic fields confine high-energy plasma in a donut-shaped chamber. 1.3 Summary of Field Effects Field Type Direction of Force Effect on Motion \\(\\mathbf{E}\\) only Parallel to \\(\\mathbf{E}\\) Linear acceleration or deceleration \\(\\mathbf{B}\\) only Perpendicular to \\(\\mathbf{v}\\) and \\(\\mathbf{B}\\) Circular or helical motion \\(\\mathbf{E} \\perp \\mathbf{B}\\) Orthogonal force due to \\(\\mathbf{v} \\times \\mathbf{B}\\) Drift or spiral trajectories 2. Simulating Particle Motion 2.1 Governing Equation \\[ \\mathbf{F} = m \\frac{d\\mathbf{v}}{dt} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] 2.2 Numerical Implementation Euler method used initially: $$ \\mathbf{v} {n+1} = \\mathbf{v}_n + \\frac{q}{m}(\\mathbf{E} + \\mathbf{v}_n \\times \\mathbf{B})\\Delta t $$ $$ \\mathbf{r} {n+1} = \\mathbf{r}_n + \\mathbf{v}_n \\Delta t $$ 2.4 Boris Algorithm Implementation (Alternative to Euler) # Boris algorithm for stable motion in magnetic fields q, m = 1.0, 1.0 B = np.array([0, 0, 1.0]) E = np.array([0.0, 0.0, 0.0]) v0 = np.array([1.0, 0.0, 0.0]) r0 = np.array([0.0, 0.0, 0.0]) dt, T = 0.01, 10 N = int(T / dt) r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 t = (q * B / m) * (dt / 2) t_mag2 = np.dot(t, t) s = 2 * t / (1 + t_mag2) for i in range(N - 1): v_minus = v[i] + (q * E / m) * (dt / 2) v_prime = v_minus + np.cross(v_minus, t) v_plus = v_minus + np.cross(v_prime, s) v[i + 1] = v_plus + (q * E / m) * (dt / 2) r[i + 1] = r[i] + v[i + 1] * dt 2.5 Types of Motion \u2022 Circular Motion Occurs when: - \\(\\mathbf{E} = 0\\) - \\(\\mathbf{v} \\perp \\mathbf{B}\\) Result: - Constant-speed circular motion in the plane perpendicular to \\(\\mathbf{B}\\) \u2022 Helical Motion Occurs when: - \\(\\mathbf{v}\\) has both parallel and perpendicular components with respect to \\(\\mathbf{B}\\) - \\(\\mathbf{E} = 0\\) or parallel to \\(\\mathbf{B}\\) Result: - Particle moves in a spiral (helix) along field lines with pitch determined by \\(v_\\parallel\\) \u2022 Drift Motion Occurs under: - \\(\\mathbf{E} \\perp \\mathbf{B}\\) Result: - Circular/helical motion superimposed with uniform drift : $$ \\mathbf{v}_\\text{drift} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$ These simulations are vital in visualizing how charged particles behave in various field environments, providing insights into devices such as mass spectrometers , magnetic confinement systems , and beam control in accelerators . 3. Parameter Exploration The dynamics of charged particles under the Lorentz force are highly sensitive to physical parameters. Exploring variations in these parameters allows us to understand how they shape the trajectory and motion characteristics such as speed, curvature, and drift. The Lorentz force remains our starting point: \\[ \\mathbf{F} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] This governs the acceleration and thus the trajectory of the particle according to Newton's second law: \\[ \\mathbf{F} = m \\frac{d\\mathbf{v}}{dt} \\] 3.1 Key Parameters and Their Effects \u2022 Electric Field Strength ( \\(E\\) ) The electric field contributes directly to linear acceleration : \\[ \\mathbf{a}_E = \\frac{q\\mathbf{E}}{m} \\] Stronger \\(E\\) leads to higher linear acceleration. Dominant in configurations where \\(\\mathbf{B} = 0\\) or \\(\\mathbf{v} \\parallel \\mathbf{E}\\) . In combined fields, \\(E\\) affects drift velocity and can induce helical stretching . \u2022 Magnetic Field Strength ( \\(B\\) ) The magnetic component of the Lorentz force is velocity-dependent: \\[ \\mathbf{F}_B = q(\\mathbf{v} \\times \\mathbf{B}) \\] Stronger \\(B\\) increases the curvature of motion. In pure \\(\\mathbf{B}\\) fields, it reduces the Larmor radius : $$ r_L = \\frac{mv_\\perp}{|q|B} $$ It also increases the gyrofrequency : $$ \\omega_c = \\frac{|q|B}{m} $$ where \\(\\omega_c\\) is the cyclotron frequency . \u2022 Initial Velocity ( \\(\\mathbf{v}\\) ) The direction and magnitude of initial velocity define the geometry of motion: Perpendicular to \\(\\mathbf{B}\\) \\(\\rightarrow\\) circular motion Parallel to \\(\\mathbf{B}\\) \\(\\rightarrow\\) linear motion Mixed components \\(\\rightarrow\\) helical motion Magnitude affects: Radius of curvature ( \\(r_L\\) increases with \\(v_\\perp\\) ) Speed of drift in crossed fields: \\[ \\mathbf{v}_\\text{drift} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} \\] \u2022 Particle Charge ( \\(q\\) ) Charge affects both magnitude and direction of the Lorentz force: Sign of \\(q\\) reverses the direction of the magnetic force: $$ \\text{If } q > 0: \\text{ right-hand rule applies} \\ \\text{If } q < 0: \\text{ reverse direction (left-hand motion)} $$ Affects radius and frequency as: $$ r_L \\propto \\frac{1}{|q|}, \\quad \\omega_c \\propto |q| $$ \u2022 Particle Mass ( \\(m\\) ) Inversely proportional to acceleration for a given force: $$ \\mathbf{a} = \\frac{\\mathbf{F}}{m} $$ Affects Larmor radius and cyclotron frequency: $$ r_L \\propto m, \\quad \\omega_c \\propto \\frac{1}{m} $$ Heavier particles exhibit larger orbits and slower rotation under the same field conditions. 3.2 Visual Exploration Goals By varying the above parameters in simulations, one should: Track trajectory changes : curvature, helical pitch, drift. Compare motion types : linear vs circular vs spiral. Identify scaling laws for: Larmor radius: \\(r_L = \\frac{mv_\\perp}{|q|B}\\) Cyclotron frequency: \\(\\omega_c = \\frac{|q|B}{m}\\) Parameter exploration is essential for tuning real-world applications, from optimizing cyclotron paths to designing magnetic traps and beamlines. 3.3 Real-World System Example: Cyclotron Motion Proton in a cyclotron: - \\(B = 1\\ \\text{T}\\) - \\(v = 1 \\times 10^6\\ \\text{m/s}\\) Larmor radius: $$ r_L = \\frac{mv}{|q|B} = \\frac{1.67 \\times 10^{-27} \\cdot 10^6}{1.6 \\times 10^{-19} \\cdot 1} \\approx 0.0104\\ \\text{m} $$ 3.4 Interactive Parameter Exploration (Optional for Jupyter/Colab) import ipywidgets as widgets from IPython.display import display def update_simulation(B_field=1.0, velocity=1.0): # Call a simulation function with updated B and v pass display(widgets.FloatSlider(value=1.0, min=0.1, max=5.0, step=0.1, description='B Field')) display(widgets.FloatSlider(value=1.0, min=0.1, max=5.0, step=0.1, description='Velocity')) 4. Visualization Visualizing charged particle trajectories under the Lorentz force is critical for developing intuition about their motion in various electromagnetic field configurations. In this section, we use Python and standard scientific libraries to produce labeled, informative 2D and 3D plots that illustrate: Larmor radius \\(r_L\\) Helical pitch (distance between spiral turns along the field direction) Drift velocity \\(\\mathbf{v}_\\text{drift} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2}\\) 4.1 Circular Motion in \\(xy\\) -Plane Charged particle moves in a circle under a uniform magnetic field ( \\(\\mathbf{B}\\) along \\(z\\) ). No electric field; pure cyclotron motion with constant radius and speed. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Parameters q, m = 1.0, 1.0 B = np.array([0, 0, 1.0]) v0 = np.array([1.0, 0.0, 0.0]) r0 = np.array([0.0, 0.0, 0.0]) dt, T = 0.01, 10 N = int(T / dt) # Calculate trajectory r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * np.cross(v[i], B) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Create animation fig, ax = plt.subplots() ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) ax.set_aspect('equal') line, = ax.plot([], [], lw=2) point, = ax.plot([], [], 'ro') def update(i): line.set_data(r[:i + 1, 0], r[:i + 1, 1]) # Trajectory line point.set_data([r[i, 0]], [r[i, 1]]) # Current point (wrapped in lists) return line, point # Create animation ani = FuncAnimation(fig, update, frames=N - 1, interval=30, blit=True) # Display animation inline in Jupyter Notebook plt.title(\"Circular Motion in xy-plane (Animated)\") plt.xlabel('x') plt.ylabel('y') # plt.grid(True) # plt.show() # Save animation as GIF gif_path = 'circular_motion.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html) 4.2 3D Helical Motion Particle follows a helical path due to velocity components both parallel and perpendicular to \\(\\mathbf{B}\\) . Circular motion + forward motion along field lines. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation from IPython.display import HTML import base64 from io import BytesIO # Parameters q, m = 1.0, 1.0 B = np.array([0, 0, 1.0]) v0 = np.array([1.0, 0.0, 0.5]) # Initial velocity with z-component for helical motion r0 = np.array([0.0, 0.0, 0.0]) dt, T = 0.01, 10 N = int(T / dt) # Calculate trajectory r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * np.cross(v[i], B) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Create 3D animation fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) ax.set_zlim(0, 6) line, = ax.plot([], [], [], lw=2) point, = ax.plot([], [], [], 'ro') def update_3d(i): # Update line (trajectory) line.set_data(r[:i, 0], r[:i, 1]) line.set_3d_properties(r[:i, 2]) # Update point (current position) point.set_data([r[i, 0]], [r[i, 1]]) # Wrap in lists to provide sequences point.set_3d_properties([r[i, 2]]) # Wrap in list to provide sequence return line, point # Create animation ani = FuncAnimation(fig, update_3d, frames=N - 1, interval=30, blit=False) # blit=False for 3D # Set plot labels and title ax.set_title(\"3D Helical Motion (Animated)\") ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') # Save animation as GIF gif_path = 'helical_motion.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html) 4.3 \\(\\mathbf{E} \\times \\mathbf{B}\\) Drift Motion In crossed electric and magnetic fields, the particle spirals while drifting uniformly perpendicular to both \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) . import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML import base64 from io import BytesIO # Parameters q, m = 1.0, 1.0 E = np.array([1.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field r0 = np.array([0.0, 0.0, 0.0]) v0 = np.array([0.5, 0.0, 0.0]) # Initial velocity dt, T = 0.01, 10 N = int(T / dt) # Calculate trajectory r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * (E + np.cross(v[i], B)) # Lorentz force with E and B fields a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Calculate E \u00d7 B drift drift = np.cross(E, B) / np.dot(B, B) # Drift velocity: (E \u00d7 B) / |B|^2 # Create 2D animation fig, ax = plt.subplots() ax.set_xlim(0, 10) ax.set_ylim(-2, 2) ax.set_aspect('equal') line, = ax.plot([], [], lw=2, label='Trajectory') point, = ax.plot([], [], 'ro', label='Particle') drift_line, = ax.plot([], [], 'r--', label='Drift') def update_drift(i): # Update trajectory line line.set_data(r[:i, 0], r[:i, 1]) # Update particle position point.set_data([r[i, 0]], [r[i, 1]]) # Wrap in lists to provide sequences # Update drift line if i > 1: # Ensure enough points for linspace t = np.linspace(0, r[i, 0], 50) # Use fixed number of points for smoothness drift_y = drift[1] * t + r[0, 1] # Drift along y-axis drift_line.set_data(t, drift_y) else: drift_line.set_data([], []) # Empty data for initial frames return line, point, drift_line # Create animation ani = FuncAnimation(fig, update_drift, frames=N - 1, interval=30, blit=True) # Set plot labels, title, and legend plt.title(\"Drift Motion in Crossed E \u00d7 B Fields (Animated)\") plt.xlabel('x') plt.ylabel('y') plt.grid(True) plt.legend() # Save animation as GIF gif_path = 'drift_motion.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html) Colab: Electromagnetism Problem 1 Souce Code Summary of Visual Insights Larmor radius is determined by the perpendicular velocity component and magnetic field: $$ r_L = \\frac{mv_\\perp}{|q|B} $$ Helical pitch corresponds to the distance moved in the field direction per revolution: $$ \\text{Pitch} = v_\\parallel T = \\frac{2\\pi m v_\\parallel}{|q|B} $$ Drift velocity from crossed fields appears as a linear translation of the helix: $$ \\mathbf{v}_{\\text{drift}} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$ These visualizations provide powerful tools to explore particle behavior and validate analytic predictions. 5. Numerical Implementation Simulating the motion of charged particles under electromagnetic forces involves solving ordinary differential equations (ODEs) derived from the Lorentz force law : \\[ \\mathbf{F} = m\\frac{d\\mathbf{v}}{dt} = q\\left( \\mathbf{E} + \\mathbf{v} \\times \\mathbf{B} \\right) \\] This gives a coupled system of first-order ODEs: \\[ \\frac{d\\mathbf{v}}{dt} = \\frac{q}{m}(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}), \\quad \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\] These equations are nonlinear and cannot usually be solved analytically. Therefore, we use numerical methods. Euler Method (First-Order Approximation) The Euler method is the simplest approach, using forward differences: \\[ \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{q}{m}(\\mathbf{E} + \\mathbf{v}_n \\times \\mathbf{B})\\Delta t \\] \\[ \\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v}_n \\Delta t \\] Pros : Easy to implement Cons : Low accuracy, error grows with time, unstable for stiff or oscillatory systems Runge-Kutta Method (4th Order, RK4) The RK4 method offers a much more accurate solution. It approximates the next state using intermediate \"slopes\": Let \\(\\mathbf{f}(t, \\mathbf{y})\\) be the derivative function for velocity and position: Compute intermediate steps: $$ \\begin{aligned} \\mathbf{k}_1 &= f(t_n, \\mathbf{y}_n) \\ \\mathbf{k}_2 &= f(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_1) \\ \\mathbf{k}_3 &= f(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_2) \\ \\mathbf{k}_4 &= f(t_n + \\Delta t, \\mathbf{y}_n + \\Delta t \\mathbf{k}_3) \\end{aligned} $$ Update the solution: $$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4) $$ Where \\(\\mathbf{y}\\) can represent either \\(\\mathbf{r}\\) or \\(\\mathbf{v}\\) . Pros : Much more accurate and stable than Euler, handles oscillatory behavior well Cons : More computationally expensive Recommendation Use Euler method for quick visualizations or conceptual understanding. Use RK4 or the Boris method for precision and stability in realistic physics simulations (e.g., plasma modeling, cyclotron motion, fusion confinement). Numerical Stability Time step size \\(\\Delta t\\) must be small enough to resolve gyro-motion : \\[ \\Delta t \\ll \\frac{2\\pi m}{|q|B} = T_{\\text{cyclotron}} \\] Choosing too large a step causes inaccurate or even unstable results.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#problem-1","text":"Simulating the Lorentz Force","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#1-exploration-of-applications","text":"The Lorentz force describes the motion of a charged particle under the influence of electric and magnetic fields , and is one of the cornerstones of classical and modern electromagnetism.","title":"1. Exploration of Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#11-fundamental-equation","text":"The Lorentz force acting on a particle of charge \\(q\\) moving with velocity \\(\\mathbf{v}\\) in an electric field \\(\\mathbf{E}\\) and magnetic field \\(\\mathbf{B}\\) is given by: \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] This vector equation has two key components: The electric force : \\(q\\mathbf{E}\\) , which acts in the direction of the electric field. The magnetic force : \\(q\\mathbf{v} \\times \\mathbf{B}\\) , which acts perpendicular to both the velocity of the particle and the magnetic field.","title":"1.1 Fundamental Equation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#12-real-world-applications","text":"The Lorentz force plays a pivotal role in several technological and scientific domains:","title":"1.2 Real-World Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#particle-accelerators","text":"In cyclotrons , synchrotrons , and linear accelerators , particles are steered and accelerated using electromagnetic fields. Magnetic fields enforce circular or helical motion: $$ r = \\frac{mv}{|q|B} $$ Electric fields provide kinetic energy: $$ \\Delta K = qEd $$","title":"\u2022 Particle Accelerators"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#mass-spectrometers","text":"Used in chemistry and physics to identify atoms and molecules based on their mass-to-charge ratio.","title":"\u2022 Mass Spectrometers"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#plasma-confinement-fusion-reactors","text":"In tokamaks and stellarators , magnetic fields confine high-energy plasma in a donut-shaped chamber.","title":"\u2022 Plasma Confinement (Fusion Reactors)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#13-summary-of-field-effects","text":"Field Type Direction of Force Effect on Motion \\(\\mathbf{E}\\) only Parallel to \\(\\mathbf{E}\\) Linear acceleration or deceleration \\(\\mathbf{B}\\) only Perpendicular to \\(\\mathbf{v}\\) and \\(\\mathbf{B}\\) Circular or helical motion \\(\\mathbf{E} \\perp \\mathbf{B}\\) Orthogonal force due to \\(\\mathbf{v} \\times \\mathbf{B}\\) Drift or spiral trajectories","title":"1.3 Summary of Field Effects"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#2-simulating-particle-motion","text":"","title":"2. Simulating Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#21-governing-equation","text":"\\[ \\mathbf{F} = m \\frac{d\\mathbf{v}}{dt} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\]","title":"2.1 Governing Equation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#22-numerical-implementation","text":"Euler method used initially: $$ \\mathbf{v} {n+1} = \\mathbf{v}_n + \\frac{q}{m}(\\mathbf{E} + \\mathbf{v}_n \\times \\mathbf{B})\\Delta t $$ $$ \\mathbf{r} {n+1} = \\mathbf{r}_n + \\mathbf{v}_n \\Delta t $$","title":"2.2 Numerical Implementation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#24-boris-algorithm-implementation-alternative-to-euler","text":"# Boris algorithm for stable motion in magnetic fields q, m = 1.0, 1.0 B = np.array([0, 0, 1.0]) E = np.array([0.0, 0.0, 0.0]) v0 = np.array([1.0, 0.0, 0.0]) r0 = np.array([0.0, 0.0, 0.0]) dt, T = 0.01, 10 N = int(T / dt) r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 t = (q * B / m) * (dt / 2) t_mag2 = np.dot(t, t) s = 2 * t / (1 + t_mag2) for i in range(N - 1): v_minus = v[i] + (q * E / m) * (dt / 2) v_prime = v_minus + np.cross(v_minus, t) v_plus = v_minus + np.cross(v_prime, s) v[i + 1] = v_plus + (q * E / m) * (dt / 2) r[i + 1] = r[i] + v[i + 1] * dt","title":"2.4 Boris Algorithm Implementation (Alternative to Euler)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#25-types-of-motion","text":"","title":"2.5 Types of Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#circular-motion","text":"Occurs when: - \\(\\mathbf{E} = 0\\) - \\(\\mathbf{v} \\perp \\mathbf{B}\\) Result: - Constant-speed circular motion in the plane perpendicular to \\(\\mathbf{B}\\)","title":"\u2022 Circular Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#helical-motion","text":"Occurs when: - \\(\\mathbf{v}\\) has both parallel and perpendicular components with respect to \\(\\mathbf{B}\\) - \\(\\mathbf{E} = 0\\) or parallel to \\(\\mathbf{B}\\) Result: - Particle moves in a spiral (helix) along field lines with pitch determined by \\(v_\\parallel\\)","title":"\u2022 Helical Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#drift-motion","text":"Occurs under: - \\(\\mathbf{E} \\perp \\mathbf{B}\\) Result: - Circular/helical motion superimposed with uniform drift : $$ \\mathbf{v}_\\text{drift} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$ These simulations are vital in visualizing how charged particles behave in various field environments, providing insights into devices such as mass spectrometers , magnetic confinement systems , and beam control in accelerators .","title":"\u2022 Drift Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#3-parameter-exploration","text":"The dynamics of charged particles under the Lorentz force are highly sensitive to physical parameters. Exploring variations in these parameters allows us to understand how they shape the trajectory and motion characteristics such as speed, curvature, and drift. The Lorentz force remains our starting point: \\[ \\mathbf{F} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] This governs the acceleration and thus the trajectory of the particle according to Newton's second law: \\[ \\mathbf{F} = m \\frac{d\\mathbf{v}}{dt} \\]","title":"3. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#31-key-parameters-and-their-effects","text":"","title":"3.1 Key Parameters and Their Effects"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#electric-field-strength-e","text":"The electric field contributes directly to linear acceleration : \\[ \\mathbf{a}_E = \\frac{q\\mathbf{E}}{m} \\] Stronger \\(E\\) leads to higher linear acceleration. Dominant in configurations where \\(\\mathbf{B} = 0\\) or \\(\\mathbf{v} \\parallel \\mathbf{E}\\) . In combined fields, \\(E\\) affects drift velocity and can induce helical stretching .","title":"\u2022 Electric Field Strength (\\(E\\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#magnetic-field-strength-b","text":"The magnetic component of the Lorentz force is velocity-dependent: \\[ \\mathbf{F}_B = q(\\mathbf{v} \\times \\mathbf{B}) \\] Stronger \\(B\\) increases the curvature of motion. In pure \\(\\mathbf{B}\\) fields, it reduces the Larmor radius : $$ r_L = \\frac{mv_\\perp}{|q|B} $$ It also increases the gyrofrequency : $$ \\omega_c = \\frac{|q|B}{m} $$ where \\(\\omega_c\\) is the cyclotron frequency .","title":"\u2022 Magnetic Field Strength (\\(B\\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#initial-velocity-mathbfv","text":"The direction and magnitude of initial velocity define the geometry of motion: Perpendicular to \\(\\mathbf{B}\\) \\(\\rightarrow\\) circular motion Parallel to \\(\\mathbf{B}\\) \\(\\rightarrow\\) linear motion Mixed components \\(\\rightarrow\\) helical motion Magnitude affects: Radius of curvature ( \\(r_L\\) increases with \\(v_\\perp\\) ) Speed of drift in crossed fields: \\[ \\mathbf{v}_\\text{drift} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} \\]","title":"\u2022 Initial Velocity (\\(\\mathbf{v}\\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#particle-charge-q","text":"Charge affects both magnitude and direction of the Lorentz force: Sign of \\(q\\) reverses the direction of the magnetic force: $$ \\text{If } q > 0: \\text{ right-hand rule applies} \\ \\text{If } q < 0: \\text{ reverse direction (left-hand motion)} $$ Affects radius and frequency as: $$ r_L \\propto \\frac{1}{|q|}, \\quad \\omega_c \\propto |q| $$","title":"\u2022 Particle Charge (\\(q\\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#particle-mass-m","text":"Inversely proportional to acceleration for a given force: $$ \\mathbf{a} = \\frac{\\mathbf{F}}{m} $$ Affects Larmor radius and cyclotron frequency: $$ r_L \\propto m, \\quad \\omega_c \\propto \\frac{1}{m} $$ Heavier particles exhibit larger orbits and slower rotation under the same field conditions.","title":"\u2022 Particle Mass (\\(m\\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#32-visual-exploration-goals","text":"By varying the above parameters in simulations, one should: Track trajectory changes : curvature, helical pitch, drift. Compare motion types : linear vs circular vs spiral. Identify scaling laws for: Larmor radius: \\(r_L = \\frac{mv_\\perp}{|q|B}\\) Cyclotron frequency: \\(\\omega_c = \\frac{|q|B}{m}\\) Parameter exploration is essential for tuning real-world applications, from optimizing cyclotron paths to designing magnetic traps and beamlines.","title":"3.2 Visual Exploration Goals"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#33-real-world-system-example-cyclotron-motion","text":"Proton in a cyclotron: - \\(B = 1\\ \\text{T}\\) - \\(v = 1 \\times 10^6\\ \\text{m/s}\\) Larmor radius: $$ r_L = \\frac{mv}{|q|B} = \\frac{1.67 \\times 10^{-27} \\cdot 10^6}{1.6 \\times 10^{-19} \\cdot 1} \\approx 0.0104\\ \\text{m} $$","title":"3.3 Real-World System Example: Cyclotron Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#34-interactive-parameter-exploration-optional-for-jupytercolab","text":"import ipywidgets as widgets from IPython.display import display def update_simulation(B_field=1.0, velocity=1.0): # Call a simulation function with updated B and v pass display(widgets.FloatSlider(value=1.0, min=0.1, max=5.0, step=0.1, description='B Field')) display(widgets.FloatSlider(value=1.0, min=0.1, max=5.0, step=0.1, description='Velocity'))","title":"3.4 Interactive Parameter Exploration (Optional for Jupyter/Colab)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#4-visualization","text":"Visualizing charged particle trajectories under the Lorentz force is critical for developing intuition about their motion in various electromagnetic field configurations. In this section, we use Python and standard scientific libraries to produce labeled, informative 2D and 3D plots that illustrate: Larmor radius \\(r_L\\) Helical pitch (distance between spiral turns along the field direction) Drift velocity \\(\\mathbf{v}_\\text{drift} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2}\\)","title":"4. Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#41-circular-motion-in-xy-plane","text":"Charged particle moves in a circle under a uniform magnetic field ( \\(\\mathbf{B}\\) along \\(z\\) ). No electric field; pure cyclotron motion with constant radius and speed. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Parameters q, m = 1.0, 1.0 B = np.array([0, 0, 1.0]) v0 = np.array([1.0, 0.0, 0.0]) r0 = np.array([0.0, 0.0, 0.0]) dt, T = 0.01, 10 N = int(T / dt) # Calculate trajectory r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * np.cross(v[i], B) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Create animation fig, ax = plt.subplots() ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) ax.set_aspect('equal') line, = ax.plot([], [], lw=2) point, = ax.plot([], [], 'ro') def update(i): line.set_data(r[:i + 1, 0], r[:i + 1, 1]) # Trajectory line point.set_data([r[i, 0]], [r[i, 1]]) # Current point (wrapped in lists) return line, point # Create animation ani = FuncAnimation(fig, update, frames=N - 1, interval=30, blit=True) # Display animation inline in Jupyter Notebook plt.title(\"Circular Motion in xy-plane (Animated)\") plt.xlabel('x') plt.ylabel('y') # plt.grid(True) # plt.show() # Save animation as GIF gif_path = 'circular_motion.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html)","title":"4.1 Circular Motion in \\(xy\\)-Plane"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#42-3d-helical-motion","text":"Particle follows a helical path due to velocity components both parallel and perpendicular to \\(\\mathbf{B}\\) . Circular motion + forward motion along field lines. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation from IPython.display import HTML import base64 from io import BytesIO # Parameters q, m = 1.0, 1.0 B = np.array([0, 0, 1.0]) v0 = np.array([1.0, 0.0, 0.5]) # Initial velocity with z-component for helical motion r0 = np.array([0.0, 0.0, 0.0]) dt, T = 0.01, 10 N = int(T / dt) # Calculate trajectory r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * np.cross(v[i], B) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Create 3D animation fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) ax.set_zlim(0, 6) line, = ax.plot([], [], [], lw=2) point, = ax.plot([], [], [], 'ro') def update_3d(i): # Update line (trajectory) line.set_data(r[:i, 0], r[:i, 1]) line.set_3d_properties(r[:i, 2]) # Update point (current position) point.set_data([r[i, 0]], [r[i, 1]]) # Wrap in lists to provide sequences point.set_3d_properties([r[i, 2]]) # Wrap in list to provide sequence return line, point # Create animation ani = FuncAnimation(fig, update_3d, frames=N - 1, interval=30, blit=False) # blit=False for 3D # Set plot labels and title ax.set_title(\"3D Helical Motion (Animated)\") ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') # Save animation as GIF gif_path = 'helical_motion.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html)","title":"4.2 3D Helical Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#43-mathbfe-times-mathbfb-drift-motion","text":"In crossed electric and magnetic fields, the particle spirals while drifting uniformly perpendicular to both \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) . import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML import base64 from io import BytesIO # Parameters q, m = 1.0, 1.0 E = np.array([1.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field r0 = np.array([0.0, 0.0, 0.0]) v0 = np.array([0.5, 0.0, 0.0]) # Initial velocity dt, T = 0.01, 10 N = int(T / dt) # Calculate trajectory r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * (E + np.cross(v[i], B)) # Lorentz force with E and B fields a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Calculate E \u00d7 B drift drift = np.cross(E, B) / np.dot(B, B) # Drift velocity: (E \u00d7 B) / |B|^2 # Create 2D animation fig, ax = plt.subplots() ax.set_xlim(0, 10) ax.set_ylim(-2, 2) ax.set_aspect('equal') line, = ax.plot([], [], lw=2, label='Trajectory') point, = ax.plot([], [], 'ro', label='Particle') drift_line, = ax.plot([], [], 'r--', label='Drift') def update_drift(i): # Update trajectory line line.set_data(r[:i, 0], r[:i, 1]) # Update particle position point.set_data([r[i, 0]], [r[i, 1]]) # Wrap in lists to provide sequences # Update drift line if i > 1: # Ensure enough points for linspace t = np.linspace(0, r[i, 0], 50) # Use fixed number of points for smoothness drift_y = drift[1] * t + r[0, 1] # Drift along y-axis drift_line.set_data(t, drift_y) else: drift_line.set_data([], []) # Empty data for initial frames return line, point, drift_line # Create animation ani = FuncAnimation(fig, update_drift, frames=N - 1, interval=30, blit=True) # Set plot labels, title, and legend plt.title(\"Drift Motion in Crossed E \u00d7 B Fields (Animated)\") plt.xlabel('x') plt.ylabel('y') plt.grid(True) plt.legend() # Save animation as GIF gif_path = 'drift_motion.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html)","title":"4.3 \\(\\mathbf{E} \\times \\mathbf{B}\\) Drift Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#colab-electromagnetism-problem-1","text":"Souce Code","title":"Colab: Electromagnetism Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#summary-of-visual-insights","text":"Larmor radius is determined by the perpendicular velocity component and magnetic field: $$ r_L = \\frac{mv_\\perp}{|q|B} $$ Helical pitch corresponds to the distance moved in the field direction per revolution: $$ \\text{Pitch} = v_\\parallel T = \\frac{2\\pi m v_\\parallel}{|q|B} $$ Drift velocity from crossed fields appears as a linear translation of the helix: $$ \\mathbf{v}_{\\text{drift}} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$ These visualizations provide powerful tools to explore particle behavior and validate analytic predictions.","title":"Summary of Visual Insights"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#5-numerical-implementation","text":"Simulating the motion of charged particles under electromagnetic forces involves solving ordinary differential equations (ODEs) derived from the Lorentz force law : \\[ \\mathbf{F} = m\\frac{d\\mathbf{v}}{dt} = q\\left( \\mathbf{E} + \\mathbf{v} \\times \\mathbf{B} \\right) \\] This gives a coupled system of first-order ODEs: \\[ \\frac{d\\mathbf{v}}{dt} = \\frac{q}{m}(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}), \\quad \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\] These equations are nonlinear and cannot usually be solved analytically. Therefore, we use numerical methods.","title":"5. Numerical Implementation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#euler-method-first-order-approximation","text":"The Euler method is the simplest approach, using forward differences: \\[ \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{q}{m}(\\mathbf{E} + \\mathbf{v}_n \\times \\mathbf{B})\\Delta t \\] \\[ \\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v}_n \\Delta t \\] Pros : Easy to implement Cons : Low accuracy, error grows with time, unstable for stiff or oscillatory systems","title":"Euler Method (First-Order Approximation)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#runge-kutta-method-4th-order-rk4","text":"The RK4 method offers a much more accurate solution. It approximates the next state using intermediate \"slopes\": Let \\(\\mathbf{f}(t, \\mathbf{y})\\) be the derivative function for velocity and position: Compute intermediate steps: $$ \\begin{aligned} \\mathbf{k}_1 &= f(t_n, \\mathbf{y}_n) \\ \\mathbf{k}_2 &= f(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_1) \\ \\mathbf{k}_3 &= f(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_2) \\ \\mathbf{k}_4 &= f(t_n + \\Delta t, \\mathbf{y}_n + \\Delta t \\mathbf{k}_3) \\end{aligned} $$ Update the solution: $$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4) $$ Where \\(\\mathbf{y}\\) can represent either \\(\\mathbf{r}\\) or \\(\\mathbf{v}\\) . Pros : Much more accurate and stable than Euler, handles oscillatory behavior well Cons : More computationally expensive","title":"Runge-Kutta Method (4th Order, RK4)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#recommendation","text":"Use Euler method for quick visualizations or conceptual understanding. Use RK4 or the Boris method for precision and stability in realistic physics simulations (e.g., plasma modeling, cyclotron motion, fusion confinement).","title":"Recommendation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1%20copy/#numerical-stability","text":"Time step size \\(\\Delta t\\) must be small enough to resolve gyro-motion : \\[ \\Delta t \\ll \\frac{2\\pi m}{|q|B} = T_{\\text{cyclotron}} \\] Choosing too large a step causes inaccurate or even unstable results.","title":"Numerical Stability"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 (Shorted) Simulating the Lorentz Force 1. Applications of the Lorentz Force The Lorentz force law, $$ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B}, $$ governs the dynamics of charged particles in electric ( \\(\\mathbf{E}\\) ) and magnetic ( \\(\\mathbf{B}\\) ) fields. Key Applications: Particle Accelerators : Magnetic fields guide particles in circular paths; electric fields accelerate them. Mass Spectrometers : Different mass-to-charge ratios cause unique curvatures in magnetic fields. Plasma Confinement : Magnetic traps (e.g., tokamaks) confine charged plasma using helical motion. Field Setup Force Direction Resulting Motion \\(\\mathbf{E}\\) only Along \\(\\mathbf{E}\\) Linear acceleration \\(\\mathbf{B}\\) only Perpendicular to \\(\\mathbf{v}, \\mathbf{B}\\) Circular/helical motion \\(\\mathbf{E} \\perp \\mathbf{B}\\) Orthogonal force, causes drift Spiral with drift velocity 2. Simulating Particle Motion Governing Equation: \\[ m\\frac{d\\mathbf{v}}{dt} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] Methods: Euler Method : Simple but less accurate for oscillatory systems. Boris Algorithm : Preserves energy in magnetic fields. Runge-Kutta (RK4) : Offers high accuracy at greater computational cost. Motion Types: Circular : \\(\\mathbf{v} \\perp \\mathbf{B}\\) , no \\(\\mathbf{E}\\) . Helical : \\(\\mathbf{v}\\) has parallel and perpendicular components to \\(\\mathbf{B}\\) . Drift : \\(\\mathbf{E} \\perp \\mathbf{B}\\) causes uniform drift: $$ \\mathbf{v}_\\text{drift} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$ 3. Parameter Exploration Simulation results depend on: Field Strengths : \\(E \\rightarrow\\) linear acceleration \\(B \\rightarrow\\) tighter curvature, smaller Larmor radius Initial Velocity : Perpendicular component: affects orbit size Parallel component: affects pitch of helical motion Charge \\(q\\) : Affects direction (sign) and magnitude of motion Mass \\(m\\) : Heavier particles move slower, larger radius Real-world example: $$ r_L = \\frac{mv}{|q|B}, \\quad \\omega_c = \\frac{|q|B}{m} $$ 4. Visualization Visualizing charged particle trajectories under the Lorentz force helps build intuition about their motion in different electromagnetic fields. Using Python, we generate labeled 2D and 3D plots to illustrate key features like: Larmor radius \\(r_L\\) Helical pitch (spiral spacing along field lines) Drift velocity \\(\\mathbf{v}_\\text{drift} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2}\\) 4.1 Circular Trajectory \u2013 Uniform Magnetic Field Only The particle starts with velocity perpendicular to $ \\mathbf{B} $, resulting in cyclotron motion. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Parameters q, m = 1.0, 1.0 B = np.array([0, 0, 1.0]) v0 = np.array([1.0, 0.0, 0.0]) r0 = np.array([0.0, 0.0, 0.0]) dt, T = 0.01, 10 N = int(T / dt) # Calculate trajectory r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * np.cross(v[i], B) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Create animation fig, ax = plt.subplots() ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) ax.set_aspect('equal') line, = ax.plot([], [], lw=2) point, = ax.plot([], [], 'ro') def update(i): line.set_data(r[:i + 1, 0], r[:i + 1, 1]) # Trajectory line point.set_data([r[i, 0]], [r[i, 1]]) # Current point (wrapped in lists) return line, point # Create animation ani = FuncAnimation(fig, update, frames=N - 1, interval=30, blit=True) # Display animation inline in Jupyter Notebook plt.title(\"Circular Motion in xy-plane (Animated)\") plt.xlabel('x') plt.ylabel('y') # plt.grid(True) # plt.show() # Save animation as GIF gif_path = 'circular_motion.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html) Analytical vs Simulated Radius The Larmor radius is given by: $$ r_L = \\frac{mv_\\perp}{|q|B} $$ Using $ m = 1\\,\\text{g} = 0.001\\,\\text{kg} $, $ v = 1\\,\\text{m/s} $, $ B = 1\\,\\text{T} $, we get: \\[ r_L = \\frac{0.001 \\cdot 1}{1 \\cdot 1} = 0.001\\,\\text{m} = 1\\,\\text{mm} \\] This matches the observed radius in the simulation, confirming accuracy. 4.2 Helical Trajectory \u2013 Combined $ \\mathbf{v} \\parallel $ and $\\mathbf{v} \\perp $ to $ \\mathbf{B} $ The initial velocity has components both parallel and perpendicular to the magnetic field, producing a spiral along the field line. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation from IPython.display import HTML import base64 from io import BytesIO # Parameters q, m = 1.0, 1.0 B = np.array([0, 0, 1.0]) v0 = np.array([1.0, 0.0, 0.5]) # Initial velocity with z-component for helical motion r0 = np.array([0.0, 0.0, 0.0]) dt, T = 0.01, 10 N = int(T / dt) # Calculate trajectory r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * np.cross(v[i], B) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Create 3D animation fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) ax.set_zlim(0, 6) line, = ax.plot([], [], [], lw=2) point, = ax.plot([], [], [], 'ro') def update_3d(i): # Update line (trajectory) line.set_data(r[:i, 0], r[:i, 1]) line.set_3d_properties(r[:i, 2]) # Update point (current position) point.set_data([r[i, 0]], [r[i, 1]]) # Wrap in lists to provide sequences point.set_3d_properties([r[i, 2]]) # Wrap in list to provide sequence return line, point # Create animation ani = FuncAnimation(fig, update_3d, frames=N - 1, interval=30, blit=False) # blit=False for 3D # Set plot labels and title ax.set_title(\"3D Helical Motion (Animated)\") ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') # Save animation as GIF gif_path = 'helical_motion.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html) 4.3 $ \\mathbf{E} \\times \\mathbf{B} $ Drift \u2013 Crossed Electric and Magnetic Fields In crossed fields, the particle spirals while drifting uniformly in a direction perpendicular to both fields. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML import base64 from io import BytesIO # Parameters q, m = 1.0, 1.0 E = np.array([1.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field r0 = np.array([0.0, 0.0, 0.0]) v0 = np.array([0.5, 0.0, 0.0]) # Initial velocity dt, T = 0.01, 10 N = int(T / dt) # Calculate trajectory r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * (E + np.cross(v[i], B)) # Lorentz force with E and B fields a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Calculate E \u00d7 B drift drift = np.cross(E, B) / np.dot(B, B) # Drift velocity: (E \u00d7 B) / |B|^2 # Create 2D animation fig, ax = plt.subplots() ax.set_xlim(0, 10) ax.set_ylim(-2, 2) ax.set_aspect('equal') line, = ax.plot([], [], lw=2, label='Trajectory') point, = ax.plot([], [], 'ro', label='Particle') drift_line, = ax.plot([], [], 'r--', label='Drift') def update_drift(i): # Update trajectory line line.set_data(r[:i, 0], r[:i, 1]) # Update particle position point.set_data([r[i, 0]], [r[i, 1]]) # Wrap in lists to provide sequences # Update drift line if i > 1: # Ensure enough points for linspace t = np.linspace(0, r[i, 0], 50) # Use fixed number of points for smoothness drift_y = drift[1] * t + r[0, 1] # Drift along y-axis drift_line.set_data(t, drift_y) else: drift_line.set_data([], []) # Empty data for initial frames return line, point, drift_line # Create animation ani = FuncAnimation(fig, update_drift, frames=N - 1, interval=30, blit=True) # Set plot labels, title, and legend plt.title(\"Drift Motion in Crossed E \u00d7 B Fields (Animated)\") plt.xlabel('x') plt.ylabel('y') plt.grid(True) plt.legend() # Save animation as GIF gif_path = 'drift_motion.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html) 4.4 High-Frequency Helical Trajectory \u2013 Extreme Charge-to-Mass Ratio To demonstrate how strong fields and light particles behave, we simulate a particle with high $ q/m $. The result is a very tight, fast spiral \u2014 often seen in high-energy plasma or cyclotron systems. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation from IPython.display import HTML import base64 from io import BytesIO # Crazy Parameters q, m = 10.0, 0.1 # Very high charge-to-mass ratio B = np.array([0, 0, 5.0]) # Strong magnetic field in z-direction v0 = np.array([5.0, 0.0, 0.1]) # High x velocity, small z component for tight helix r0 = np.array([0.0, 0.0, 0.0]) dt, T = 0.001, 5.0 # Small dt for smooth animation N = int(T / dt) # Initialize arrays r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 # Compute trajectory for i in range(N - 1): F = q * np.cross(v[i], B) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Create 3D animation fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.set_xlim(-3, 3) ax.set_ylim(-3, 3) ax.set_zlim(0, 5) ax.set_title(\"Crazy 3D Helical Motion\") ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') # Line with fading color colors = plt.cm.plasma(np.linspace(0, 1, N)) line, = ax.plot([], [], [], lw=2) point, = ax.plot([], [], [], 'ro') # Current position # Plot fading trail manually with segments def update_3d(i): ax.clear() ax.set_xlim(-3, 3) ax.set_ylim(-3, 3) ax.set_zlim(0, 5) ax.set_title(\"Crazy 3D Helical Motion\") ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') # Plot color-fading segments step = max(1, i // 200) for j in range(0, i - 1, step): ax.plot(r[j:j+2, 0], r[j:j+2, 1], r[j:j+2, 2], color=colors[j], lw=1) # Red dot for current position ax.plot([r[i, 0]], [r[i, 1]], [r[i, 2]], 'ro') return [] # Animate ani = FuncAnimation(fig, update_3d, frames=N, interval=20, blit=False) # Save as GIF gif_path = 'crazy_helical_motion_v2.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in notebook with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html) Colab: Electromagnetism Problem 1 Souce Code 5. Numerical Methods Summary Use Euler for simplicity. Prefer Boris or RK4 for accuracy and energy stability. Keep \\(\\Delta t\\) small enough to resolve cyclotron motion: $$ \\Delta t \\ll \\frac{2\\pi m}{|q|B} $$ 6. Conclusion This simulation project demonstrates how the Lorentz force governs charged particle motion under different electromagnetic field configurations. By adjusting parameters like velocity, mass, and field strengths, we observed key behaviors such as: - Circular motion in a uniform magnetic field, - Helical motion with velocity along $ \\mathbf{B} $, - Uniform drift in crossed $ \\mathbf{E} \\times \\mathbf{B} $ fields, - and extreme helical spirals in high-field environments. The animations and numerical results confirm theoretical predictions like the Larmor radius and drift velocity. This work also highlights the importance of choosing physically meaningful parameters to produce interpretable, scalable simulations.","title":"Problem 1 (Shorted)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1-shorted","text":"Simulating the Lorentz Force","title":"Problem 1 (Shorted)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-applications-of-the-lorentz-force","text":"The Lorentz force law, $$ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B}, $$ governs the dynamics of charged particles in electric ( \\(\\mathbf{E}\\) ) and magnetic ( \\(\\mathbf{B}\\) ) fields.","title":"1. Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#key-applications","text":"Particle Accelerators : Magnetic fields guide particles in circular paths; electric fields accelerate them. Mass Spectrometers : Different mass-to-charge ratios cause unique curvatures in magnetic fields. Plasma Confinement : Magnetic traps (e.g., tokamaks) confine charged plasma using helical motion. Field Setup Force Direction Resulting Motion \\(\\mathbf{E}\\) only Along \\(\\mathbf{E}\\) Linear acceleration \\(\\mathbf{B}\\) only Perpendicular to \\(\\mathbf{v}, \\mathbf{B}\\) Circular/helical motion \\(\\mathbf{E} \\perp \\mathbf{B}\\) Orthogonal force, causes drift Spiral with drift velocity","title":"Key Applications:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulating-particle-motion","text":"","title":"2. Simulating Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#governing-equation","text":"\\[ m\\frac{d\\mathbf{v}}{dt} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\]","title":"Governing Equation:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#methods","text":"Euler Method : Simple but less accurate for oscillatory systems. Boris Algorithm : Preserves energy in magnetic fields. Runge-Kutta (RK4) : Offers high accuracy at greater computational cost.","title":"Methods:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motion-types","text":"Circular : \\(\\mathbf{v} \\perp \\mathbf{B}\\) , no \\(\\mathbf{E}\\) . Helical : \\(\\mathbf{v}\\) has parallel and perpendicular components to \\(\\mathbf{B}\\) . Drift : \\(\\mathbf{E} \\perp \\mathbf{B}\\) causes uniform drift: $$ \\mathbf{v}_\\text{drift} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$","title":"Motion Types:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-parameter-exploration","text":"Simulation results depend on: Field Strengths : \\(E \\rightarrow\\) linear acceleration \\(B \\rightarrow\\) tighter curvature, smaller Larmor radius Initial Velocity : Perpendicular component: affects orbit size Parallel component: affects pitch of helical motion Charge \\(q\\) : Affects direction (sign) and magnitude of motion Mass \\(m\\) : Heavier particles move slower, larger radius Real-world example: $$ r_L = \\frac{mv}{|q|B}, \\quad \\omega_c = \\frac{|q|B}{m} $$","title":"3. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-visualization","text":"Visualizing charged particle trajectories under the Lorentz force helps build intuition about their motion in different electromagnetic fields. Using Python, we generate labeled 2D and 3D plots to illustrate key features like: Larmor radius \\(r_L\\) Helical pitch (spiral spacing along field lines) Drift velocity \\(\\mathbf{v}_\\text{drift} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2}\\)","title":"4. Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#41-circular-trajectory-uniform-magnetic-field-only","text":"The particle starts with velocity perpendicular to $ \\mathbf{B} $, resulting in cyclotron motion. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Parameters q, m = 1.0, 1.0 B = np.array([0, 0, 1.0]) v0 = np.array([1.0, 0.0, 0.0]) r0 = np.array([0.0, 0.0, 0.0]) dt, T = 0.01, 10 N = int(T / dt) # Calculate trajectory r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * np.cross(v[i], B) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Create animation fig, ax = plt.subplots() ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) ax.set_aspect('equal') line, = ax.plot([], [], lw=2) point, = ax.plot([], [], 'ro') def update(i): line.set_data(r[:i + 1, 0], r[:i + 1, 1]) # Trajectory line point.set_data([r[i, 0]], [r[i, 1]]) # Current point (wrapped in lists) return line, point # Create animation ani = FuncAnimation(fig, update, frames=N - 1, interval=30, blit=True) # Display animation inline in Jupyter Notebook plt.title(\"Circular Motion in xy-plane (Animated)\") plt.xlabel('x') plt.ylabel('y') # plt.grid(True) # plt.show() # Save animation as GIF gif_path = 'circular_motion.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html)","title":"4.1 Circular Trajectory \u2013 Uniform Magnetic Field Only"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#analytical-vs-simulated-radius","text":"The Larmor radius is given by: $$ r_L = \\frac{mv_\\perp}{|q|B} $$ Using $ m = 1\\,\\text{g} = 0.001\\,\\text{kg} $, $ v = 1\\,\\text{m/s} $, $ B = 1\\,\\text{T} $, we get: \\[ r_L = \\frac{0.001 \\cdot 1}{1 \\cdot 1} = 0.001\\,\\text{m} = 1\\,\\text{mm} \\] This matches the observed radius in the simulation, confirming accuracy.","title":"Analytical vs Simulated Radius"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#42-helical-trajectory-combined-mathbfvparallel-and-mathbfvperp-to-mathbfb","text":"The initial velocity has components both parallel and perpendicular to the magnetic field, producing a spiral along the field line. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation from IPython.display import HTML import base64 from io import BytesIO # Parameters q, m = 1.0, 1.0 B = np.array([0, 0, 1.0]) v0 = np.array([1.0, 0.0, 0.5]) # Initial velocity with z-component for helical motion r0 = np.array([0.0, 0.0, 0.0]) dt, T = 0.01, 10 N = int(T / dt) # Calculate trajectory r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * np.cross(v[i], B) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Create 3D animation fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) ax.set_zlim(0, 6) line, = ax.plot([], [], [], lw=2) point, = ax.plot([], [], [], 'ro') def update_3d(i): # Update line (trajectory) line.set_data(r[:i, 0], r[:i, 1]) line.set_3d_properties(r[:i, 2]) # Update point (current position) point.set_data([r[i, 0]], [r[i, 1]]) # Wrap in lists to provide sequences point.set_3d_properties([r[i, 2]]) # Wrap in list to provide sequence return line, point # Create animation ani = FuncAnimation(fig, update_3d, frames=N - 1, interval=30, blit=False) # blit=False for 3D # Set plot labels and title ax.set_title(\"3D Helical Motion (Animated)\") ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') # Save animation as GIF gif_path = 'helical_motion.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html)","title":"4.2 Helical Trajectory \u2013 Combined $ \\mathbf{v}\\parallel $ and $\\mathbf{v}\\perp $ to $ \\mathbf{B} $"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#43-mathbfe-times-mathbfb-drift-crossed-electric-and-magnetic-fields","text":"In crossed fields, the particle spirals while drifting uniformly in a direction perpendicular to both fields. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML import base64 from io import BytesIO # Parameters q, m = 1.0, 1.0 E = np.array([1.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field r0 = np.array([0.0, 0.0, 0.0]) v0 = np.array([0.5, 0.0, 0.0]) # Initial velocity dt, T = 0.01, 10 N = int(T / dt) # Calculate trajectory r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * (E + np.cross(v[i], B)) # Lorentz force with E and B fields a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Calculate E \u00d7 B drift drift = np.cross(E, B) / np.dot(B, B) # Drift velocity: (E \u00d7 B) / |B|^2 # Create 2D animation fig, ax = plt.subplots() ax.set_xlim(0, 10) ax.set_ylim(-2, 2) ax.set_aspect('equal') line, = ax.plot([], [], lw=2, label='Trajectory') point, = ax.plot([], [], 'ro', label='Particle') drift_line, = ax.plot([], [], 'r--', label='Drift') def update_drift(i): # Update trajectory line line.set_data(r[:i, 0], r[:i, 1]) # Update particle position point.set_data([r[i, 0]], [r[i, 1]]) # Wrap in lists to provide sequences # Update drift line if i > 1: # Ensure enough points for linspace t = np.linspace(0, r[i, 0], 50) # Use fixed number of points for smoothness drift_y = drift[1] * t + r[0, 1] # Drift along y-axis drift_line.set_data(t, drift_y) else: drift_line.set_data([], []) # Empty data for initial frames return line, point, drift_line # Create animation ani = FuncAnimation(fig, update_drift, frames=N - 1, interval=30, blit=True) # Set plot labels, title, and legend plt.title(\"Drift Motion in Crossed E \u00d7 B Fields (Animated)\") plt.xlabel('x') plt.ylabel('y') plt.grid(True) plt.legend() # Save animation as GIF gif_path = 'drift_motion.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html)","title":"4.3 $ \\mathbf{E} \\times \\mathbf{B} $ Drift \u2013 Crossed Electric and Magnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#44-high-frequency-helical-trajectory-extreme-charge-to-mass-ratio","text":"To demonstrate how strong fields and light particles behave, we simulate a particle with high $ q/m $. The result is a very tight, fast spiral \u2014 often seen in high-energy plasma or cyclotron systems. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation from IPython.display import HTML import base64 from io import BytesIO # Crazy Parameters q, m = 10.0, 0.1 # Very high charge-to-mass ratio B = np.array([0, 0, 5.0]) # Strong magnetic field in z-direction v0 = np.array([5.0, 0.0, 0.1]) # High x velocity, small z component for tight helix r0 = np.array([0.0, 0.0, 0.0]) dt, T = 0.001, 5.0 # Small dt for smooth animation N = int(T / dt) # Initialize arrays r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 # Compute trajectory for i in range(N - 1): F = q * np.cross(v[i], B) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # Create 3D animation fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.set_xlim(-3, 3) ax.set_ylim(-3, 3) ax.set_zlim(0, 5) ax.set_title(\"Crazy 3D Helical Motion\") ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') # Line with fading color colors = plt.cm.plasma(np.linspace(0, 1, N)) line, = ax.plot([], [], [], lw=2) point, = ax.plot([], [], [], 'ro') # Current position # Plot fading trail manually with segments def update_3d(i): ax.clear() ax.set_xlim(-3, 3) ax.set_ylim(-3, 3) ax.set_zlim(0, 5) ax.set_title(\"Crazy 3D Helical Motion\") ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') # Plot color-fading segments step = max(1, i // 200) for j in range(0, i - 1, step): ax.plot(r[j:j+2, 0], r[j:j+2, 1], r[j:j+2, 2], color=colors[j], lw=1) # Red dot for current position ax.plot([r[i, 0]], [r[i, 1]], [r[i, 2]], 'ro') return [] # Animate ani = FuncAnimation(fig, update_3d, frames=N, interval=20, blit=False) # Save as GIF gif_path = 'crazy_helical_motion_v2.gif' ani.save(gif_path, writer='pillow', fps=30) # Display GIF in notebook with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html)","title":"4.4 High-Frequency Helical Trajectory \u2013 Extreme Charge-to-Mass Ratio"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#colab-electromagnetism-problem-1","text":"Souce Code","title":"Colab: Electromagnetism Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-numerical-methods-summary","text":"Use Euler for simplicity. Prefer Boris or RK4 for accuracy and energy stability. Keep \\(\\Delta t\\) small enough to resolve cyclotron motion: $$ \\Delta t \\ll \\frac{2\\pi m}{|q|B} $$","title":"5. Numerical Methods Summary"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#6-conclusion","text":"This simulation project demonstrates how the Lorentz force governs charged particle motion under different electromagnetic field configurations. By adjusting parameters like velocity, mass, and field strengths, we observed key behaviors such as: - Circular motion in a uniform magnetic field, - Helical motion with velocity along $ \\mathbf{B} $, - Uniform drift in crossed $ \\mathbf{E} \\times \\mathbf{B} $ fields, - and extreme helical spirals in high-field environments. The animations and numerical results confirm theoretical predictions like the Larmor radius and drift velocity. This work also highlights the importance of choosing physically meaningful parameters to produce interpretable, scalable simulations.","title":"6. Conclusion"},{"location":"1%20Physics/5%20Circuits/Problem_1.1/","text":"Problem 1 1. Problem Overview 1.1 Introduction Compute the equivalent resistance \\(R\\_{\\text{eq}}\\) between two nodes in a resistor network, modeled as a weighted undirected graph \\(G = (V, E)\\) where edges represent resistors. Use Ohm\u2019s Law: \\(R\\_{\\text{eq}} = \\frac{V}{I}\\) . 1.2 Equivalent Resistance Basics Ohm\u2019s Law : \\(V = I \\cdot R\\) Series : \\(R\\_{\\text{eq}} = R\\_1 + R\\_2 + \\cdots + R\\_n\\) Parallel : \\(\\frac{1}{R\\_{\\text{eq}}} = \\sum \\frac{1}{R\\_i}\\) 1.3 Formal Statement Given graph \\(G\\) , START node \\(A\\) , and END node \\(B\\) , find \\(R\\_{\\text{eq}}(A, B)\\) . 1.4 Applications Useful in power systems, electronics, and network analysis; demonstrates links between circuit theory and graph theory. 2. Graph Representation Model circuit as an undirected, weighted graph with: Nodes = junctions Edges = resistors, with weights \\(R\\_{uv}\\) Support formats include adjacency and resistance matrices. Graphs help in detecting simplifications like series and parallel connections. 3. Input Structure Input defines: Nodes list Edge list as tuples: \\((u, v, R\\_{uv})\\) Start and end nodes Edge representations and formats enable algorithmic simplification. 4. Series and Parallel Detection Key for simplification: Series : Two edges in line through a node with degree 2 (not start/end) Parallel : Multiple edges between same nodes Apply recursively until no more simplifications. 5. Resistance Computation Use Ohm\u2019s Law: \\(R = \\frac{V}{I}\\) . Node Voltage Method : Solve linear system using KCL. Laplacian Method : Use matrix pseudoinverse to find resistance. 6. Complex Network Reduction For complex circuits: Apply recursive reduction , node elimination , or Y-\u0394 transforms Use matrix methods for numerical and symbolic solutions 7. Resistance Computation (Final Step) Once simplified, compute \\(R\\_{\\text{eq}}\\) : Simple case : Apply direct formulas General case : Use node voltage or Laplacian methods 8. Plot and Visualization Circuit simplification Case 1 import networkx as nx import matplotlib.pyplot as plt import os from PIL import Image from IPython.display import HTML import base64 # Step directory folder_name = \"case_1\" os.makedirs(folder_name, exist_ok=True) # Base position layout (same throughout) base_pos = { \"B+\": (0, 1), \"R2\": (1, 1.5), \"R3\": (2, 1.5), \"R4\": (3, 1), \"R5\": (4, 1), \"B-\": (5, 1), \"R1\": (1.5, 0.3) } # Function to draw and save a step def draw_step(G, pos, title, highlight=[], merged_labels={}, filename=\"step.png\"): plt.figure(figsize=(7, 3)) # Colors for nodes colors = [] for node in G.nodes(): if node in highlight: colors.append(\"red\" if \"1\" in node or \"2\" in node or \"3\" in node or \"23\" in node else \"green\" if \"4\" in node or \"5\" in node or \"45\" in node else \"cyan\" if \"123\" in node else \"magenta\") else: colors.append(\"lightgray\") # Labels labels = {n: merged_labels.get(n, n) for n in G.nodes()} nx.draw_networkx_nodes(G, pos, node_color=colors, node_size=1200, node_shape='s', edgecolors='black') nx.draw_networkx_labels(G, pos, labels=labels, font_size=10, font_weight=\"bold\") nx.draw_networkx_edges(G, pos, edge_color=\"gray\", arrows=True, arrowsize=15, width=2) plt.title(title, fontsize=14, loc='left') plt.axis(\"off\") plt.tight_layout() plt.savefig(f\"{folder_name}/{filename}\", dpi=100) plt.close() # Step 0 # Step 1: Initial circuit G1 = nx.DiGraph() G1.add_edges_from([ (\"B+\", \"R2\"), (\"R2\", \"R3\"), (\"R3\", \"R4\"), (\"R4\", \"R5\"), (\"R5\", \"B-\"), (\"B+\", \"R1\"), (\"R1\", \"R4\") ]) draw_step(G1, base_pos, \"Initial circuit\", highlight=[], filename=\"step_0.png\") # Step 1: Initial circuit G1 = nx.DiGraph() G1.add_edges_from([ (\"B+\", \"R2\"), (\"R2\", \"R3\"), (\"R3\", \"R4\"), (\"R4\", \"R5\"), (\"R5\", \"B-\"), (\"B+\", \"R1\"), (\"R1\", \"R4\") ]) draw_step(G1, base_pos, \"First step\", highlight=[\"R2\", \"R3\"], filename=\"step_1.1.png\") # Step 1: After combining R2 and R3 \u2192 R23 G2 = nx.DiGraph() G2.add_edges_from([ (\"B+\", \"R23\"), (\"R23\", \"R4\"), (\"R4\", \"R5\"), (\"R5\", \"B-\"), (\"B+\", \"R1\"), (\"R1\", \"R4\") ]) pos2 = base_pos.copy() pos2[\"R23\"] = ((base_pos[\"R2\"][0] + base_pos[\"R3\"][0]) / 2, base_pos[\"R2\"][1]) draw_step(G2, pos2, \"First step\", highlight=[\"R23\"], merged_labels={\"R23\": \"R23\"}, filename=\"step_1.2.png\") # Step 2: Highlight R4 and R5 draw_step(G2, pos2, \"Second step\", highlight=[\"R4\", \"R5\"], filename=\"step_2.1.png\") # Step 2: Combine R4 + R5 \u2192 R45 G3 = nx.DiGraph() G3.add_edges_from([ (\"B+\", \"R23\"), (\"R23\", \"R45\"), (\"R45\", \"B-\"), (\"B+\", \"R1\"), (\"R1\", \"R45\") ]) pos3 = pos2.copy() pos3[\"R45\"] = ((base_pos[\"R4\"][0] + base_pos[\"R5\"][0]) / 2, base_pos[\"R4\"][1]) draw_step(G3, pos3, \"Second step\", highlight=[\"R45\"], merged_labels={\"R45\": \"R45\"}, filename=\"step_2.2.png\") # Step 3: Highlight R1 and R23 draw_step(G3, pos3, \"Third step\", highlight=[\"R1\", \"R23\"], filename=\"step_3.1.png\") # Step 3: Combine R1 \u2016 R23 \u2192 R123 G4 = nx.DiGraph() G4.add_edges_from([ (\"B+\", \"R123\"), (\"R123\", \"R45\"), (\"R45\", \"B-\") ]) pos4 = pos3.copy() pos4[\"R123\"] = ((base_pos[\"R1\"][0] + pos2[\"R23\"][0]) / 2, 1.1) draw_step(G4, pos4, \"Third step\", highlight=[\"R123\"], merged_labels={\"R123\": \"R123\"}, filename=\"step_3.2.png\") # Step 4: Highlight R123 and R45 draw_step(G4, pos4, \"Fourth step\", highlight=[\"R123\", \"R45\"], filename=\"step_4.1.png\") # Step 4: Combine R123 + R45 \u2192 R12345 G5 = nx.DiGraph() G5.add_edges_from([ (\"B+\", \"R12345\"), (\"R12345\", \"B-\") ]) pos5 = {\"B+\": (0, 1), \"R12345\": (2.5, 1), \"B-\": (5, 1)} draw_step(G5, pos5, \"Fourth step\", highlight=[\"R12345\"], merged_labels={\"R12345\": \"R12345\"}, filename=\"step_4.2.png\") # === Generate GIF from step images === image_files = sorted([f for f in os.listdir(\"case_1\") if f.endswith(\".png\")]) print(image_files) frames = [Image.open(os.path.join(folder_name, fname)) for fname in image_files] gif_path = \"case1_visual_simplification.gif\" frames[0].save(gif_path, save_all=True, append_images=frames[1:], duration=1200, loop=0) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html) Case 2 import networkx as nx import matplotlib.pyplot as plt # ----------------------------- # Function to draw nodes with different shapes # ----------------------------- def custom_draw(G, pos, title): plt.figure(figsize=(12, 4)) circle_nodes = [n for n in G.nodes if n.startswith(\"O\")] rounded_square_nodes = [\"B+\", \"B-\"] square_nodes = [n for n in G.nodes if n.startswith(\"R\")] # V\u1ebd c\u00e1c c\u1ea1nh v\u1edbi m\u0169i t\u00ean nx.draw_networkx_edges( G, pos, arrows=True, arrowstyle='->', arrowsize=20, connectionstyle='arc3,rad=0.0', min_target_margin=15, width=2 ) # V\u1ebd c\u00e1c node h\u00ecnh tr\u00f2n (O) nx.draw_networkx_nodes(G, pos, nodelist=circle_nodes, node_shape='o', node_color='lightgrey', node_size=1000) # Node B+ B- gi\u1ea3 l\u1eadp bo g\u00f3c b\u1eb1ng m\u00e0u tr\u1eafng + vi\u1ec1n \u0111\u1eadm nx.draw_networkx_nodes(G, pos, nodelist=rounded_square_nodes, node_shape='s', node_color='white', edgecolors='black', linewidths=2, node_size=1000) # Node \u0111i\u1ec7n tr\u1edf vu\u00f4ng nx.draw_networkx_nodes(G, pos, nodelist=square_nodes, node_shape='s', node_color='lightgrey', edgecolors='black', linewidths=1, node_size=1000) # V\u1ebd nh\u00e3n nx.draw_networkx_labels(G, pos) plt.title(title) plt.axis('off') plt.show() # ----------------------------- # Picture 1: Resistors as Nodes (Initial) # ----------------------------- G1 = nx.DiGraph() G1.add_edges_from([ (\"B+\", \"R1\"), (\"R1\", \"R2\"), (\"R1\", \"R3\"), (\"R2\", \"O1\"), (\"R3\", \"O1\"), (\"O1\", \"R4\"), (\"O1\", \"R5\"), (\"R4\", \"B-\"), (\"R5\", \"B-\"), ]) pos1 = { \"B+\": (-2, 0), \"R1\": (-1, 0), \"R2\": (0, 1), \"R3\": (0, -1), \"O1\": (1, 0), \"R4\": (2, 1), \"R5\": (2, -1), \"B-\": (3, 0), } custom_draw(G1, pos1, \"Resistors as Nodes (Initial)\") # ----------------------------- # Picture 2: Consistent Node Representation # ----------------------------- G2 = nx.DiGraph() G2.add_edges_from([ (\"B+\", \"O0\"), (\"O0\", \"R1\"), (\"R1\", \"O1\"), (\"O1\", \"R2\"), (\"O1\", \"R3\"), (\"R2\", \"O2\"), (\"R3\", \"O2\"), (\"O2\", \"R4\"), (\"O2\", \"R5\"), (\"R4\", \"O3\"), (\"R5\", \"O3\"), (\"O3\", \"B-\"), ]) pos2 = { \"B+\": (-3, 0), \"O0\": (-2, 0), \"R1\": (-1, 0), \"O1\": (0, 0), \"R2\": (1, 1), \"R3\": (1, -1), \"O2\": (2, 0), \"R4\": (3, 1), \"R5\": (3, -1), \"O3\": (4, 0), \"B-\": (5, 0), } custom_draw(G2, pos2, \"With Junction Nodes\") # ----------------------------- # Picture 3: Edge-Based Resistor Graph # ----------------------------- G3 = nx.DiGraph() G3.add_edges_from([ (\"B+\", \"O0\", {\"label\": \"\"}), (\"O0\", \"O1\", {\"label\": \"R1\"}), (\"O0\", \"O1\", {\"label\": \"R2\"}), (\"O1\", \"O2\", {\"label\": \"R3\"}), (\"O1\", \"O2\", {\"label\": \"R4\"}), (\"O2\", \"O3\", {\"label\": \"R5\"}), (\"O3\", \"B-\", {\"label\": \"\"}), ]) # V\u1ecb tr\u00ed node pos3 = { \"B+\": (-3, 0), \"O0\": (-2, 0), \"O1\": (-1, 0), \"O2\": (0, 0), \"O3\": (1, 0), \"B-\": (2, 0), } plt.figure(figsize=(12, 4)) # V\u1ebd B+ \u2192 O0 nx.draw_networkx_edges(G3, pos3, edgelist=[(\"B+\", \"O0\")], connectionstyle='arc3,rad=0.0', arrowstyle='->', arrowsize=20, width=2 ) # V\u1ebd R1 nx.draw_networkx_edges(G3, pos3, edgelist=[(\"O0\", \"O1\")], connectionstyle='arc3,rad=0.0', arrowstyle='->', arrowsize=20, width=2 ) # V\u1ebd R2: cong l\u00ean nx.draw_networkx_edges(G3, pos3, edgelist=[(\"O1\", \"O2\")], connectionstyle='arc3,rad=0.3', arrowstyle='->', arrowsize=20, width=2 ) # V\u1ebd R3: cong xu\u1ed1ng nx.draw_networkx_edges(G3, pos3, edgelist=[(\"O1\", \"O2\")], connectionstyle='arc3,rad=-0.3', arrowstyle='->', arrowsize=20, width=2 ) # V\u1ebd R4 v\u00e0 R5: h\u01a1i cong l\u00ean & xu\u1ed1ng nx.draw_networkx_edges(G3, pos3, edgelist=[(\"O2\", \"O3\")], connectionstyle='arc3,rad=0.3', arrowstyle='->', arrowsize=20, width=2 ) nx.draw_networkx_edges(G3, pos3, edgelist=[(\"O2\", \"O3\")], connectionstyle='arc3,rad=-0.3', arrowstyle='->', arrowsize=20, width=2 ) # V\u1ebd O3 \u2192 B- nx.draw_networkx_edges(G3, pos3, edgelist=[(\"O3\", \"B-\")], connectionstyle='arc3,rad=0.0', arrowstyle='->', arrowsize=20, width=2 ) # V\u1ebd node circle_nodes = [n for n in G3.nodes if n.startswith(\"O\")] rounded_square_nodes = [\"B+\", \"B-\"] nx.draw_networkx_nodes(G3, pos3, nodelist=circle_nodes, node_shape='o', node_color='lightgrey', node_size=1000) nx.draw_networkx_nodes(G3, pos3, nodelist=rounded_square_nodes, node_shape='s', node_color='white', edgecolors='black', linewidths=2, node_size=1000) # Nh\u00e3n node nx.draw_networkx_labels(G3, pos3) # Nh\u00e3n c\u1ea1nh edge_labels = { (\"O0\", \"O1\"): \"R1\", (\"O1\", \"O2\"): \"R2 / R3\", (\"O2\", \"O3\"): \"R4 / R5\", } nx.draw_networkx_edge_labels(G3, pos3, edge_labels=edge_labels) plt.title(\"Resistors as Edges\") plt.axis('off') plt.show() Initial Consistent Node Representation Edge-Based Resistor Graph Building blocks Series configuration import networkx as nx import matplotlib.pyplot as plt def draw_circuit(G, pos, title): plt.figure(figsize=(10, 5)) # Classify nodes circle_nodes = [n for n in G.nodes if n.startswith('o')] square_nodes = [n for n in G.nodes if n.startswith('I') or n.startswith('D') or n.startswith('R')] # Draw edges nx.draw_networkx_edges(G, pos, arrows=True) # Draw nodes with different shapes nx.draw_networkx_nodes( G, pos, nodelist=circle_nodes, node_color=[G.nodes[n].get('color', 'lightgrey') for n in circle_nodes], node_size=2000, node_shape='o' ) nx.draw_networkx_nodes( G, pos, nodelist=square_nodes, node_color=[G.nodes[n].get('color', 'lightgrey') for n in square_nodes], node_size=2000, node_shape='s' ) # Draw labels nx.draw_networkx_labels(G, pos, font_size=10) plt.title(title) plt.axis('off') plt.show() # First graph: Original circuit G1 = nx.DiGraph() inputs = [f\"I{i}\" for i in range(1, 4)] outputs = [f\"D{i}\" for i in range(1, 5)] # Add nodes and edges G1.add_node(\"o1\", color='lightgreen') G1.add_node(\"o2\", color='red') G1.add_node(\"o3\", color='lightgreen') G1.add_node(\"R1\") G1.add_node(\"R2\") for i in inputs: G1.add_edge(i, \"o1\") G1.add_edge(\"o1\", \"R1\") G1.add_edge(\"R1\", \"o2\") G1.add_edge(\"o2\", \"R2\") G1.add_edge(\"R2\", \"o3\") for d in outputs: G1.add_edge(\"o3\", d) # Positioning manually pos1 = { \"I1\": (-2, 1), \"I2\": (-2, 0), \"I3\": (-2, -1), \"o1\": (-1, 0), \"R1\": (0, 0), \"o2\": (1, 0), \"R2\": (2, 0), \"o3\": (3, 0), \"D1\": (4, 1), \"D2\": (4, 0.5), \"D3\": (4, -0.5), \"D4\": (4, -1) } draw_circuit(G1, pos1, \"Original Circuit\") # Second graph: Simplified circuit G2 = nx.DiGraph() G2.add_node(\"o1\", color='lightgreen') G2.add_node(\"o3\", color='lightgreen') G2.add_node(\"R12\") for i in inputs: G2.add_edge(i, \"o1\") G2.add_edge(\"o1\", \"R12\") G2.add_edge(\"R12\", \"o3\") for i in range(1, 6): # Assume m=5 for illustration G2.add_edge(\"o3\", f\"D{i}\") # Positioning manually pos2 = { \"I1\": (-2, 1), \"I2\": (-2, 0), \"I3\": (-2, -1), \"o1\": (-1, 0), \"R12\": (0, 0), \"o3\": (1, 0), \"D1\": (2, 1), \"D2\": (2, 0.5), \"D3\": (2, 0), \"D4\": (2, -0.5), \"D5\": (2, -1) } draw_circuit(G2, pos2, \"Simplified Circuit\") Can be replaced by Parallel configuration Can be replaced by Colab: Circuit Problem 1 Souce Code","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1.1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1.1/#1-problem-overview","text":"","title":"1. Problem Overview"},{"location":"1%20Physics/5%20Circuits/Problem_1.1/#11-introduction","text":"Compute the equivalent resistance \\(R\\_{\\text{eq}}\\) between two nodes in a resistor network, modeled as a weighted undirected graph \\(G = (V, E)\\) where edges represent resistors. Use Ohm\u2019s Law: \\(R\\_{\\text{eq}} = \\frac{V}{I}\\) .","title":"1.1 Introduction"},{"location":"1%20Physics/5%20Circuits/Problem_1.1/#12-equivalent-resistance-basics","text":"Ohm\u2019s Law : \\(V = I \\cdot R\\) Series : \\(R\\_{\\text{eq}} = R\\_1 + R\\_2 + \\cdots + R\\_n\\) Parallel : \\(\\frac{1}{R\\_{\\text{eq}}} = \\sum \\frac{1}{R\\_i}\\)","title":"1.2 Equivalent Resistance Basics"},{"location":"1%20Physics/5%20Circuits/Problem_1.1/#13-formal-statement","text":"Given graph \\(G\\) , START node \\(A\\) , and END node \\(B\\) , find \\(R\\_{\\text{eq}}(A, B)\\) .","title":"1.3 Formal Statement"},{"location":"1%20Physics/5%20Circuits/Problem_1.1/#14-applications","text":"Useful in power systems, electronics, and network analysis; demonstrates links between circuit theory and graph theory.","title":"1.4 Applications"},{"location":"1%20Physics/5%20Circuits/Problem_1.1/#2-graph-representation","text":"Model circuit as an undirected, weighted graph with: Nodes = junctions Edges = resistors, with weights \\(R\\_{uv}\\) Support formats include adjacency and resistance matrices. Graphs help in detecting simplifications like series and parallel connections.","title":"2. Graph Representation"},{"location":"1%20Physics/5%20Circuits/Problem_1.1/#3-input-structure","text":"Input defines: Nodes list Edge list as tuples: \\((u, v, R\\_{uv})\\) Start and end nodes Edge representations and formats enable algorithmic simplification.","title":"3. Input Structure"},{"location":"1%20Physics/5%20Circuits/Problem_1.1/#4-series-and-parallel-detection","text":"Key for simplification: Series : Two edges in line through a node with degree 2 (not start/end) Parallel : Multiple edges between same nodes Apply recursively until no more simplifications.","title":"4. Series and Parallel Detection"},{"location":"1%20Physics/5%20Circuits/Problem_1.1/#5-resistance-computation","text":"Use Ohm\u2019s Law: \\(R = \\frac{V}{I}\\) . Node Voltage Method : Solve linear system using KCL. Laplacian Method : Use matrix pseudoinverse to find resistance.","title":"5. Resistance Computation"},{"location":"1%20Physics/5%20Circuits/Problem_1.1/#6-complex-network-reduction","text":"For complex circuits: Apply recursive reduction , node elimination , or Y-\u0394 transforms Use matrix methods for numerical and symbolic solutions","title":"6. Complex Network Reduction"},{"location":"1%20Physics/5%20Circuits/Problem_1.1/#7-resistance-computation-final-step","text":"Once simplified, compute \\(R\\_{\\text{eq}}\\) : Simple case : Apply direct formulas General case : Use node voltage or Laplacian methods","title":"7. Resistance Computation (Final Step)"},{"location":"1%20Physics/5%20Circuits/Problem_1.1/#8-plot-and-visualization","text":"","title":"8. Plot and Visualization"},{"location":"1%20Physics/5%20Circuits/Problem_1.1/#circuit-simplification","text":"","title":"Circuit simplification"},{"location":"1%20Physics/5%20Circuits/Problem_1.1/#case-1","text":"import networkx as nx import matplotlib.pyplot as plt import os from PIL import Image from IPython.display import HTML import base64 # Step directory folder_name = \"case_1\" os.makedirs(folder_name, exist_ok=True) # Base position layout (same throughout) base_pos = { \"B+\": (0, 1), \"R2\": (1, 1.5), \"R3\": (2, 1.5), \"R4\": (3, 1), \"R5\": (4, 1), \"B-\": (5, 1), \"R1\": (1.5, 0.3) } # Function to draw and save a step def draw_step(G, pos, title, highlight=[], merged_labels={}, filename=\"step.png\"): plt.figure(figsize=(7, 3)) # Colors for nodes colors = [] for node in G.nodes(): if node in highlight: colors.append(\"red\" if \"1\" in node or \"2\" in node or \"3\" in node or \"23\" in node else \"green\" if \"4\" in node or \"5\" in node or \"45\" in node else \"cyan\" if \"123\" in node else \"magenta\") else: colors.append(\"lightgray\") # Labels labels = {n: merged_labels.get(n, n) for n in G.nodes()} nx.draw_networkx_nodes(G, pos, node_color=colors, node_size=1200, node_shape='s', edgecolors='black') nx.draw_networkx_labels(G, pos, labels=labels, font_size=10, font_weight=\"bold\") nx.draw_networkx_edges(G, pos, edge_color=\"gray\", arrows=True, arrowsize=15, width=2) plt.title(title, fontsize=14, loc='left') plt.axis(\"off\") plt.tight_layout() plt.savefig(f\"{folder_name}/{filename}\", dpi=100) plt.close() # Step 0 # Step 1: Initial circuit G1 = nx.DiGraph() G1.add_edges_from([ (\"B+\", \"R2\"), (\"R2\", \"R3\"), (\"R3\", \"R4\"), (\"R4\", \"R5\"), (\"R5\", \"B-\"), (\"B+\", \"R1\"), (\"R1\", \"R4\") ]) draw_step(G1, base_pos, \"Initial circuit\", highlight=[], filename=\"step_0.png\") # Step 1: Initial circuit G1 = nx.DiGraph() G1.add_edges_from([ (\"B+\", \"R2\"), (\"R2\", \"R3\"), (\"R3\", \"R4\"), (\"R4\", \"R5\"), (\"R5\", \"B-\"), (\"B+\", \"R1\"), (\"R1\", \"R4\") ]) draw_step(G1, base_pos, \"First step\", highlight=[\"R2\", \"R3\"], filename=\"step_1.1.png\") # Step 1: After combining R2 and R3 \u2192 R23 G2 = nx.DiGraph() G2.add_edges_from([ (\"B+\", \"R23\"), (\"R23\", \"R4\"), (\"R4\", \"R5\"), (\"R5\", \"B-\"), (\"B+\", \"R1\"), (\"R1\", \"R4\") ]) pos2 = base_pos.copy() pos2[\"R23\"] = ((base_pos[\"R2\"][0] + base_pos[\"R3\"][0]) / 2, base_pos[\"R2\"][1]) draw_step(G2, pos2, \"First step\", highlight=[\"R23\"], merged_labels={\"R23\": \"R23\"}, filename=\"step_1.2.png\") # Step 2: Highlight R4 and R5 draw_step(G2, pos2, \"Second step\", highlight=[\"R4\", \"R5\"], filename=\"step_2.1.png\") # Step 2: Combine R4 + R5 \u2192 R45 G3 = nx.DiGraph() G3.add_edges_from([ (\"B+\", \"R23\"), (\"R23\", \"R45\"), (\"R45\", \"B-\"), (\"B+\", \"R1\"), (\"R1\", \"R45\") ]) pos3 = pos2.copy() pos3[\"R45\"] = ((base_pos[\"R4\"][0] + base_pos[\"R5\"][0]) / 2, base_pos[\"R4\"][1]) draw_step(G3, pos3, \"Second step\", highlight=[\"R45\"], merged_labels={\"R45\": \"R45\"}, filename=\"step_2.2.png\") # Step 3: Highlight R1 and R23 draw_step(G3, pos3, \"Third step\", highlight=[\"R1\", \"R23\"], filename=\"step_3.1.png\") # Step 3: Combine R1 \u2016 R23 \u2192 R123 G4 = nx.DiGraph() G4.add_edges_from([ (\"B+\", \"R123\"), (\"R123\", \"R45\"), (\"R45\", \"B-\") ]) pos4 = pos3.copy() pos4[\"R123\"] = ((base_pos[\"R1\"][0] + pos2[\"R23\"][0]) / 2, 1.1) draw_step(G4, pos4, \"Third step\", highlight=[\"R123\"], merged_labels={\"R123\": \"R123\"}, filename=\"step_3.2.png\") # Step 4: Highlight R123 and R45 draw_step(G4, pos4, \"Fourth step\", highlight=[\"R123\", \"R45\"], filename=\"step_4.1.png\") # Step 4: Combine R123 + R45 \u2192 R12345 G5 = nx.DiGraph() G5.add_edges_from([ (\"B+\", \"R12345\"), (\"R12345\", \"B-\") ]) pos5 = {\"B+\": (0, 1), \"R12345\": (2.5, 1), \"B-\": (5, 1)} draw_step(G5, pos5, \"Fourth step\", highlight=[\"R12345\"], merged_labels={\"R12345\": \"R12345\"}, filename=\"step_4.2.png\") # === Generate GIF from step images === image_files = sorted([f for f in os.listdir(\"case_1\") if f.endswith(\".png\")]) print(image_files) frames = [Image.open(os.path.join(folder_name, fname)) for fname in image_files] gif_path = \"case1_visual_simplification.gif\" frames[0].save(gif_path, save_all=True, append_images=frames[1:], duration=1200, loop=0) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html)","title":"Case 1"},{"location":"1%20Physics/5%20Circuits/Problem_1.1/#case-2","text":"import networkx as nx import matplotlib.pyplot as plt # ----------------------------- # Function to draw nodes with different shapes # ----------------------------- def custom_draw(G, pos, title): plt.figure(figsize=(12, 4)) circle_nodes = [n for n in G.nodes if n.startswith(\"O\")] rounded_square_nodes = [\"B+\", \"B-\"] square_nodes = [n for n in G.nodes if n.startswith(\"R\")] # V\u1ebd c\u00e1c c\u1ea1nh v\u1edbi m\u0169i t\u00ean nx.draw_networkx_edges( G, pos, arrows=True, arrowstyle='->', arrowsize=20, connectionstyle='arc3,rad=0.0', min_target_margin=15, width=2 ) # V\u1ebd c\u00e1c node h\u00ecnh tr\u00f2n (O) nx.draw_networkx_nodes(G, pos, nodelist=circle_nodes, node_shape='o', node_color='lightgrey', node_size=1000) # Node B+ B- gi\u1ea3 l\u1eadp bo g\u00f3c b\u1eb1ng m\u00e0u tr\u1eafng + vi\u1ec1n \u0111\u1eadm nx.draw_networkx_nodes(G, pos, nodelist=rounded_square_nodes, node_shape='s', node_color='white', edgecolors='black', linewidths=2, node_size=1000) # Node \u0111i\u1ec7n tr\u1edf vu\u00f4ng nx.draw_networkx_nodes(G, pos, nodelist=square_nodes, node_shape='s', node_color='lightgrey', edgecolors='black', linewidths=1, node_size=1000) # V\u1ebd nh\u00e3n nx.draw_networkx_labels(G, pos) plt.title(title) plt.axis('off') plt.show() # ----------------------------- # Picture 1: Resistors as Nodes (Initial) # ----------------------------- G1 = nx.DiGraph() G1.add_edges_from([ (\"B+\", \"R1\"), (\"R1\", \"R2\"), (\"R1\", \"R3\"), (\"R2\", \"O1\"), (\"R3\", \"O1\"), (\"O1\", \"R4\"), (\"O1\", \"R5\"), (\"R4\", \"B-\"), (\"R5\", \"B-\"), ]) pos1 = { \"B+\": (-2, 0), \"R1\": (-1, 0), \"R2\": (0, 1), \"R3\": (0, -1), \"O1\": (1, 0), \"R4\": (2, 1), \"R5\": (2, -1), \"B-\": (3, 0), } custom_draw(G1, pos1, \"Resistors as Nodes (Initial)\") # ----------------------------- # Picture 2: Consistent Node Representation # ----------------------------- G2 = nx.DiGraph() G2.add_edges_from([ (\"B+\", \"O0\"), (\"O0\", \"R1\"), (\"R1\", \"O1\"), (\"O1\", \"R2\"), (\"O1\", \"R3\"), (\"R2\", \"O2\"), (\"R3\", \"O2\"), (\"O2\", \"R4\"), (\"O2\", \"R5\"), (\"R4\", \"O3\"), (\"R5\", \"O3\"), (\"O3\", \"B-\"), ]) pos2 = { \"B+\": (-3, 0), \"O0\": (-2, 0), \"R1\": (-1, 0), \"O1\": (0, 0), \"R2\": (1, 1), \"R3\": (1, -1), \"O2\": (2, 0), \"R4\": (3, 1), \"R5\": (3, -1), \"O3\": (4, 0), \"B-\": (5, 0), } custom_draw(G2, pos2, \"With Junction Nodes\") # ----------------------------- # Picture 3: Edge-Based Resistor Graph # ----------------------------- G3 = nx.DiGraph() G3.add_edges_from([ (\"B+\", \"O0\", {\"label\": \"\"}), (\"O0\", \"O1\", {\"label\": \"R1\"}), (\"O0\", \"O1\", {\"label\": \"R2\"}), (\"O1\", \"O2\", {\"label\": \"R3\"}), (\"O1\", \"O2\", {\"label\": \"R4\"}), (\"O2\", \"O3\", {\"label\": \"R5\"}), (\"O3\", \"B-\", {\"label\": \"\"}), ]) # V\u1ecb tr\u00ed node pos3 = { \"B+\": (-3, 0), \"O0\": (-2, 0), \"O1\": (-1, 0), \"O2\": (0, 0), \"O3\": (1, 0), \"B-\": (2, 0), } plt.figure(figsize=(12, 4)) # V\u1ebd B+ \u2192 O0 nx.draw_networkx_edges(G3, pos3, edgelist=[(\"B+\", \"O0\")], connectionstyle='arc3,rad=0.0', arrowstyle='->', arrowsize=20, width=2 ) # V\u1ebd R1 nx.draw_networkx_edges(G3, pos3, edgelist=[(\"O0\", \"O1\")], connectionstyle='arc3,rad=0.0', arrowstyle='->', arrowsize=20, width=2 ) # V\u1ebd R2: cong l\u00ean nx.draw_networkx_edges(G3, pos3, edgelist=[(\"O1\", \"O2\")], connectionstyle='arc3,rad=0.3', arrowstyle='->', arrowsize=20, width=2 ) # V\u1ebd R3: cong xu\u1ed1ng nx.draw_networkx_edges(G3, pos3, edgelist=[(\"O1\", \"O2\")], connectionstyle='arc3,rad=-0.3', arrowstyle='->', arrowsize=20, width=2 ) # V\u1ebd R4 v\u00e0 R5: h\u01a1i cong l\u00ean & xu\u1ed1ng nx.draw_networkx_edges(G3, pos3, edgelist=[(\"O2\", \"O3\")], connectionstyle='arc3,rad=0.3', arrowstyle='->', arrowsize=20, width=2 ) nx.draw_networkx_edges(G3, pos3, edgelist=[(\"O2\", \"O3\")], connectionstyle='arc3,rad=-0.3', arrowstyle='->', arrowsize=20, width=2 ) # V\u1ebd O3 \u2192 B- nx.draw_networkx_edges(G3, pos3, edgelist=[(\"O3\", \"B-\")], connectionstyle='arc3,rad=0.0', arrowstyle='->', arrowsize=20, width=2 ) # V\u1ebd node circle_nodes = [n for n in G3.nodes if n.startswith(\"O\")] rounded_square_nodes = [\"B+\", \"B-\"] nx.draw_networkx_nodes(G3, pos3, nodelist=circle_nodes, node_shape='o', node_color='lightgrey', node_size=1000) nx.draw_networkx_nodes(G3, pos3, nodelist=rounded_square_nodes, node_shape='s', node_color='white', edgecolors='black', linewidths=2, node_size=1000) # Nh\u00e3n node nx.draw_networkx_labels(G3, pos3) # Nh\u00e3n c\u1ea1nh edge_labels = { (\"O0\", \"O1\"): \"R1\", (\"O1\", \"O2\"): \"R2 / R3\", (\"O2\", \"O3\"): \"R4 / R5\", } nx.draw_networkx_edge_labels(G3, pos3, edge_labels=edge_labels) plt.title(\"Resistors as Edges\") plt.axis('off') plt.show() Initial Consistent Node Representation Edge-Based Resistor Graph","title":"Case 2"},{"location":"1%20Physics/5%20Circuits/Problem_1.1/#building-blocks","text":"","title":"Building blocks"},{"location":"1%20Physics/5%20Circuits/Problem_1.1/#series-configuration","text":"import networkx as nx import matplotlib.pyplot as plt def draw_circuit(G, pos, title): plt.figure(figsize=(10, 5)) # Classify nodes circle_nodes = [n for n in G.nodes if n.startswith('o')] square_nodes = [n for n in G.nodes if n.startswith('I') or n.startswith('D') or n.startswith('R')] # Draw edges nx.draw_networkx_edges(G, pos, arrows=True) # Draw nodes with different shapes nx.draw_networkx_nodes( G, pos, nodelist=circle_nodes, node_color=[G.nodes[n].get('color', 'lightgrey') for n in circle_nodes], node_size=2000, node_shape='o' ) nx.draw_networkx_nodes( G, pos, nodelist=square_nodes, node_color=[G.nodes[n].get('color', 'lightgrey') for n in square_nodes], node_size=2000, node_shape='s' ) # Draw labels nx.draw_networkx_labels(G, pos, font_size=10) plt.title(title) plt.axis('off') plt.show() # First graph: Original circuit G1 = nx.DiGraph() inputs = [f\"I{i}\" for i in range(1, 4)] outputs = [f\"D{i}\" for i in range(1, 5)] # Add nodes and edges G1.add_node(\"o1\", color='lightgreen') G1.add_node(\"o2\", color='red') G1.add_node(\"o3\", color='lightgreen') G1.add_node(\"R1\") G1.add_node(\"R2\") for i in inputs: G1.add_edge(i, \"o1\") G1.add_edge(\"o1\", \"R1\") G1.add_edge(\"R1\", \"o2\") G1.add_edge(\"o2\", \"R2\") G1.add_edge(\"R2\", \"o3\") for d in outputs: G1.add_edge(\"o3\", d) # Positioning manually pos1 = { \"I1\": (-2, 1), \"I2\": (-2, 0), \"I3\": (-2, -1), \"o1\": (-1, 0), \"R1\": (0, 0), \"o2\": (1, 0), \"R2\": (2, 0), \"o3\": (3, 0), \"D1\": (4, 1), \"D2\": (4, 0.5), \"D3\": (4, -0.5), \"D4\": (4, -1) } draw_circuit(G1, pos1, \"Original Circuit\") # Second graph: Simplified circuit G2 = nx.DiGraph() G2.add_node(\"o1\", color='lightgreen') G2.add_node(\"o3\", color='lightgreen') G2.add_node(\"R12\") for i in inputs: G2.add_edge(i, \"o1\") G2.add_edge(\"o1\", \"R12\") G2.add_edge(\"R12\", \"o3\") for i in range(1, 6): # Assume m=5 for illustration G2.add_edge(\"o3\", f\"D{i}\") # Positioning manually pos2 = { \"I1\": (-2, 1), \"I2\": (-2, 0), \"I3\": (-2, -1), \"o1\": (-1, 0), \"R12\": (0, 0), \"o3\": (1, 0), \"D1\": (2, 1), \"D2\": (2, 0.5), \"D3\": (2, 0), \"D4\": (2, -0.5), \"D5\": (2, -1) } draw_circuit(G2, pos2, \"Simplified Circuit\") Can be replaced by","title":"Series configuration"},{"location":"1%20Physics/5%20Circuits/Problem_1.1/#parallel-configuration","text":"Can be replaced by","title":"Parallel configuration"},{"location":"1%20Physics/5%20Circuits/Problem_1.1/#colab-circuit-problem-1","text":"Souce Code","title":"Colab: Circuit Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 1. Problem Overview 1.1 Introduction The objective is to compute the equivalent resistance \\(R_{\\text{eq}}\\) between two designated points in an electrical network: a START node and an END node . This is a foundational problem in circuit theory, as it enables the prediction of current flow, voltage drops, and power dissipation. We model the resistor network as a weighted undirected graph \\(G = (V, E)\\) , where: - \\(V\\) is the set of nodes (electrical junctions), - \\(E\\) is the set of edges (resistors), - Each edge \\(e = (u, v) \\in E\\) has an associated resistance \\(R_{uv} > 0\\) . The central task is to determine \\(R_{\\text{eq}}(A, B)\\) , the effective resistance between a START node \\(A \\in V\\) and an END node \\(B \\in V\\) . If a voltage source \\(V\\) were connected across \\(A\\) and \\(B\\) , the current \\(I\\) flowing through the network would satisfy Ohm\u2019s Law: \\[ R_{\\text{eq}} = \\frac{V}{I} \\] 1.2 Equivalent Resistance: Conceptual Basis 1.2.1 Ohm\u2019s Law For any two-terminal resistive element: \\[ V = I \\cdot R \\] where: - \\(V\\) is the potential difference (volts), - \\(I\\) is the current (amperes), - \\(R\\) is the resistance (ohms, \\(\\Omega\\) ). 1.2.2 Series Configuration For resistors in series: \\[ R_{\\text{eq}} = R_1 + R_2 + \\cdots + R_n \\] This applies when the same current flows through each resistor without branching paths. 1.2.3 Parallel Configuration For resistors in parallel: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\cdots + \\frac{1}{R_n} \\] This configuration implies the voltage across each resistor is the same, while the current divides among the paths. 1.3 Formal Problem Statement Given: - A graph \\(G = (V, E)\\) with \\(R_e > 0\\) for all \\(e \\in E\\) , - A specified START node \\(A \\in V\\) , - A specified END node \\(B \\in V\\) , Find: the equivalent resistance \\(R_{\\text{eq}}(A, B)\\) between nodes \\(A\\) and \\(B\\) , as if the network were replaced by a single equivalent resistor. 1.4 Applications and Implications Accurate computation of \\(R_{\\text{eq}}\\) has applications in: - Power grid analysis, - Signal integrity assessment in microelectronics, - Fault tolerance in communication networks, - Optimization of low-power and efficient designs. Additionally, this problem demonstrates the synergy between electrical engineering and graph theory , showcasing the power of algorithmic thinking in physical systems. 2. Graph Representation 2.1 Motivation To analyze electrical circuits algorithmically, we need a mathematical abstraction that captures the topology and resistance values of the network. Graph theory provides a natural framework for modeling circuits, where nodes correspond to electrical junctions and edges represent resistive elements. This abstraction enables the application of graph algorithms to simplify and solve complex networks, particularly when identifying series and parallel connections, or computing resistance between arbitrary nodes. 2.2 Graph Model We model a resistor network as an undirected, weighted graph : \\[ G = (V, E, R) \\] where: - \\(V\\) is a set of nodes (or vertices ) representing circuit junctions, - \\(E \\subseteq \\{ \\{u, v\\} \\mid u, v \\in V, u \\neq v \\}\\) is a set of edges representing resistors, - \\(R: E \\rightarrow \\mathbb{R}^+\\) is a function assigning a resistance value \\(R_{uv}\\) to each edge \\(e = \\{u, v\\}\\) . Each resistor is treated as a symmetric component: the resistance between \\(u\\) and \\(v\\) is the same regardless of current direction. 2.3 Edge Representation Each edge (resistor) can be described as a tuple: \\[ (u, v, R_{uv}) \\] where: - \\(u, v \\in V\\) are the connected nodes, - \\(R_{uv} \\in \\mathbb{R}^+\\) is the resistance in ohms \\((\\Omega)\\) . For example, a resistor of \\(5\\,\\Omega\\) between node 1 and node 3 is represented as: \\[ (1, 3, 5) \\] Multiple resistors between the same pair of nodes are treated as parallel resistors and must be aggregated accordingly: \\[ \\frac{1}{R_{\\text{eq}}} = \\sum_{i=1}^{n} \\frac{1}{R_i} \\] 2.4 Adjacency and Resistance Matrix Representations The graph can be represented in matrix form to facilitate algorithmic manipulation: Adjacency Matrix \\(A\\) : A symmetric \\(|V| \\times |V|\\) matrix with entries: $$ A_{uv} = \\begin{cases} 1 & \\text{if } {u, v} \\in E \\ 0 & \\text{otherwise} \\end{cases} $$ Resistance Matrix \\(R\\) : A weighted matrix storing resistance values: $$ R_{uv} = \\begin{cases} R_{uv} & \\text{if } {u, v} \\in E \\ \\infty & \\text{otherwise} \\end{cases} $$ These representations are useful for implementing resistance-reduction algorithms and simulations. 2.5 Visualization Example Consider a simple triangular network with nodes \\(A\\) , \\(B\\) , and \\(C\\) , and resistors between each pair: \\((A, B, 2\\,\\Omega)\\) \\((B, C, 3\\,\\Omega)\\) \\((A, C, 4\\,\\Omega)\\) This network can be visualized as a triangle graph, and the total resistance between any two nodes can be computed using the parallel and series reduction rules based on the graph structure. 2.6 Benefits of Graph-Based Representation Enables recursive simplification. Facilitates cycle detection and transformation (e.g., \u0394-Y transforms). Prepares the circuit for numerical or symbolic computation. Unifies the treatment of arbitrary and complex topologies. 3. Input Structure 3.1 Purpose To perform automated or algorithmic analysis of circuits, we must establish a precise and unambiguous format for inputting the resistor network. This input captures both the topology of the network (i.e., how nodes are connected) and the numerical values of resistances. 3.2 Input Components The input consists of three essential components: Node Set : A list of all nodes in the circuit. Edge List : Each edge is a resistor defined by a pair of nodes and a resistance value. Start and End Nodes : Two nodes \\(A\\) and \\(B\\) between which the equivalent resistance is to be computed. 3.3 Edge Format Each resistor is represented as a tuple: \\[ (u, v, R_{uv}) \\in V \\times V \\times \\mathbb{R}^+ \\] where: - \\(u\\) and \\(v\\) are node identifiers, - \\(R_{uv}\\) is the resistance in ohms \\((\\Omega)\\) between \\(u\\) and \\(v\\) . For example, the following list of edges defines a small network: (1, 2, 10) (2, 3, 5) (1, 3, 20) This specifies resistors of \\(10\\Omega\\) , \\(5\\Omega\\) , and \\(20\\Omega\\) respectively between the indicated node pairs. 3.4 Input as Data Structure In programming terms, the input could be stored as a list of dictionaries or tuples. Example in Python-like pseudocode: edges = [ (1, 2, 10), (2, 3, 5), (1, 3, 20) ] start_node = 1 end_node = 3 3.5 Graph Construction From the edge list, we construct a graph \\(G = (V, E)\\) : The set of vertices \\(V\\) is the union of all nodes that appear in any edge. The set of edges \\(E\\) is directly derived from the input tuples. A mapping function \\(R: E \\rightarrow \\mathbb{R}^+\\) is defined such that: \\[ R(\\{u, v\\}) = R_{uv} \\] If multiple resistors exist between the same node pair (i.e., parallel resistors), their combined resistance is computed before storing: \\[ \\frac{1}{R_{\\text{eq}}(u, v)} = \\sum_{i=1}^{n} \\frac{1}{R_i} \\] 3.6 Special Cases Duplicate edges : Combine them using the parallel resistance formula. Self-loops : Resistors connecting a node to itself are typically ignored unless explicitly meaningful. Isolated nodes : Nodes not connected to either the start or end can be pruned. 3.7 Summary The input format should: Be compact and readable. Allow for easy graph construction. Support preprocessing for simplification (e.g., merging parallels). Clearly specify the two terminal nodes of interest: START ( \\(A\\) ) and END ( \\(B\\) ). 4. Series and Parallel Detection 4.1 Motivation To simplify a resistor network, we must identify series and parallel substructures within the graph. These structures allow the replacement of multiple resistors with a single equivalent resistor, thereby reducing circuit complexity and enabling easier computation of \\(R_{\\text{eq}}\\) between the START and END nodes. Automated detection of these configurations is crucial for algorithmic analysis, particularly when dealing with arbitrary and nested resistor arrangements. 4.2 Series Configuration Two resistors are in series if: - They are connected end-to-end , i.e., one resistor's endpoint is the other's start point. - The shared node does not connect to any other component (i.e., has degree 2). - The same current flows through both. 4.2.1 Detection Rule Given three nodes \\(u\\) , \\(v\\) , and \\(w\\) , if the following conditions hold: - \\((u, v) \\in E\\) and \\((v, w) \\in E\\) , - \\(\\deg(v) = 2\\) , - \\(v \\neq \\text{START}\\) and \\(v \\neq \\text{END}\\) , then the resistors \\(R_{uv}\\) and \\(R_{vw}\\) can be combined in series: \\[ R_{\\text{eq}}(u, w) = R_{uv} + R_{vw} \\] The graph is updated by: - Removing node \\(v\\) , - Adding edge \\((u, w)\\) with weight \\(R_{\\text{eq}}(u, w)\\) . 4.3 Parallel Configuration Two or more resistors are in parallel if: - They connect the same two nodes , - Each provides an independent path for current between those nodes. 4.3.1 Detection Rule If multiple edges exist between the same node pair \\((u, v)\\) : - \\(\\exists \\{R_1, R_2, \\dots, R_n\\}\\) connecting \\(u\\) and \\(v\\) , - Replace them with a single equivalent resistor: \\[ \\frac{1}{R_{\\text{eq}}(u, v)} = \\sum_{i=1}^{n} \\frac{1}{R_i} \\] The graph is updated by: - Removing all parallel edges, - Adding one edge \\((u, v)\\) with the combined resistance \\(R_{\\text{eq}}\\) . 4.4 General Algorithm Strategy Repeat the following until no further simplification is possible: 1. Scan all nodes for degree-2 series candidates. 2. Collapse series connections using the rule in Section 4.2. 3. Detect and merge all parallel resistors using the rule in Section 4.3. 4. Update the graph structure accordingly. This recursive simplification reduces the graph step-by-step while preserving the electrical behavior between the START and END nodes. 4.5 Handling Nested Structures Series and parallel simplifications can be nested or interleaved , such as: A parallel branch that itself contains series resistors. A series connection where one element is a group of parallel resistors. The algorithm must support recursive detection: - Flatten inner structures before processing outer ones. - Traverse the graph hierarchically or use pattern recognition for subgraphs. 4.6 Example Given the network: \\((1, 2, 3\\,\\Omega)\\) \\((2, 3, 5\\,\\Omega)\\) \\((1, 3, 10\\,\\Omega)\\) Resistors \\((1, 2)\\) and \\((2, 3)\\) are in series : $$ R_{\\text{series}} = 3 + 5 = 8\\,\\Omega $$ Then, the 8\u2009\u03a9 resistor and the existing 10\u2009\u03a9 between \\((1, 3)\\) are in parallel : $$ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{8} + \\frac{1}{10} = \\frac{9}{40} \\quad \\Rightarrow \\quad R_{\\text{eq}} = \\frac{40}{9} \\approx 4.44\\,\\Omega $$ 4.7 Summary Series and parallel detection forms the backbone of circuit simplification: Series: Collapse resistors along unbranched paths. Parallel: Merge resistors connecting identical node pairs. Ensure recursive handling of nested structures. This is a key pre-processing step before applying more general techniques like graph traversal, matrix methods, or Y-\u0394 transforms. 5. Resistance Computation 5.1 Objective After reducing a resistor network via series and parallel simplification, or in cases where such reductions are insufficient due to complex interconnections (e.g., multiple loops or bridges), we must compute the equivalent resistance between two specific nodes: the START node \\(A\\) and the END node \\(B\\) . This section presents rigorous methods for computing the effective resistance \\(R_{\\text{eq}}(A, B)\\) in arbitrary networks, using physical laws and graph-theoretic principles. 5.2 Physical Basis Let a voltage \\(V\\) be applied between nodes \\(A\\) and \\(B\\) , resulting in a total current \\(I\\) . The equivalent resistance is given by Ohm's law: \\[ R_{\\text{eq}}(A, B) = \\frac{V}{I} \\] The challenge is to determine \\(I\\) for a given \\(V\\) using laws of circuit analysis. 5.3 Kirchoff\u2019s Laws Two foundational principles are used: Kirchhoff's Current Law (KCL): The total current entering a node equals the total current leaving it. $$ \\sum I_{\\text{in}} = \\sum I_{\\text{out}} $$ Kirchhoff's Voltage Law (KVL): The total voltage change around any closed loop is zero. $$ \\sum_{\\text{loop}} V = 0 $$ Using these laws, we derive a system of equations representing the flow of current and distribution of voltage in the graph. 5.4 Method 1: Node Voltage Method Assign a voltage variable \\(V_i\\) to each node \\(i \\in V\\) , with the reference voltage (e.g., \\(V_B = 0\\) ). Use KCL to write equations at each node, expressing the net current as zero: For node \\(i\\) : $$ \\sum_{j \\in \\mathcal{N}(i)} \\frac{V_i - V_j}{R_{ij}} = 0 $$ where \\(\\mathcal{N}(i)\\) denotes the neighbors of node \\(i\\) . Solve the resulting linear system of equations . Compute the current from \\(A\\) to \\(B\\) : $$ I = \\sum_{j \\in \\mathcal{N}(A)} \\frac{V_A - V_j}{R_{Aj}} $$ Use \\(R_{\\text{eq}} = \\frac{V}{I}\\) (e.g., set \\(V = 1\\) for convenience). 5.5 Method 2: Effective Resistance via Laplacian Matrix The Laplacian matrix \\(L\\) of a graph encodes both connectivity and resistance: Let \\(R_{uv}\\) be the resistance of edge \\((u, v)\\) . Define the conductance as \\(C_{uv} = \\frac{1}{R_{uv}}\\) . Construct the Laplacian : \\(L_{ii} = \\sum_{j \\in \\mathcal{N}(i)} C_{ij}\\) \\(L_{ij} = -C_{ij}\\) for \\(i \\ne j\\) Let \\(L^{\\dagger}\\) be the Moore-Penrose pseudoinverse of \\(L\\) . Then the effective resistance between nodes \\(A\\) and \\(B\\) is: \\[ R_{\\text{eq}}(A, B) = (e_A - e_B)^T L^{\\dagger} (e_A - e_B) \\] where \\(e_A\\) and \\(e_B\\) are indicator vectors with 1 at index \\(A\\) or \\(B\\) and 0 elsewhere. This method is powerful for theoretical analysis and for computing resistances in highly connected or cyclic graphs. 5.6 Algorithmic Considerations Use sparse matrix solvers for large networks. Exploit symmetry and planarity if present. For small or moderately-sized graphs, the node voltage method is often sufficient and interpretable. 5.7 Example Consider the triangle network with nodes \\(1\\) , \\(2\\) , and \\(3\\) , and edges: \\((1, 2, 3\\,\\Omega)\\) \\((2, 3, 5\\,\\Omega)\\) \\((1, 3, 10\\,\\Omega)\\) To find \\(R_{\\text{eq}}(1, 3)\\) : 1. Combine \\((1, 2)\\) and \\((2, 3)\\) in series: \\(R = 3 + 5 = 8\\,\\Omega\\) 2. Then, combine with \\((1, 3)\\) in parallel: $$ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{8} + \\frac{1}{10} = \\frac{9}{40} \\quad \\Rightarrow \\quad R_{\\text{eq}} = \\frac{40}{9} \\approx 4.44\\,\\Omega $$ 5.8 Summary To compute equivalent resistance: - Use simplification when possible (series/parallel). - Apply Kirchhoff\u2019s laws to derive current-voltage relations. - For general graphs, use Laplacian matrix methods and pseudoinverses. - Always calculate \\(R_{\\text{eq}} = \\frac{V}{I}\\) after solving for current or voltage. These techniques ensure correctness across all circuit topologies\u2014from simple chains to complex meshes. 6. Complex Network Reduction 6.1 Motivation While many resistor networks can be simplified using basic series and parallel rules, complex topologies often contain loops , bridges , or interlaced structures that resist straightforward reduction. For such networks, we require more sophisticated methods grounded in graph theory and linear algebra. Two general strategies are applied: - Recursive simplification : Extend series/parallel logic using traversal and pattern detection. - Graph-based algorithms : Use tools like node elimination , matrix methods , and Y-\u0394 (star-delta) transforms to reduce the network. 6.2 Recursive Simplification Recursive simplification automates the identification of reducible structures through iterative scanning of subgraphs. 6.2.1 Recursive Algorithm Steps Search for series or parallel structures . Reduce the identified substructure. Update the graph. Repeat until no more reductions can be made. This process may be implemented via depth-first or breadth-first search to locate collapsible subgraphs. It also forms the basis for symbolic circuit solvers. 6.3 Node Elimination A powerful technique derived from linear algebra is node elimination , where non-terminal nodes are removed and their connections replaced by equivalent resistive links. 6.3.1 Example Suppose node \\(v\\) connects nodes \\(u\\) and \\(w\\) via \\(R_{uv}\\) and \\(R_{vw}\\) . Eliminating \\(v\\) results in: \\[ R_{uw}^{\\text{new}} = R_{uv} + R_{vw} \\] if no other edges are present. This can be extended to more general structures by manipulating the Laplacian matrix or applying graph contraction. 6.4 Y-\u0394 (Star-Delta) Transforms Some resistor networks contain triangular or Y-shaped subgraphs that cannot be reduced by series/parallel rules. The Y-\u0394 transform converts between these two equivalent forms to enable further simplification. 6.4.1 \u0394 to Y Conversion Given a triangle with resistors \\(R_{ab}\\) , \\(R_{bc}\\) , and \\(R_{ca}\\) , the equivalent star resistors are: \\[ R_a = \\frac{R_{ab} R_{ca}}{R_{ab} + R_{bc} + R_{ca}}, \\quad R_b = \\frac{R_{ab} R_{bc}}{R_{ab} + R_{bc} + R_{ca}}, \\quad R_c = \\frac{R_{bc} R_{ca}}{R_{ab} + R_{bc} + R_{ca}} \\] 6.4.2 Y to \u0394 Conversion Given a Y-network with resistors \\(R_a\\) , \\(R_b\\) , \\(R_c\\) connected to a central node: \\[ R_{ab} = \\frac{R_a + R_b + R_a R_b / R_c}, \\quad \\text{and cyclic permutations} \\] Applying such transforms can unlock simplifications otherwise blocked by network geometry. 6.5 Matrix-Based Reduction Another general method is to solve the system of linear equations describing the network: Define the Laplacian matrix \\(L\\) of the graph using conductances \\(C_{uv} = 1 / R_{uv}\\) . Solve the equation \\(L \\mathbf{v} = \\mathbf{i}\\) with boundary conditions (fixed voltages at START and END nodes). Derive total current \\(I\\) and compute: \\[ R_{\\text{eq}} = \\frac{V}{I} \\] This method generalizes to arbitrary networks and supports symbolic and numeric computation. 6.6 Summary To reduce complex resistor networks: - Use recursive simplification for detectably nested structures. - Apply node elimination to remove intermediate nodes. - Perform Y-\u0394 transformations for triangular or star subgraphs. - Use Laplacian methods for fully arbitrary topologies. These tools allow rigorous analysis of circuits far beyond what manual reduction permits and are essential for building scalable solvers. 7. Resistance Computation 7.1 Objective Once the resistor network has been simplified\u2014either through recursive reduction or more advanced graph-based transformations\u2014the final step is to compute the total equivalent resistance between two specified nodes: the START node \\(A\\) and the END node \\(B\\) . This scalar value, denoted as \\(R_{\\text{eq}}(A, B)\\) , characterizes the electrical behavior of the entire network as seen from terminals \\(A\\) and \\(B\\) . 7.2 Assumption: Simplified Graph We assume the circuit graph \\(G = (V, E)\\) has already been reduced as much as possible using: Series/parallel simplification, Y-\u0394 transformations (if applicable), Node elimination (optional), Or left in its original form if handled algorithmically. All remaining resistors are considered essential \u2014i.e., no further simplification is evident from the graph's structure alone. 7.3 Fundamental Approach The total equivalent resistance is computed using: \\[ R_{\\text{eq}} = \\frac{V}{I} \\] where: - \\(V\\) is the potential difference applied between nodes \\(A\\) and \\(B\\) , - \\(I\\) is the total current flowing between these nodes. The methods to compute \\(I\\) depend on whether the graph is simple (e.g., a chain or tree) or arbitrary (containing cycles, bridges, etc.). 7.4 Direct Computation in Simple Cases In very simple cases\u2014e.g., when only a single path or two resistors in parallel remain\u2014the equivalent resistance can be directly computed using the known rules: 7.4.1 Series: \\[ R_{\\text{eq}} = R_1 + R_2 + \\cdots + R_n \\] 7.4.2 Parallel: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\cdots + \\frac{1}{R_n} \\] These cases require no further analysis and can be returned immediately. 7.5 General Case: Node Voltage Method When the graph contains cycles or complex interconnections, we apply Kirchhoff\u2019s Laws and linear algebra. 7.5.1 Steps: Fix node \\(B\\) as reference: \\(V_B = 0\\) Apply KCL at all non-terminal nodes: $$ \\sum_{j \\in \\mathcal{N}(i)} \\frac{V_i - V_j}{R_{ij}} = 0 $$ Solve the resulting linear system for all unknown node voltages \\(V_i\\) . Compute current leaving \\(A\\) : $$ I = \\sum_{j \\in \\mathcal{N}(A)} \\frac{V_A - V_j}{R_{Aj}} $$ Finally, compute: $$ R_{\\text{eq}}(A, B) = \\frac{V_A - V_B}{I} $$ In practice, it is convenient to choose \\(V_A = 1\\) and \\(V_B = 0\\) . 7.6 Laplacian Matrix Method (Optional) In symbolic or large-scale computation, we use the graph Laplacian \\(L\\) and its pseudoinverse \\(L^\\dagger\\) : \\[ R_{\\text{eq}}(A, B) = (e_A - e_B)^T L^\\dagger (e_A - e_B) \\] where \\(e_A\\) and \\(e_B\\) are unit vectors corresponding to nodes \\(A\\) and \\(B\\) . This method guarantees correctness and generality, even on arbitrary networks with thousands of components. 7.7 Visualization It is helpful to visualize the final simplified graph before computing \\(R_{\\text{eq}}\\) , to ensure no redundant paths remain and to trace current paths conceptually. Plotting tools like NetworkX + Matplotlib in Python allow us to inspect the reduced graph before final computation. 7.8 Summary If the simplified graph contains only a few components, apply direct formulas. For general networks, use the node voltage method . For symbolic or matrix-based workflows, use the Laplacian pseudoinverse method . Always finalize by computing: $$ R_{\\text{eq}} = \\frac{V}{I} $$ This value encapsulates the total resistance between START and END nodes and is the ultimate goal of the entire reduction process. 8. Plot and Visualization Circuit simplification Case 1 import networkx as nx import matplotlib.pyplot as plt import os from PIL import Image from IPython.display import HTML import base64 # Step directory folder_name = \"case_1\" os.makedirs(folder_name, exist_ok=True) # Base position layout (same throughout) base_pos = { \"B+\": (0, 1), \"R2\": (1, 1.5), \"R3\": (2, 1.5), \"R4\": (3, 1), \"R5\": (4, 1), \"B-\": (5, 1), \"R1\": (1.5, 0.3) } # Function to draw and save a step def draw_step(G, pos, title, highlight=[], merged_labels={}, filename=\"step.png\"): plt.figure(figsize=(7, 3)) # Colors for nodes colors = [] for node in G.nodes(): if node in highlight: colors.append(\"red\" if \"1\" in node or \"2\" in node or \"3\" in node or \"23\" in node else \"green\" if \"4\" in node or \"5\" in node or \"45\" in node else \"cyan\" if \"123\" in node else \"magenta\") else: colors.append(\"lightgray\") # Labels labels = {n: merged_labels.get(n, n) for n in G.nodes()} nx.draw_networkx_nodes(G, pos, node_color=colors, node_size=1200, node_shape='s', edgecolors='black') nx.draw_networkx_labels(G, pos, labels=labels, font_size=10, font_weight=\"bold\") nx.draw_networkx_edges(G, pos, edge_color=\"gray\", arrows=True, arrowsize=15, width=2) plt.title(title, fontsize=14, loc='left') plt.axis(\"off\") plt.tight_layout() plt.savefig(f\"{folder_name}/{filename}\", dpi=100) plt.close() # Step 0 # Step 1: Initial circuit G1 = nx.DiGraph() G1.add_edges_from([ (\"B+\", \"R2\"), (\"R2\", \"R3\"), (\"R3\", \"R4\"), (\"R4\", \"R5\"), (\"R5\", \"B-\"), (\"B+\", \"R1\"), (\"R1\", \"R4\") ]) draw_step(G1, base_pos, \"Initial circuit\", highlight=[], filename=\"step_0.png\") # Step 1: Initial circuit G1 = nx.DiGraph() G1.add_edges_from([ (\"B+\", \"R2\"), (\"R2\", \"R3\"), (\"R3\", \"R4\"), (\"R4\", \"R5\"), (\"R5\", \"B-\"), (\"B+\", \"R1\"), (\"R1\", \"R4\") ]) draw_step(G1, base_pos, \"First step\", highlight=[\"R2\", \"R3\"], filename=\"step_1.1.png\") # Step 1: After combining R2 and R3 \u2192 R23 G2 = nx.DiGraph() G2.add_edges_from([ (\"B+\", \"R23\"), (\"R23\", \"R4\"), (\"R4\", \"R5\"), (\"R5\", \"B-\"), (\"B+\", \"R1\"), (\"R1\", \"R4\") ]) pos2 = base_pos.copy() pos2[\"R23\"] = ((base_pos[\"R2\"][0] + base_pos[\"R3\"][0]) / 2, base_pos[\"R2\"][1]) draw_step(G2, pos2, \"First step\", highlight=[\"R23\"], merged_labels={\"R23\": \"R23\"}, filename=\"step_1.2.png\") # Step 2: Highlight R4 and R5 draw_step(G2, pos2, \"Second step\", highlight=[\"R4\", \"R5\"], filename=\"step_2.1.png\") # Step 2: Combine R4 + R5 \u2192 R45 G3 = nx.DiGraph() G3.add_edges_from([ (\"B+\", \"R23\"), (\"R23\", \"R45\"), (\"R45\", \"B-\"), (\"B+\", \"R1\"), (\"R1\", \"R45\") ]) pos3 = pos2.copy() pos3[\"R45\"] = ((base_pos[\"R4\"][0] + base_pos[\"R5\"][0]) / 2, base_pos[\"R4\"][1]) draw_step(G3, pos3, \"Second step\", highlight=[\"R45\"], merged_labels={\"R45\": \"R45\"}, filename=\"step_2.2.png\") # Step 3: Highlight R1 and R23 draw_step(G3, pos3, \"Third step\", highlight=[\"R1\", \"R23\"], filename=\"step_3.1.png\") # Step 3: Combine R1 \u2016 R23 \u2192 R123 G4 = nx.DiGraph() G4.add_edges_from([ (\"B+\", \"R123\"), (\"R123\", \"R45\"), (\"R45\", \"B-\") ]) pos4 = pos3.copy() pos4[\"R123\"] = ((base_pos[\"R1\"][0] + pos2[\"R23\"][0]) / 2, 1.1) draw_step(G4, pos4, \"Third step\", highlight=[\"R123\"], merged_labels={\"R123\": \"R123\"}, filename=\"step_3.2.png\") # Step 4: Highlight R123 and R45 draw_step(G4, pos4, \"Fourth step\", highlight=[\"R123\", \"R45\"], filename=\"step_4.1.png\") # Step 4: Combine R123 + R45 \u2192 R12345 G5 = nx.DiGraph() G5.add_edges_from([ (\"B+\", \"R12345\"), (\"R12345\", \"B-\") ]) pos5 = {\"B+\": (0, 1), \"R12345\": (2.5, 1), \"B-\": (5, 1)} draw_step(G5, pos5, \"Fourth step\", highlight=[\"R12345\"], merged_labels={\"R12345\": \"R12345\"}, filename=\"step_4.2.png\") # === Generate GIF from step images === image_files = sorted([f for f in os.listdir(\"case_1\") if f.endswith(\".png\")]) print(image_files) frames = [Image.open(os.path.join(folder_name, fname)) for fname in image_files] gif_path = \"case1_visual_simplification.gif\" frames[0].save(gif_path, save_all=True, append_images=frames[1:], duration=1200, loop=0) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html) Case 2 import networkx as nx import matplotlib.pyplot as plt # ----------------------------- # Function to draw nodes with different shapes # ----------------------------- def custom_draw(G, pos, title): plt.figure(figsize=(12, 4)) circle_nodes = [n for n in G.nodes if n.startswith(\"O\")] rounded_square_nodes = [\"B+\", \"B-\"] square_nodes = [n for n in G.nodes if n.startswith(\"R\")] # V\u1ebd c\u00e1c c\u1ea1nh v\u1edbi m\u0169i t\u00ean nx.draw_networkx_edges( G, pos, arrows=True, arrowstyle='->', arrowsize=20, connectionstyle='arc3,rad=0.0', min_target_margin=15, width=2 ) # V\u1ebd c\u00e1c node h\u00ecnh tr\u00f2n (O) nx.draw_networkx_nodes(G, pos, nodelist=circle_nodes, node_shape='o', node_color='lightgrey', node_size=1000) # Node B+ B- gi\u1ea3 l\u1eadp bo g\u00f3c b\u1eb1ng m\u00e0u tr\u1eafng + vi\u1ec1n \u0111\u1eadm nx.draw_networkx_nodes(G, pos, nodelist=rounded_square_nodes, node_shape='s', node_color='white', edgecolors='black', linewidths=2, node_size=1000) # Node \u0111i\u1ec7n tr\u1edf vu\u00f4ng nx.draw_networkx_nodes(G, pos, nodelist=square_nodes, node_shape='s', node_color='lightgrey', edgecolors='black', linewidths=1, node_size=1000) # V\u1ebd nh\u00e3n nx.draw_networkx_labels(G, pos) plt.title(title) plt.axis('off') plt.show() # ----------------------------- # Picture 1: Resistors as Nodes (Initial) # ----------------------------- G1 = nx.DiGraph() G1.add_edges_from([ (\"B+\", \"R1\"), (\"R1\", \"R2\"), (\"R1\", \"R3\"), (\"R2\", \"O1\"), (\"R3\", \"O1\"), (\"O1\", \"R4\"), (\"O1\", \"R5\"), (\"R4\", \"B-\"), (\"R5\", \"B-\"), ]) pos1 = { \"B+\": (-2, 0), \"R1\": (-1, 0), \"R2\": (0, 1), \"R3\": (0, -1), \"O1\": (1, 0), \"R4\": (2, 1), \"R5\": (2, -1), \"B-\": (3, 0), } custom_draw(G1, pos1, \"Resistors as Nodes (Initial)\") # ----------------------------- # Picture 2: Consistent Node Representation # ----------------------------- G2 = nx.DiGraph() G2.add_edges_from([ (\"B+\", \"O0\"), (\"O0\", \"R1\"), (\"R1\", \"O1\"), (\"O1\", \"R2\"), (\"O1\", \"R3\"), (\"R2\", \"O2\"), (\"R3\", \"O2\"), (\"O2\", \"R4\"), (\"O2\", \"R5\"), (\"R4\", \"O3\"), (\"R5\", \"O3\"), (\"O3\", \"B-\"), ]) pos2 = { \"B+\": (-3, 0), \"O0\": (-2, 0), \"R1\": (-1, 0), \"O1\": (0, 0), \"R2\": (1, 1), \"R3\": (1, -1), \"O2\": (2, 0), \"R4\": (3, 1), \"R5\": (3, -1), \"O3\": (4, 0), \"B-\": (5, 0), } custom_draw(G2, pos2, \"With Junction Nodes\") # ----------------------------- # Picture 3: Edge-Based Resistor Graph # ----------------------------- G3 = nx.DiGraph() G3.add_edges_from([ (\"B+\", \"O0\", {\"label\": \"\"}), (\"O0\", \"O1\", {\"label\": \"R1\"}), (\"O0\", \"O1\", {\"label\": \"R2\"}), (\"O1\", \"O2\", {\"label\": \"R3\"}), (\"O1\", \"O2\", {\"label\": \"R4\"}), (\"O2\", \"O3\", {\"label\": \"R5\"}), (\"O3\", \"B-\", {\"label\": \"\"}), ]) # V\u1ecb tr\u00ed node pos3 = { \"B+\": (-3, 0), \"O0\": (-2, 0), \"O1\": (-1, 0), \"O2\": (0, 0), \"O3\": (1, 0), \"B-\": (2, 0), } plt.figure(figsize=(12, 4)) # V\u1ebd B+ \u2192 O0 nx.draw_networkx_edges(G3, pos3, edgelist=[(\"B+\", \"O0\")], connectionstyle='arc3,rad=0.0', arrowstyle='->', arrowsize=20, width=2 ) # V\u1ebd R1 nx.draw_networkx_edges(G3, pos3, edgelist=[(\"O0\", \"O1\")], connectionstyle='arc3,rad=0.0', arrowstyle='->', arrowsize=20, width=2 ) # V\u1ebd R2: cong l\u00ean nx.draw_networkx_edges(G3, pos3, edgelist=[(\"O1\", \"O2\")], connectionstyle='arc3,rad=0.3', arrowstyle='->', arrowsize=20, width=2 ) # V\u1ebd R3: cong xu\u1ed1ng nx.draw_networkx_edges(G3, pos3, edgelist=[(\"O1\", \"O2\")], connectionstyle='arc3,rad=-0.3', arrowstyle='->', arrowsize=20, width=2 ) # V\u1ebd R4 v\u00e0 R5: h\u01a1i cong l\u00ean & xu\u1ed1ng nx.draw_networkx_edges(G3, pos3, edgelist=[(\"O2\", \"O3\")], connectionstyle='arc3,rad=0.3', arrowstyle='->', arrowsize=20, width=2 ) nx.draw_networkx_edges(G3, pos3, edgelist=[(\"O2\", \"O3\")], connectionstyle='arc3,rad=-0.3', arrowstyle='->', arrowsize=20, width=2 ) # V\u1ebd O3 \u2192 B- nx.draw_networkx_edges(G3, pos3, edgelist=[(\"O3\", \"B-\")], connectionstyle='arc3,rad=0.0', arrowstyle='->', arrowsize=20, width=2 ) # V\u1ebd node circle_nodes = [n for n in G3.nodes if n.startswith(\"O\")] rounded_square_nodes = [\"B+\", \"B-\"] nx.draw_networkx_nodes(G3, pos3, nodelist=circle_nodes, node_shape='o', node_color='lightgrey', node_size=1000) nx.draw_networkx_nodes(G3, pos3, nodelist=rounded_square_nodes, node_shape='s', node_color='white', edgecolors='black', linewidths=2, node_size=1000) # Nh\u00e3n node nx.draw_networkx_labels(G3, pos3) # Nh\u00e3n c\u1ea1nh edge_labels = { (\"O0\", \"O1\"): \"R1\", (\"O1\", \"O2\"): \"R2 / R3\", (\"O2\", \"O3\"): \"R4 / R5\", } nx.draw_networkx_edge_labels(G3, pos3, edge_labels=edge_labels) plt.title(\"Resistors as Edges\") plt.axis('off') plt.show() Initial Consistent Node Representation Edge-Based Resistor Graph Building blocks Series configuration import networkx as nx import matplotlib.pyplot as plt def draw_circuit(G, pos, title): plt.figure(figsize=(10, 5)) # Classify nodes circle_nodes = [n for n in G.nodes if n.startswith('o')] square_nodes = [n for n in G.nodes if n.startswith('I') or n.startswith('D') or n.startswith('R')] # Draw edges nx.draw_networkx_edges(G, pos, arrows=True) # Draw nodes with different shapes nx.draw_networkx_nodes( G, pos, nodelist=circle_nodes, node_color=[G.nodes[n].get('color', 'lightgrey') for n in circle_nodes], node_size=2000, node_shape='o' ) nx.draw_networkx_nodes( G, pos, nodelist=square_nodes, node_color=[G.nodes[n].get('color', 'lightgrey') for n in square_nodes], node_size=2000, node_shape='s' ) # Draw labels nx.draw_networkx_labels(G, pos, font_size=10) plt.title(title) plt.axis('off') plt.show() # First graph: Original circuit G1 = nx.DiGraph() inputs = [f\"I{i}\" for i in range(1, 4)] outputs = [f\"D{i}\" for i in range(1, 5)] # Add nodes and edges G1.add_node(\"o1\", color='lightgreen') G1.add_node(\"o2\", color='red') G1.add_node(\"o3\", color='lightgreen') G1.add_node(\"R1\") G1.add_node(\"R2\") for i in inputs: G1.add_edge(i, \"o1\") G1.add_edge(\"o1\", \"R1\") G1.add_edge(\"R1\", \"o2\") G1.add_edge(\"o2\", \"R2\") G1.add_edge(\"R2\", \"o3\") for d in outputs: G1.add_edge(\"o3\", d) # Positioning manually pos1 = { \"I1\": (-2, 1), \"I2\": (-2, 0), \"I3\": (-2, -1), \"o1\": (-1, 0), \"R1\": (0, 0), \"o2\": (1, 0), \"R2\": (2, 0), \"o3\": (3, 0), \"D1\": (4, 1), \"D2\": (4, 0.5), \"D3\": (4, -0.5), \"D4\": (4, -1) } draw_circuit(G1, pos1, \"Original Circuit\") # Second graph: Simplified circuit G2 = nx.DiGraph() G2.add_node(\"o1\", color='lightgreen') G2.add_node(\"o3\", color='lightgreen') G2.add_node(\"R12\") for i in inputs: G2.add_edge(i, \"o1\") G2.add_edge(\"o1\", \"R12\") G2.add_edge(\"R12\", \"o3\") for i in range(1, 6): # Assume m=5 for illustration G2.add_edge(\"o3\", f\"D{i}\") # Positioning manually pos2 = { \"I1\": (-2, 1), \"I2\": (-2, 0), \"I3\": (-2, -1), \"o1\": (-1, 0), \"R12\": (0, 0), \"o3\": (1, 0), \"D1\": (2, 1), \"D2\": (2, 0.5), \"D3\": (2, 0), \"D4\": (2, -0.5), \"D5\": (2, -1) } draw_circuit(G2, pos2, \"Simplified Circuit\") Can be replaced by Parallel configuration Can be replaced by Colab: Circuit Problem 1 Souce Code","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-problem-overview","text":"","title":"1. Problem Overview"},{"location":"1%20Physics/5%20Circuits/Problem_1/#11-introduction","text":"The objective is to compute the equivalent resistance \\(R_{\\text{eq}}\\) between two designated points in an electrical network: a START node and an END node . This is a foundational problem in circuit theory, as it enables the prediction of current flow, voltage drops, and power dissipation. We model the resistor network as a weighted undirected graph \\(G = (V, E)\\) , where: - \\(V\\) is the set of nodes (electrical junctions), - \\(E\\) is the set of edges (resistors), - Each edge \\(e = (u, v) \\in E\\) has an associated resistance \\(R_{uv} > 0\\) . The central task is to determine \\(R_{\\text{eq}}(A, B)\\) , the effective resistance between a START node \\(A \\in V\\) and an END node \\(B \\in V\\) . If a voltage source \\(V\\) were connected across \\(A\\) and \\(B\\) , the current \\(I\\) flowing through the network would satisfy Ohm\u2019s Law: \\[ R_{\\text{eq}} = \\frac{V}{I} \\]","title":"1.1 Introduction"},{"location":"1%20Physics/5%20Circuits/Problem_1/#12-equivalent-resistance-conceptual-basis","text":"","title":"1.2 Equivalent Resistance: Conceptual Basis"},{"location":"1%20Physics/5%20Circuits/Problem_1/#121-ohms-law","text":"For any two-terminal resistive element: \\[ V = I \\cdot R \\] where: - \\(V\\) is the potential difference (volts), - \\(I\\) is the current (amperes), - \\(R\\) is the resistance (ohms, \\(\\Omega\\) ).","title":"1.2.1 Ohm\u2019s Law"},{"location":"1%20Physics/5%20Circuits/Problem_1/#122-series-configuration","text":"For resistors in series: \\[ R_{\\text{eq}} = R_1 + R_2 + \\cdots + R_n \\] This applies when the same current flows through each resistor without branching paths.","title":"1.2.2 Series Configuration"},{"location":"1%20Physics/5%20Circuits/Problem_1/#123-parallel-configuration","text":"For resistors in parallel: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\cdots + \\frac{1}{R_n} \\] This configuration implies the voltage across each resistor is the same, while the current divides among the paths.","title":"1.2.3 Parallel Configuration"},{"location":"1%20Physics/5%20Circuits/Problem_1/#13-formal-problem-statement","text":"Given: - A graph \\(G = (V, E)\\) with \\(R_e > 0\\) for all \\(e \\in E\\) , - A specified START node \\(A \\in V\\) , - A specified END node \\(B \\in V\\) , Find: the equivalent resistance \\(R_{\\text{eq}}(A, B)\\) between nodes \\(A\\) and \\(B\\) , as if the network were replaced by a single equivalent resistor.","title":"1.3 Formal Problem Statement"},{"location":"1%20Physics/5%20Circuits/Problem_1/#14-applications-and-implications","text":"Accurate computation of \\(R_{\\text{eq}}\\) has applications in: - Power grid analysis, - Signal integrity assessment in microelectronics, - Fault tolerance in communication networks, - Optimization of low-power and efficient designs. Additionally, this problem demonstrates the synergy between electrical engineering and graph theory , showcasing the power of algorithmic thinking in physical systems.","title":"1.4 Applications and Implications"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-graph-representation","text":"","title":"2. Graph Representation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#21-motivation","text":"To analyze electrical circuits algorithmically, we need a mathematical abstraction that captures the topology and resistance values of the network. Graph theory provides a natural framework for modeling circuits, where nodes correspond to electrical junctions and edges represent resistive elements. This abstraction enables the application of graph algorithms to simplify and solve complex networks, particularly when identifying series and parallel connections, or computing resistance between arbitrary nodes.","title":"2.1 Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#22-graph-model","text":"We model a resistor network as an undirected, weighted graph : \\[ G = (V, E, R) \\] where: - \\(V\\) is a set of nodes (or vertices ) representing circuit junctions, - \\(E \\subseteq \\{ \\{u, v\\} \\mid u, v \\in V, u \\neq v \\}\\) is a set of edges representing resistors, - \\(R: E \\rightarrow \\mathbb{R}^+\\) is a function assigning a resistance value \\(R_{uv}\\) to each edge \\(e = \\{u, v\\}\\) . Each resistor is treated as a symmetric component: the resistance between \\(u\\) and \\(v\\) is the same regardless of current direction.","title":"2.2 Graph Model"},{"location":"1%20Physics/5%20Circuits/Problem_1/#23-edge-representation","text":"Each edge (resistor) can be described as a tuple: \\[ (u, v, R_{uv}) \\] where: - \\(u, v \\in V\\) are the connected nodes, - \\(R_{uv} \\in \\mathbb{R}^+\\) is the resistance in ohms \\((\\Omega)\\) . For example, a resistor of \\(5\\,\\Omega\\) between node 1 and node 3 is represented as: \\[ (1, 3, 5) \\] Multiple resistors between the same pair of nodes are treated as parallel resistors and must be aggregated accordingly: \\[ \\frac{1}{R_{\\text{eq}}} = \\sum_{i=1}^{n} \\frac{1}{R_i} \\]","title":"2.3 Edge Representation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#24-adjacency-and-resistance-matrix-representations","text":"The graph can be represented in matrix form to facilitate algorithmic manipulation: Adjacency Matrix \\(A\\) : A symmetric \\(|V| \\times |V|\\) matrix with entries: $$ A_{uv} = \\begin{cases} 1 & \\text{if } {u, v} \\in E \\ 0 & \\text{otherwise} \\end{cases} $$ Resistance Matrix \\(R\\) : A weighted matrix storing resistance values: $$ R_{uv} = \\begin{cases} R_{uv} & \\text{if } {u, v} \\in E \\ \\infty & \\text{otherwise} \\end{cases} $$ These representations are useful for implementing resistance-reduction algorithms and simulations.","title":"2.4 Adjacency and Resistance Matrix Representations"},{"location":"1%20Physics/5%20Circuits/Problem_1/#25-visualization-example","text":"Consider a simple triangular network with nodes \\(A\\) , \\(B\\) , and \\(C\\) , and resistors between each pair: \\((A, B, 2\\,\\Omega)\\) \\((B, C, 3\\,\\Omega)\\) \\((A, C, 4\\,\\Omega)\\) This network can be visualized as a triangle graph, and the total resistance between any two nodes can be computed using the parallel and series reduction rules based on the graph structure.","title":"2.5 Visualization Example"},{"location":"1%20Physics/5%20Circuits/Problem_1/#26-benefits-of-graph-based-representation","text":"Enables recursive simplification. Facilitates cycle detection and transformation (e.g., \u0394-Y transforms). Prepares the circuit for numerical or symbolic computation. Unifies the treatment of arbitrary and complex topologies.","title":"2.6 Benefits of Graph-Based Representation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-input-structure","text":"","title":"3. Input Structure"},{"location":"1%20Physics/5%20Circuits/Problem_1/#31-purpose","text":"To perform automated or algorithmic analysis of circuits, we must establish a precise and unambiguous format for inputting the resistor network. This input captures both the topology of the network (i.e., how nodes are connected) and the numerical values of resistances.","title":"3.1 Purpose"},{"location":"1%20Physics/5%20Circuits/Problem_1/#32-input-components","text":"The input consists of three essential components: Node Set : A list of all nodes in the circuit. Edge List : Each edge is a resistor defined by a pair of nodes and a resistance value. Start and End Nodes : Two nodes \\(A\\) and \\(B\\) between which the equivalent resistance is to be computed.","title":"3.2 Input Components"},{"location":"1%20Physics/5%20Circuits/Problem_1/#33-edge-format","text":"Each resistor is represented as a tuple: \\[ (u, v, R_{uv}) \\in V \\times V \\times \\mathbb{R}^+ \\] where: - \\(u\\) and \\(v\\) are node identifiers, - \\(R_{uv}\\) is the resistance in ohms \\((\\Omega)\\) between \\(u\\) and \\(v\\) . For example, the following list of edges defines a small network: (1, 2, 10) (2, 3, 5) (1, 3, 20) This specifies resistors of \\(10\\Omega\\) , \\(5\\Omega\\) , and \\(20\\Omega\\) respectively between the indicated node pairs.","title":"3.3 Edge Format"},{"location":"1%20Physics/5%20Circuits/Problem_1/#34-input-as-data-structure","text":"In programming terms, the input could be stored as a list of dictionaries or tuples. Example in Python-like pseudocode: edges = [ (1, 2, 10), (2, 3, 5), (1, 3, 20) ] start_node = 1 end_node = 3","title":"3.4 Input as Data Structure"},{"location":"1%20Physics/5%20Circuits/Problem_1/#35-graph-construction","text":"From the edge list, we construct a graph \\(G = (V, E)\\) : The set of vertices \\(V\\) is the union of all nodes that appear in any edge. The set of edges \\(E\\) is directly derived from the input tuples. A mapping function \\(R: E \\rightarrow \\mathbb{R}^+\\) is defined such that: \\[ R(\\{u, v\\}) = R_{uv} \\] If multiple resistors exist between the same node pair (i.e., parallel resistors), their combined resistance is computed before storing: \\[ \\frac{1}{R_{\\text{eq}}(u, v)} = \\sum_{i=1}^{n} \\frac{1}{R_i} \\]","title":"3.5 Graph Construction"},{"location":"1%20Physics/5%20Circuits/Problem_1/#36-special-cases","text":"Duplicate edges : Combine them using the parallel resistance formula. Self-loops : Resistors connecting a node to itself are typically ignored unless explicitly meaningful. Isolated nodes : Nodes not connected to either the start or end can be pruned.","title":"3.6 Special Cases"},{"location":"1%20Physics/5%20Circuits/Problem_1/#37-summary","text":"The input format should: Be compact and readable. Allow for easy graph construction. Support preprocessing for simplification (e.g., merging parallels). Clearly specify the two terminal nodes of interest: START ( \\(A\\) ) and END ( \\(B\\) ).","title":"3.7 Summary"},{"location":"1%20Physics/5%20Circuits/Problem_1/#4-series-and-parallel-detection","text":"","title":"4. Series and Parallel Detection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#41-motivation","text":"To simplify a resistor network, we must identify series and parallel substructures within the graph. These structures allow the replacement of multiple resistors with a single equivalent resistor, thereby reducing circuit complexity and enabling easier computation of \\(R_{\\text{eq}}\\) between the START and END nodes. Automated detection of these configurations is crucial for algorithmic analysis, particularly when dealing with arbitrary and nested resistor arrangements.","title":"4.1 Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#42-series-configuration","text":"Two resistors are in series if: - They are connected end-to-end , i.e., one resistor's endpoint is the other's start point. - The shared node does not connect to any other component (i.e., has degree 2). - The same current flows through both.","title":"4.2 Series Configuration"},{"location":"1%20Physics/5%20Circuits/Problem_1/#421-detection-rule","text":"Given three nodes \\(u\\) , \\(v\\) , and \\(w\\) , if the following conditions hold: - \\((u, v) \\in E\\) and \\((v, w) \\in E\\) , - \\(\\deg(v) = 2\\) , - \\(v \\neq \\text{START}\\) and \\(v \\neq \\text{END}\\) , then the resistors \\(R_{uv}\\) and \\(R_{vw}\\) can be combined in series: \\[ R_{\\text{eq}}(u, w) = R_{uv} + R_{vw} \\] The graph is updated by: - Removing node \\(v\\) , - Adding edge \\((u, w)\\) with weight \\(R_{\\text{eq}}(u, w)\\) .","title":"4.2.1 Detection Rule"},{"location":"1%20Physics/5%20Circuits/Problem_1/#43-parallel-configuration","text":"Two or more resistors are in parallel if: - They connect the same two nodes , - Each provides an independent path for current between those nodes.","title":"4.3 Parallel Configuration"},{"location":"1%20Physics/5%20Circuits/Problem_1/#431-detection-rule","text":"If multiple edges exist between the same node pair \\((u, v)\\) : - \\(\\exists \\{R_1, R_2, \\dots, R_n\\}\\) connecting \\(u\\) and \\(v\\) , - Replace them with a single equivalent resistor: \\[ \\frac{1}{R_{\\text{eq}}(u, v)} = \\sum_{i=1}^{n} \\frac{1}{R_i} \\] The graph is updated by: - Removing all parallel edges, - Adding one edge \\((u, v)\\) with the combined resistance \\(R_{\\text{eq}}\\) .","title":"4.3.1 Detection Rule"},{"location":"1%20Physics/5%20Circuits/Problem_1/#44-general-algorithm-strategy","text":"Repeat the following until no further simplification is possible: 1. Scan all nodes for degree-2 series candidates. 2. Collapse series connections using the rule in Section 4.2. 3. Detect and merge all parallel resistors using the rule in Section 4.3. 4. Update the graph structure accordingly. This recursive simplification reduces the graph step-by-step while preserving the electrical behavior between the START and END nodes.","title":"4.4 General Algorithm Strategy"},{"location":"1%20Physics/5%20Circuits/Problem_1/#45-handling-nested-structures","text":"Series and parallel simplifications can be nested or interleaved , such as: A parallel branch that itself contains series resistors. A series connection where one element is a group of parallel resistors. The algorithm must support recursive detection: - Flatten inner structures before processing outer ones. - Traverse the graph hierarchically or use pattern recognition for subgraphs.","title":"4.5 Handling Nested Structures"},{"location":"1%20Physics/5%20Circuits/Problem_1/#46-example","text":"Given the network: \\((1, 2, 3\\,\\Omega)\\) \\((2, 3, 5\\,\\Omega)\\) \\((1, 3, 10\\,\\Omega)\\) Resistors \\((1, 2)\\) and \\((2, 3)\\) are in series : $$ R_{\\text{series}} = 3 + 5 = 8\\,\\Omega $$ Then, the 8\u2009\u03a9 resistor and the existing 10\u2009\u03a9 between \\((1, 3)\\) are in parallel : $$ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{8} + \\frac{1}{10} = \\frac{9}{40} \\quad \\Rightarrow \\quad R_{\\text{eq}} = \\frac{40}{9} \\approx 4.44\\,\\Omega $$","title":"4.6 Example"},{"location":"1%20Physics/5%20Circuits/Problem_1/#47-summary","text":"Series and parallel detection forms the backbone of circuit simplification: Series: Collapse resistors along unbranched paths. Parallel: Merge resistors connecting identical node pairs. Ensure recursive handling of nested structures. This is a key pre-processing step before applying more general techniques like graph traversal, matrix methods, or Y-\u0394 transforms.","title":"4.7 Summary"},{"location":"1%20Physics/5%20Circuits/Problem_1/#5-resistance-computation","text":"","title":"5. Resistance Computation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#51-objective","text":"After reducing a resistor network via series and parallel simplification, or in cases where such reductions are insufficient due to complex interconnections (e.g., multiple loops or bridges), we must compute the equivalent resistance between two specific nodes: the START node \\(A\\) and the END node \\(B\\) . This section presents rigorous methods for computing the effective resistance \\(R_{\\text{eq}}(A, B)\\) in arbitrary networks, using physical laws and graph-theoretic principles.","title":"5.1 Objective"},{"location":"1%20Physics/5%20Circuits/Problem_1/#52-physical-basis","text":"Let a voltage \\(V\\) be applied between nodes \\(A\\) and \\(B\\) , resulting in a total current \\(I\\) . The equivalent resistance is given by Ohm's law: \\[ R_{\\text{eq}}(A, B) = \\frac{V}{I} \\] The challenge is to determine \\(I\\) for a given \\(V\\) using laws of circuit analysis.","title":"5.2 Physical Basis"},{"location":"1%20Physics/5%20Circuits/Problem_1/#53-kirchoffs-laws","text":"Two foundational principles are used: Kirchhoff's Current Law (KCL): The total current entering a node equals the total current leaving it. $$ \\sum I_{\\text{in}} = \\sum I_{\\text{out}} $$ Kirchhoff's Voltage Law (KVL): The total voltage change around any closed loop is zero. $$ \\sum_{\\text{loop}} V = 0 $$ Using these laws, we derive a system of equations representing the flow of current and distribution of voltage in the graph.","title":"5.3 Kirchoff\u2019s Laws"},{"location":"1%20Physics/5%20Circuits/Problem_1/#54-method-1-node-voltage-method","text":"Assign a voltage variable \\(V_i\\) to each node \\(i \\in V\\) , with the reference voltage (e.g., \\(V_B = 0\\) ). Use KCL to write equations at each node, expressing the net current as zero: For node \\(i\\) : $$ \\sum_{j \\in \\mathcal{N}(i)} \\frac{V_i - V_j}{R_{ij}} = 0 $$ where \\(\\mathcal{N}(i)\\) denotes the neighbors of node \\(i\\) . Solve the resulting linear system of equations . Compute the current from \\(A\\) to \\(B\\) : $$ I = \\sum_{j \\in \\mathcal{N}(A)} \\frac{V_A - V_j}{R_{Aj}} $$ Use \\(R_{\\text{eq}} = \\frac{V}{I}\\) (e.g., set \\(V = 1\\) for convenience).","title":"5.4 Method 1: Node Voltage Method"},{"location":"1%20Physics/5%20Circuits/Problem_1/#55-method-2-effective-resistance-via-laplacian-matrix","text":"The Laplacian matrix \\(L\\) of a graph encodes both connectivity and resistance: Let \\(R_{uv}\\) be the resistance of edge \\((u, v)\\) . Define the conductance as \\(C_{uv} = \\frac{1}{R_{uv}}\\) . Construct the Laplacian : \\(L_{ii} = \\sum_{j \\in \\mathcal{N}(i)} C_{ij}\\) \\(L_{ij} = -C_{ij}\\) for \\(i \\ne j\\) Let \\(L^{\\dagger}\\) be the Moore-Penrose pseudoinverse of \\(L\\) . Then the effective resistance between nodes \\(A\\) and \\(B\\) is: \\[ R_{\\text{eq}}(A, B) = (e_A - e_B)^T L^{\\dagger} (e_A - e_B) \\] where \\(e_A\\) and \\(e_B\\) are indicator vectors with 1 at index \\(A\\) or \\(B\\) and 0 elsewhere. This method is powerful for theoretical analysis and for computing resistances in highly connected or cyclic graphs.","title":"5.5 Method 2: Effective Resistance via Laplacian Matrix"},{"location":"1%20Physics/5%20Circuits/Problem_1/#56-algorithmic-considerations","text":"Use sparse matrix solvers for large networks. Exploit symmetry and planarity if present. For small or moderately-sized graphs, the node voltage method is often sufficient and interpretable.","title":"5.6 Algorithmic Considerations"},{"location":"1%20Physics/5%20Circuits/Problem_1/#57-example","text":"Consider the triangle network with nodes \\(1\\) , \\(2\\) , and \\(3\\) , and edges: \\((1, 2, 3\\,\\Omega)\\) \\((2, 3, 5\\,\\Omega)\\) \\((1, 3, 10\\,\\Omega)\\) To find \\(R_{\\text{eq}}(1, 3)\\) : 1. Combine \\((1, 2)\\) and \\((2, 3)\\) in series: \\(R = 3 + 5 = 8\\,\\Omega\\) 2. Then, combine with \\((1, 3)\\) in parallel: $$ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{8} + \\frac{1}{10} = \\frac{9}{40} \\quad \\Rightarrow \\quad R_{\\text{eq}} = \\frac{40}{9} \\approx 4.44\\,\\Omega $$","title":"5.7 Example"},{"location":"1%20Physics/5%20Circuits/Problem_1/#58-summary","text":"To compute equivalent resistance: - Use simplification when possible (series/parallel). - Apply Kirchhoff\u2019s laws to derive current-voltage relations. - For general graphs, use Laplacian matrix methods and pseudoinverses. - Always calculate \\(R_{\\text{eq}} = \\frac{V}{I}\\) after solving for current or voltage. These techniques ensure correctness across all circuit topologies\u2014from simple chains to complex meshes.","title":"5.8 Summary"},{"location":"1%20Physics/5%20Circuits/Problem_1/#6-complex-network-reduction","text":"","title":"6. Complex Network Reduction"},{"location":"1%20Physics/5%20Circuits/Problem_1/#61-motivation","text":"While many resistor networks can be simplified using basic series and parallel rules, complex topologies often contain loops , bridges , or interlaced structures that resist straightforward reduction. For such networks, we require more sophisticated methods grounded in graph theory and linear algebra. Two general strategies are applied: - Recursive simplification : Extend series/parallel logic using traversal and pattern detection. - Graph-based algorithms : Use tools like node elimination , matrix methods , and Y-\u0394 (star-delta) transforms to reduce the network.","title":"6.1 Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#62-recursive-simplification","text":"Recursive simplification automates the identification of reducible structures through iterative scanning of subgraphs.","title":"6.2 Recursive Simplification"},{"location":"1%20Physics/5%20Circuits/Problem_1/#621-recursive-algorithm-steps","text":"Search for series or parallel structures . Reduce the identified substructure. Update the graph. Repeat until no more reductions can be made. This process may be implemented via depth-first or breadth-first search to locate collapsible subgraphs. It also forms the basis for symbolic circuit solvers.","title":"6.2.1 Recursive Algorithm Steps"},{"location":"1%20Physics/5%20Circuits/Problem_1/#63-node-elimination","text":"A powerful technique derived from linear algebra is node elimination , where non-terminal nodes are removed and their connections replaced by equivalent resistive links.","title":"6.3 Node Elimination"},{"location":"1%20Physics/5%20Circuits/Problem_1/#631-example","text":"Suppose node \\(v\\) connects nodes \\(u\\) and \\(w\\) via \\(R_{uv}\\) and \\(R_{vw}\\) . Eliminating \\(v\\) results in: \\[ R_{uw}^{\\text{new}} = R_{uv} + R_{vw} \\] if no other edges are present. This can be extended to more general structures by manipulating the Laplacian matrix or applying graph contraction.","title":"6.3.1 Example"},{"location":"1%20Physics/5%20Circuits/Problem_1/#64-y-star-delta-transforms","text":"Some resistor networks contain triangular or Y-shaped subgraphs that cannot be reduced by series/parallel rules. The Y-\u0394 transform converts between these two equivalent forms to enable further simplification.","title":"6.4 Y-\u0394 (Star-Delta) Transforms"},{"location":"1%20Physics/5%20Circuits/Problem_1/#641-to-y-conversion","text":"Given a triangle with resistors \\(R_{ab}\\) , \\(R_{bc}\\) , and \\(R_{ca}\\) , the equivalent star resistors are: \\[ R_a = \\frac{R_{ab} R_{ca}}{R_{ab} + R_{bc} + R_{ca}}, \\quad R_b = \\frac{R_{ab} R_{bc}}{R_{ab} + R_{bc} + R_{ca}}, \\quad R_c = \\frac{R_{bc} R_{ca}}{R_{ab} + R_{bc} + R_{ca}} \\]","title":"6.4.1 \u0394 to Y Conversion"},{"location":"1%20Physics/5%20Circuits/Problem_1/#642-y-to-conversion","text":"Given a Y-network with resistors \\(R_a\\) , \\(R_b\\) , \\(R_c\\) connected to a central node: \\[ R_{ab} = \\frac{R_a + R_b + R_a R_b / R_c}, \\quad \\text{and cyclic permutations} \\] Applying such transforms can unlock simplifications otherwise blocked by network geometry.","title":"6.4.2 Y to \u0394 Conversion"},{"location":"1%20Physics/5%20Circuits/Problem_1/#65-matrix-based-reduction","text":"Another general method is to solve the system of linear equations describing the network: Define the Laplacian matrix \\(L\\) of the graph using conductances \\(C_{uv} = 1 / R_{uv}\\) . Solve the equation \\(L \\mathbf{v} = \\mathbf{i}\\) with boundary conditions (fixed voltages at START and END nodes). Derive total current \\(I\\) and compute: \\[ R_{\\text{eq}} = \\frac{V}{I} \\] This method generalizes to arbitrary networks and supports symbolic and numeric computation.","title":"6.5 Matrix-Based Reduction"},{"location":"1%20Physics/5%20Circuits/Problem_1/#66-summary","text":"To reduce complex resistor networks: - Use recursive simplification for detectably nested structures. - Apply node elimination to remove intermediate nodes. - Perform Y-\u0394 transformations for triangular or star subgraphs. - Use Laplacian methods for fully arbitrary topologies. These tools allow rigorous analysis of circuits far beyond what manual reduction permits and are essential for building scalable solvers.","title":"6.6 Summary"},{"location":"1%20Physics/5%20Circuits/Problem_1/#7-resistance-computation","text":"","title":"7. Resistance Computation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#71-objective","text":"Once the resistor network has been simplified\u2014either through recursive reduction or more advanced graph-based transformations\u2014the final step is to compute the total equivalent resistance between two specified nodes: the START node \\(A\\) and the END node \\(B\\) . This scalar value, denoted as \\(R_{\\text{eq}}(A, B)\\) , characterizes the electrical behavior of the entire network as seen from terminals \\(A\\) and \\(B\\) .","title":"7.1 Objective"},{"location":"1%20Physics/5%20Circuits/Problem_1/#72-assumption-simplified-graph","text":"We assume the circuit graph \\(G = (V, E)\\) has already been reduced as much as possible using: Series/parallel simplification, Y-\u0394 transformations (if applicable), Node elimination (optional), Or left in its original form if handled algorithmically. All remaining resistors are considered essential \u2014i.e., no further simplification is evident from the graph's structure alone.","title":"7.2 Assumption: Simplified Graph"},{"location":"1%20Physics/5%20Circuits/Problem_1/#73-fundamental-approach","text":"The total equivalent resistance is computed using: \\[ R_{\\text{eq}} = \\frac{V}{I} \\] where: - \\(V\\) is the potential difference applied between nodes \\(A\\) and \\(B\\) , - \\(I\\) is the total current flowing between these nodes. The methods to compute \\(I\\) depend on whether the graph is simple (e.g., a chain or tree) or arbitrary (containing cycles, bridges, etc.).","title":"7.3 Fundamental Approach"},{"location":"1%20Physics/5%20Circuits/Problem_1/#74-direct-computation-in-simple-cases","text":"In very simple cases\u2014e.g., when only a single path or two resistors in parallel remain\u2014the equivalent resistance can be directly computed using the known rules:","title":"7.4 Direct Computation in Simple Cases"},{"location":"1%20Physics/5%20Circuits/Problem_1/#741-series","text":"\\[ R_{\\text{eq}} = R_1 + R_2 + \\cdots + R_n \\]","title":"7.4.1 Series:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#742-parallel","text":"\\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\cdots + \\frac{1}{R_n} \\] These cases require no further analysis and can be returned immediately.","title":"7.4.2 Parallel:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#75-general-case-node-voltage-method","text":"When the graph contains cycles or complex interconnections, we apply Kirchhoff\u2019s Laws and linear algebra.","title":"7.5 General Case: Node Voltage Method"},{"location":"1%20Physics/5%20Circuits/Problem_1/#751-steps","text":"Fix node \\(B\\) as reference: \\(V_B = 0\\) Apply KCL at all non-terminal nodes: $$ \\sum_{j \\in \\mathcal{N}(i)} \\frac{V_i - V_j}{R_{ij}} = 0 $$ Solve the resulting linear system for all unknown node voltages \\(V_i\\) . Compute current leaving \\(A\\) : $$ I = \\sum_{j \\in \\mathcal{N}(A)} \\frac{V_A - V_j}{R_{Aj}} $$ Finally, compute: $$ R_{\\text{eq}}(A, B) = \\frac{V_A - V_B}{I} $$ In practice, it is convenient to choose \\(V_A = 1\\) and \\(V_B = 0\\) .","title":"7.5.1 Steps:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#76-laplacian-matrix-method-optional","text":"In symbolic or large-scale computation, we use the graph Laplacian \\(L\\) and its pseudoinverse \\(L^\\dagger\\) : \\[ R_{\\text{eq}}(A, B) = (e_A - e_B)^T L^\\dagger (e_A - e_B) \\] where \\(e_A\\) and \\(e_B\\) are unit vectors corresponding to nodes \\(A\\) and \\(B\\) . This method guarantees correctness and generality, even on arbitrary networks with thousands of components.","title":"7.6 Laplacian Matrix Method (Optional)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#77-visualization","text":"It is helpful to visualize the final simplified graph before computing \\(R_{\\text{eq}}\\) , to ensure no redundant paths remain and to trace current paths conceptually. Plotting tools like NetworkX + Matplotlib in Python allow us to inspect the reduced graph before final computation.","title":"7.7 Visualization"},{"location":"1%20Physics/5%20Circuits/Problem_1/#78-summary","text":"If the simplified graph contains only a few components, apply direct formulas. For general networks, use the node voltage method . For symbolic or matrix-based workflows, use the Laplacian pseudoinverse method . Always finalize by computing: $$ R_{\\text{eq}} = \\frac{V}{I} $$ This value encapsulates the total resistance between START and END nodes and is the ultimate goal of the entire reduction process.","title":"7.8 Summary"},{"location":"1%20Physics/5%20Circuits/Problem_1/#8-plot-and-visualization","text":"","title":"8. Plot and Visualization"},{"location":"1%20Physics/5%20Circuits/Problem_1/#circuit-simplification","text":"","title":"Circuit simplification"},{"location":"1%20Physics/5%20Circuits/Problem_1/#case-1","text":"import networkx as nx import matplotlib.pyplot as plt import os from PIL import Image from IPython.display import HTML import base64 # Step directory folder_name = \"case_1\" os.makedirs(folder_name, exist_ok=True) # Base position layout (same throughout) base_pos = { \"B+\": (0, 1), \"R2\": (1, 1.5), \"R3\": (2, 1.5), \"R4\": (3, 1), \"R5\": (4, 1), \"B-\": (5, 1), \"R1\": (1.5, 0.3) } # Function to draw and save a step def draw_step(G, pos, title, highlight=[], merged_labels={}, filename=\"step.png\"): plt.figure(figsize=(7, 3)) # Colors for nodes colors = [] for node in G.nodes(): if node in highlight: colors.append(\"red\" if \"1\" in node or \"2\" in node or \"3\" in node or \"23\" in node else \"green\" if \"4\" in node or \"5\" in node or \"45\" in node else \"cyan\" if \"123\" in node else \"magenta\") else: colors.append(\"lightgray\") # Labels labels = {n: merged_labels.get(n, n) for n in G.nodes()} nx.draw_networkx_nodes(G, pos, node_color=colors, node_size=1200, node_shape='s', edgecolors='black') nx.draw_networkx_labels(G, pos, labels=labels, font_size=10, font_weight=\"bold\") nx.draw_networkx_edges(G, pos, edge_color=\"gray\", arrows=True, arrowsize=15, width=2) plt.title(title, fontsize=14, loc='left') plt.axis(\"off\") plt.tight_layout() plt.savefig(f\"{folder_name}/{filename}\", dpi=100) plt.close() # Step 0 # Step 1: Initial circuit G1 = nx.DiGraph() G1.add_edges_from([ (\"B+\", \"R2\"), (\"R2\", \"R3\"), (\"R3\", \"R4\"), (\"R4\", \"R5\"), (\"R5\", \"B-\"), (\"B+\", \"R1\"), (\"R1\", \"R4\") ]) draw_step(G1, base_pos, \"Initial circuit\", highlight=[], filename=\"step_0.png\") # Step 1: Initial circuit G1 = nx.DiGraph() G1.add_edges_from([ (\"B+\", \"R2\"), (\"R2\", \"R3\"), (\"R3\", \"R4\"), (\"R4\", \"R5\"), (\"R5\", \"B-\"), (\"B+\", \"R1\"), (\"R1\", \"R4\") ]) draw_step(G1, base_pos, \"First step\", highlight=[\"R2\", \"R3\"], filename=\"step_1.1.png\") # Step 1: After combining R2 and R3 \u2192 R23 G2 = nx.DiGraph() G2.add_edges_from([ (\"B+\", \"R23\"), (\"R23\", \"R4\"), (\"R4\", \"R5\"), (\"R5\", \"B-\"), (\"B+\", \"R1\"), (\"R1\", \"R4\") ]) pos2 = base_pos.copy() pos2[\"R23\"] = ((base_pos[\"R2\"][0] + base_pos[\"R3\"][0]) / 2, base_pos[\"R2\"][1]) draw_step(G2, pos2, \"First step\", highlight=[\"R23\"], merged_labels={\"R23\": \"R23\"}, filename=\"step_1.2.png\") # Step 2: Highlight R4 and R5 draw_step(G2, pos2, \"Second step\", highlight=[\"R4\", \"R5\"], filename=\"step_2.1.png\") # Step 2: Combine R4 + R5 \u2192 R45 G3 = nx.DiGraph() G3.add_edges_from([ (\"B+\", \"R23\"), (\"R23\", \"R45\"), (\"R45\", \"B-\"), (\"B+\", \"R1\"), (\"R1\", \"R45\") ]) pos3 = pos2.copy() pos3[\"R45\"] = ((base_pos[\"R4\"][0] + base_pos[\"R5\"][0]) / 2, base_pos[\"R4\"][1]) draw_step(G3, pos3, \"Second step\", highlight=[\"R45\"], merged_labels={\"R45\": \"R45\"}, filename=\"step_2.2.png\") # Step 3: Highlight R1 and R23 draw_step(G3, pos3, \"Third step\", highlight=[\"R1\", \"R23\"], filename=\"step_3.1.png\") # Step 3: Combine R1 \u2016 R23 \u2192 R123 G4 = nx.DiGraph() G4.add_edges_from([ (\"B+\", \"R123\"), (\"R123\", \"R45\"), (\"R45\", \"B-\") ]) pos4 = pos3.copy() pos4[\"R123\"] = ((base_pos[\"R1\"][0] + pos2[\"R23\"][0]) / 2, 1.1) draw_step(G4, pos4, \"Third step\", highlight=[\"R123\"], merged_labels={\"R123\": \"R123\"}, filename=\"step_3.2.png\") # Step 4: Highlight R123 and R45 draw_step(G4, pos4, \"Fourth step\", highlight=[\"R123\", \"R45\"], filename=\"step_4.1.png\") # Step 4: Combine R123 + R45 \u2192 R12345 G5 = nx.DiGraph() G5.add_edges_from([ (\"B+\", \"R12345\"), (\"R12345\", \"B-\") ]) pos5 = {\"B+\": (0, 1), \"R12345\": (2.5, 1), \"B-\": (5, 1)} draw_step(G5, pos5, \"Fourth step\", highlight=[\"R12345\"], merged_labels={\"R12345\": \"R12345\"}, filename=\"step_4.2.png\") # === Generate GIF from step images === image_files = sorted([f for f in os.listdir(\"case_1\") if f.endswith(\".png\")]) print(image_files) frames = [Image.open(os.path.join(folder_name, fname)) for fname in image_files] gif_path = \"case1_visual_simplification.gif\" frames[0].save(gif_path, save_all=True, append_images=frames[1:], duration=1200, loop=0) # Display GIF in Colab using HTML with open(gif_path, 'rb') as f: gif_data = f.read() b64_gif = base64.b64encode(gif_data).decode('utf-8') html = f'<img src=\"data:image/gif;base64,{b64_gif}\">' HTML(html)","title":"Case 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#case-2","text":"import networkx as nx import matplotlib.pyplot as plt # ----------------------------- # Function to draw nodes with different shapes # ----------------------------- def custom_draw(G, pos, title): plt.figure(figsize=(12, 4)) circle_nodes = [n for n in G.nodes if n.startswith(\"O\")] rounded_square_nodes = [\"B+\", \"B-\"] square_nodes = [n for n in G.nodes if n.startswith(\"R\")] # V\u1ebd c\u00e1c c\u1ea1nh v\u1edbi m\u0169i t\u00ean nx.draw_networkx_edges( G, pos, arrows=True, arrowstyle='->', arrowsize=20, connectionstyle='arc3,rad=0.0', min_target_margin=15, width=2 ) # V\u1ebd c\u00e1c node h\u00ecnh tr\u00f2n (O) nx.draw_networkx_nodes(G, pos, nodelist=circle_nodes, node_shape='o', node_color='lightgrey', node_size=1000) # Node B+ B- gi\u1ea3 l\u1eadp bo g\u00f3c b\u1eb1ng m\u00e0u tr\u1eafng + vi\u1ec1n \u0111\u1eadm nx.draw_networkx_nodes(G, pos, nodelist=rounded_square_nodes, node_shape='s', node_color='white', edgecolors='black', linewidths=2, node_size=1000) # Node \u0111i\u1ec7n tr\u1edf vu\u00f4ng nx.draw_networkx_nodes(G, pos, nodelist=square_nodes, node_shape='s', node_color='lightgrey', edgecolors='black', linewidths=1, node_size=1000) # V\u1ebd nh\u00e3n nx.draw_networkx_labels(G, pos) plt.title(title) plt.axis('off') plt.show() # ----------------------------- # Picture 1: Resistors as Nodes (Initial) # ----------------------------- G1 = nx.DiGraph() G1.add_edges_from([ (\"B+\", \"R1\"), (\"R1\", \"R2\"), (\"R1\", \"R3\"), (\"R2\", \"O1\"), (\"R3\", \"O1\"), (\"O1\", \"R4\"), (\"O1\", \"R5\"), (\"R4\", \"B-\"), (\"R5\", \"B-\"), ]) pos1 = { \"B+\": (-2, 0), \"R1\": (-1, 0), \"R2\": (0, 1), \"R3\": (0, -1), \"O1\": (1, 0), \"R4\": (2, 1), \"R5\": (2, -1), \"B-\": (3, 0), } custom_draw(G1, pos1, \"Resistors as Nodes (Initial)\") # ----------------------------- # Picture 2: Consistent Node Representation # ----------------------------- G2 = nx.DiGraph() G2.add_edges_from([ (\"B+\", \"O0\"), (\"O0\", \"R1\"), (\"R1\", \"O1\"), (\"O1\", \"R2\"), (\"O1\", \"R3\"), (\"R2\", \"O2\"), (\"R3\", \"O2\"), (\"O2\", \"R4\"), (\"O2\", \"R5\"), (\"R4\", \"O3\"), (\"R5\", \"O3\"), (\"O3\", \"B-\"), ]) pos2 = { \"B+\": (-3, 0), \"O0\": (-2, 0), \"R1\": (-1, 0), \"O1\": (0, 0), \"R2\": (1, 1), \"R3\": (1, -1), \"O2\": (2, 0), \"R4\": (3, 1), \"R5\": (3, -1), \"O3\": (4, 0), \"B-\": (5, 0), } custom_draw(G2, pos2, \"With Junction Nodes\") # ----------------------------- # Picture 3: Edge-Based Resistor Graph # ----------------------------- G3 = nx.DiGraph() G3.add_edges_from([ (\"B+\", \"O0\", {\"label\": \"\"}), (\"O0\", \"O1\", {\"label\": \"R1\"}), (\"O0\", \"O1\", {\"label\": \"R2\"}), (\"O1\", \"O2\", {\"label\": \"R3\"}), (\"O1\", \"O2\", {\"label\": \"R4\"}), (\"O2\", \"O3\", {\"label\": \"R5\"}), (\"O3\", \"B-\", {\"label\": \"\"}), ]) # V\u1ecb tr\u00ed node pos3 = { \"B+\": (-3, 0), \"O0\": (-2, 0), \"O1\": (-1, 0), \"O2\": (0, 0), \"O3\": (1, 0), \"B-\": (2, 0), } plt.figure(figsize=(12, 4)) # V\u1ebd B+ \u2192 O0 nx.draw_networkx_edges(G3, pos3, edgelist=[(\"B+\", \"O0\")], connectionstyle='arc3,rad=0.0', arrowstyle='->', arrowsize=20, width=2 ) # V\u1ebd R1 nx.draw_networkx_edges(G3, pos3, edgelist=[(\"O0\", \"O1\")], connectionstyle='arc3,rad=0.0', arrowstyle='->', arrowsize=20, width=2 ) # V\u1ebd R2: cong l\u00ean nx.draw_networkx_edges(G3, pos3, edgelist=[(\"O1\", \"O2\")], connectionstyle='arc3,rad=0.3', arrowstyle='->', arrowsize=20, width=2 ) # V\u1ebd R3: cong xu\u1ed1ng nx.draw_networkx_edges(G3, pos3, edgelist=[(\"O1\", \"O2\")], connectionstyle='arc3,rad=-0.3', arrowstyle='->', arrowsize=20, width=2 ) # V\u1ebd R4 v\u00e0 R5: h\u01a1i cong l\u00ean & xu\u1ed1ng nx.draw_networkx_edges(G3, pos3, edgelist=[(\"O2\", \"O3\")], connectionstyle='arc3,rad=0.3', arrowstyle='->', arrowsize=20, width=2 ) nx.draw_networkx_edges(G3, pos3, edgelist=[(\"O2\", \"O3\")], connectionstyle='arc3,rad=-0.3', arrowstyle='->', arrowsize=20, width=2 ) # V\u1ebd O3 \u2192 B- nx.draw_networkx_edges(G3, pos3, edgelist=[(\"O3\", \"B-\")], connectionstyle='arc3,rad=0.0', arrowstyle='->', arrowsize=20, width=2 ) # V\u1ebd node circle_nodes = [n for n in G3.nodes if n.startswith(\"O\")] rounded_square_nodes = [\"B+\", \"B-\"] nx.draw_networkx_nodes(G3, pos3, nodelist=circle_nodes, node_shape='o', node_color='lightgrey', node_size=1000) nx.draw_networkx_nodes(G3, pos3, nodelist=rounded_square_nodes, node_shape='s', node_color='white', edgecolors='black', linewidths=2, node_size=1000) # Nh\u00e3n node nx.draw_networkx_labels(G3, pos3) # Nh\u00e3n c\u1ea1nh edge_labels = { (\"O0\", \"O1\"): \"R1\", (\"O1\", \"O2\"): \"R2 / R3\", (\"O2\", \"O3\"): \"R4 / R5\", } nx.draw_networkx_edge_labels(G3, pos3, edge_labels=edge_labels) plt.title(\"Resistors as Edges\") plt.axis('off') plt.show() Initial Consistent Node Representation Edge-Based Resistor Graph","title":"Case 2"},{"location":"1%20Physics/5%20Circuits/Problem_1/#building-blocks","text":"","title":"Building blocks"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-configuration","text":"import networkx as nx import matplotlib.pyplot as plt def draw_circuit(G, pos, title): plt.figure(figsize=(10, 5)) # Classify nodes circle_nodes = [n for n in G.nodes if n.startswith('o')] square_nodes = [n for n in G.nodes if n.startswith('I') or n.startswith('D') or n.startswith('R')] # Draw edges nx.draw_networkx_edges(G, pos, arrows=True) # Draw nodes with different shapes nx.draw_networkx_nodes( G, pos, nodelist=circle_nodes, node_color=[G.nodes[n].get('color', 'lightgrey') for n in circle_nodes], node_size=2000, node_shape='o' ) nx.draw_networkx_nodes( G, pos, nodelist=square_nodes, node_color=[G.nodes[n].get('color', 'lightgrey') for n in square_nodes], node_size=2000, node_shape='s' ) # Draw labels nx.draw_networkx_labels(G, pos, font_size=10) plt.title(title) plt.axis('off') plt.show() # First graph: Original circuit G1 = nx.DiGraph() inputs = [f\"I{i}\" for i in range(1, 4)] outputs = [f\"D{i}\" for i in range(1, 5)] # Add nodes and edges G1.add_node(\"o1\", color='lightgreen') G1.add_node(\"o2\", color='red') G1.add_node(\"o3\", color='lightgreen') G1.add_node(\"R1\") G1.add_node(\"R2\") for i in inputs: G1.add_edge(i, \"o1\") G1.add_edge(\"o1\", \"R1\") G1.add_edge(\"R1\", \"o2\") G1.add_edge(\"o2\", \"R2\") G1.add_edge(\"R2\", \"o3\") for d in outputs: G1.add_edge(\"o3\", d) # Positioning manually pos1 = { \"I1\": (-2, 1), \"I2\": (-2, 0), \"I3\": (-2, -1), \"o1\": (-1, 0), \"R1\": (0, 0), \"o2\": (1, 0), \"R2\": (2, 0), \"o3\": (3, 0), \"D1\": (4, 1), \"D2\": (4, 0.5), \"D3\": (4, -0.5), \"D4\": (4, -1) } draw_circuit(G1, pos1, \"Original Circuit\") # Second graph: Simplified circuit G2 = nx.DiGraph() G2.add_node(\"o1\", color='lightgreen') G2.add_node(\"o3\", color='lightgreen') G2.add_node(\"R12\") for i in inputs: G2.add_edge(i, \"o1\") G2.add_edge(\"o1\", \"R12\") G2.add_edge(\"R12\", \"o3\") for i in range(1, 6): # Assume m=5 for illustration G2.add_edge(\"o3\", f\"D{i}\") # Positioning manually pos2 = { \"I1\": (-2, 1), \"I2\": (-2, 0), \"I3\": (-2, -1), \"o1\": (-1, 0), \"R12\": (0, 0), \"o3\": (1, 0), \"D1\": (2, 1), \"D2\": (2, 0.5), \"D3\": (2, 0), \"D4\": (2, -0.5), \"D5\": (2, -1) } draw_circuit(G2, pos2, \"Simplified Circuit\") Can be replaced by","title":"Series configuration"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-configuration","text":"Can be replaced by","title":"Parallel configuration"},{"location":"1%20Physics/5%20Circuits/Problem_1/#colab-circuit-problem-1","text":"Souce Code","title":"Colab: Circuit Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}