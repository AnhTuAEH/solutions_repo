{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Projectile motion provides a fundamental framework for understanding physics in two dimensions. This document derives the governing equations, analyzes the range as a function of the angle of projection, explores practical applications, and implements simulations to visualize key relationships. 1. Theoretical Foundation Derivation of Equations of Motion Consider a projectile launched with initial velocity \\(v_0\\) at angle \\(\\theta\\) from height \\(h\\) , under gravity \\(g\\) as the sole force. Using Newton\u2019s second law, \\(\\vec{F} = m \\vec{a}\\) , with \\(F_x = 0\\) and \\(F_y = -mg\\) : Horizontal: \\(\\frac{d^2x}{dt^2} = 0\\) . Vertical: \\(\\frac{d^2y}{dt^2} = -g\\) . Initial conditions are \\(x(0) = 0\\) , \\(y(0) = h\\) , \\(\\frac{dx}{dt}(0) = v_{0x} = v_0 \\cos\\theta\\) , \\(\\frac{dy}{dt}(0) = v_{0y} = v_0 \\sin\\theta\\) . Solving: \\[ x(t) = (v_0 \\cos\\theta) t, \\] \\[ y(t) = h + (v_0 \\sin\\theta) t - \\frac{1}{2} g t^2. \\] Trajectory Equation Eliminate \\(t\\) from \\(x(t)\\) : \\(t = \\frac{x}{v_0 \\cos\\theta}\\) . Substitute into \\(y(t)\\) : \\[ y = h + (v_0 \\sin\\theta) \\frac{x}{v_0 \\cos\\theta} - \\frac{1}{2} g \\left( \\frac{x}{v_0 \\cos\\theta} \\right)^2, \\] \\[ y = h + x \\tan\\theta - \\frac{g x^2}{2 v_0^2 \\cos^2\\theta}. \\] This parabolic form depends on \\(v_0\\) , \\(\\theta\\) , \\(h\\) , and \\(g\\) , defining a family of solutions. Family of Solutions For \\(h = 0\\) , the range \\(R\\) (where \\(y = 0\\) ) is: \\[ 0 = R \\tan\\theta - \\frac{g R^2}{2 v_0^2 \\cos^2\\theta}, \\] \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g}. \\] Varying \\(v_0\\) , \\(\\theta\\) , \\(h\\) , or \\(g\\) generates distinct trajectories, e.g., higher \\(v_0\\) flattens the curve, while \\(h \\neq 0\\) shifts the landing point. 2. Analysis of the Range Range Formula For \\(h = 0\\) : \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g}. \\] Key Parameters \\(v_0\\) : Range scales as \\(v_0^2\\) . \\(g\\) : Inversely proportional to \\(R\\) . \\(\\theta\\) : \\(\\sin 2\\theta\\) peaks at 1, affecting \\(R\\) symmetrically about 45\u00b0. Parameter Effects Increasing \\(v_0\\) : If \\(v_0\\) doubles, \\(R\\) quadruples (e.g., from 10 m/s to 20 m/s, \\(R\\) increases by 4\u00d7). Changing \\(g\\) : On the Moon ( \\(g = 1.62 \\, \\text{m/s}^2\\) ), \\(R\\) is \\(9.81 / 1.62 \\approx 6\\) times larger than on Earth. Varying \\(\\theta\\) : \\(R = 0\\) at \\(\\theta = 0^\\circ, 90^\\circ\\) ; peaks at \\(\\theta = 45^\\circ\\) . Optimal Angle Maximize \\(R = \\frac{v_0^2}{g} \\sin 2\\theta\\) : \\[ \\frac{dR}{d\\theta} = \\frac{v_0^2}{g} \\cdot 2 \\cos 2\\theta = 0, \\] \\[ \\theta = 45^\\circ, \\quad R_{\\text{max}} = \\frac{v_0^2}{g}. \\] 3. Practical Applications Scenarios Basketball : Shots follow \\(y = x \\tan\\theta - \\frac{g x^2}{2 v_0^2 \\cos^2\\theta}\\) . Artillery : Targets require adjusted \\(R\\) . Space Launches : Early trajectories approximate projectiles. Uneven Terrain For landing height \\(h_f\\) : \\[ h_f = h + R \\tan\\theta - \\frac{g R^2}{2 v_0^2 \\cos^2\\theta}, \\] solve the quadratic for \\(R\\) . For \\(h > h_f\\) , \\(R\\) increases. Additional Factors Air Resistance : \\(F_d = -k v^2\\) reduces \\(R\\) , solved numerically. Wind : Adds \\(w t\\) to \\(x(t)\\) , shifting \\(R\\) . Adaptations Use numerical methods (e.g., Runge-Kutta) for drag; adjust \\(x(t) = (v_0 \\cos\\theta + w) t\\) for wind. 4. Implementation Simulation Tool Below are Python scripts simulating projectile motion. Code 1: Plotting the Trajectory for a Single Set of Parameters import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 20.0 # Initial velocity (m/s) theta_deg = 45 # Angle in degrees g = 9.81 # Gravitational acceleration (m/s^2) h = 0.0 # Initial height (m) # Convert angle to radians theta = np.radians(theta_deg) # Time of flight (for h = 0, adjust if h != 0) t_flight = 2 * v0 * np.sin(theta) / g t = np.linspace(0, t_flight, 100) # Position equations x = v0 * np.cos(theta) * t y = h + v0 * np.sin(theta) * t - 0.5 * g * t**2 # Plot plt.figure(figsize=(8, 6)) plt.plot(x, y, label=f'\u03b8 = {theta_deg}\u00b0', color='blue') plt.title('Projectile Trajectory') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Height (m)') plt.grid(True) plt.legend() plt.axhline(0, color='black', linewidth=0.5) plt.show() Code 2: Range vs. Angle for Different Initial Velocities import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 # Gravitational acceleration (m/s^2) angles_deg = np.linspace(0, 90, 91) # Angles from 0\u00b0 to 90\u00b0 angles_rad = np.radians(angles_deg) v0_values = [10, 20, 30] # Different initial velocities (m/s) # Plot plt.figure(figsize=(8, 6)) for v0 in v0_values: R = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles_deg, R, label=f'v\u2080 = {v0} m/s') plt.title('Range vs. Angle of Projection') plt.xlabel('Angle \u03b8 (degrees)') plt.ylabel('Range R (m)') plt.grid(True) plt.legend() plt.show() Code 3: Range vs. Angle for Different Gravitational Accelerations import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 20.0 # Initial velocity (m/s) angles_deg = np.linspace(0, 90, 91) # Angles from 0\u00b0 to 90\u00b0 angles_rad = np.radians(angles_deg) g_values = {'Earth': 9.81, 'Moon': 1.62, 'Mars': 3.72} # Gravity (m/s^2) # Plot plt.figure(figsize=(8, 6)) for planet, g in g_values.items(): R = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles_deg, R, label=f'{planet} (g = {g} m/s\u00b2)') plt.title('Range vs. Angle for Different Gravities') plt.xlabel('Angle \u03b8 (degrees)') plt.ylabel('Range R (m)') plt.grid(True) plt.legend() plt.show() Code 4: Trajectory with Non-Zero Initial Height import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 15.0 # Initial velocity (m/s) theta_deg = 30 # Angle in degrees g = 9.81 # Gravitational acceleration (m/s^2) h_values = [0, 5, 10] # Initial heights (m) theta = np.radians(theta_deg) # Plot plt.figure(figsize=(8, 6)) for h in h_values: # Time of flight (solve quadratic: y = 0) a = -0.5 * g b = v0 * np.sin(theta) c = h t_flight = (-b + np.sqrt(b**2 - 4 * a * c)) / (2 * a) # Positive root t = np.linspace(0, t_flight, 100) x = v0 * np.cos(theta) * t y = h + v0 * np.sin(theta) * t - 0.5 * g * t**2 plt.plot(x, y, label=f'h = {h} m') plt.title('Trajectory with Varying Initial Height') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Height (m)') plt.grid(True) plt.legend() plt.axhline(0, color='black', linewidth=0.5) plt.show() Deliverables Equations : Derived \\(x(t)\\) , \\(y(t)\\) , and \\(R\\) . Graphs : Trajectory and \\(R\\) vs. \\(\\theta\\) plots. Limitations : Ideal model ignores drag; extend with numerical solvers. Conclusion The range \\(R = \\frac{v_0^2 \\sin 2\\theta}{g}\\) peaks at 45\u00b0, scales with \\(v_0^2\\) , and adapts to real-world factors via modifications, demonstrated through simulations. Colab Souce Code","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"Projectile motion provides a fundamental framework for understanding physics in two dimensions. This document derives the governing equations, analyzes the range as a function of the angle of projection, explores practical applications, and implements simulations to visualize key relationships.","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-equations-of-motion","text":"Consider a projectile launched with initial velocity \\(v_0\\) at angle \\(\\theta\\) from height \\(h\\) , under gravity \\(g\\) as the sole force. Using Newton\u2019s second law, \\(\\vec{F} = m \\vec{a}\\) , with \\(F_x = 0\\) and \\(F_y = -mg\\) : Horizontal: \\(\\frac{d^2x}{dt^2} = 0\\) . Vertical: \\(\\frac{d^2y}{dt^2} = -g\\) . Initial conditions are \\(x(0) = 0\\) , \\(y(0) = h\\) , \\(\\frac{dx}{dt}(0) = v_{0x} = v_0 \\cos\\theta\\) , \\(\\frac{dy}{dt}(0) = v_{0y} = v_0 \\sin\\theta\\) . Solving: \\[ x(t) = (v_0 \\cos\\theta) t, \\] \\[ y(t) = h + (v_0 \\sin\\theta) t - \\frac{1}{2} g t^2. \\]","title":"Derivation of Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#trajectory-equation","text":"Eliminate \\(t\\) from \\(x(t)\\) : \\(t = \\frac{x}{v_0 \\cos\\theta}\\) . Substitute into \\(y(t)\\) : \\[ y = h + (v_0 \\sin\\theta) \\frac{x}{v_0 \\cos\\theta} - \\frac{1}{2} g \\left( \\frac{x}{v_0 \\cos\\theta} \\right)^2, \\] \\[ y = h + x \\tan\\theta - \\frac{g x^2}{2 v_0^2 \\cos^2\\theta}. \\] This parabolic form depends on \\(v_0\\) , \\(\\theta\\) , \\(h\\) , and \\(g\\) , defining a family of solutions.","title":"Trajectory Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"For \\(h = 0\\) , the range \\(R\\) (where \\(y = 0\\) ) is: \\[ 0 = R \\tan\\theta - \\frac{g R^2}{2 v_0^2 \\cos^2\\theta}, \\] \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g}. \\] Varying \\(v_0\\) , \\(\\theta\\) , \\(h\\) , or \\(g\\) generates distinct trajectories, e.g., higher \\(v_0\\) flattens the curve, while \\(h \\neq 0\\) shifts the landing point.","title":"Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-formula","text":"For \\(h = 0\\) : \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g}. \\]","title":"Range Formula"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-parameters","text":"\\(v_0\\) : Range scales as \\(v_0^2\\) . \\(g\\) : Inversely proportional to \\(R\\) . \\(\\theta\\) : \\(\\sin 2\\theta\\) peaks at 1, affecting \\(R\\) symmetrically about 45\u00b0.","title":"Key Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#parameter-effects","text":"Increasing \\(v_0\\) : If \\(v_0\\) doubles, \\(R\\) quadruples (e.g., from 10 m/s to 20 m/s, \\(R\\) increases by 4\u00d7). Changing \\(g\\) : On the Moon ( \\(g = 1.62 \\, \\text{m/s}^2\\) ), \\(R\\) is \\(9.81 / 1.62 \\approx 6\\) times larger than on Earth. Varying \\(\\theta\\) : \\(R = 0\\) at \\(\\theta = 0^\\circ, 90^\\circ\\) ; peaks at \\(\\theta = 45^\\circ\\) .","title":"Parameter Effects"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#optimal-angle","text":"Maximize \\(R = \\frac{v_0^2}{g} \\sin 2\\theta\\) : \\[ \\frac{dR}{d\\theta} = \\frac{v_0^2}{g} \\cdot 2 \\cos 2\\theta = 0, \\] \\[ \\theta = 45^\\circ, \\quad R_{\\text{max}} = \\frac{v_0^2}{g}. \\]","title":"Optimal Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#scenarios","text":"Basketball : Shots follow \\(y = x \\tan\\theta - \\frac{g x^2}{2 v_0^2 \\cos^2\\theta}\\) . Artillery : Targets require adjusted \\(R\\) . Space Launches : Early trajectories approximate projectiles.","title":"Scenarios"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#uneven-terrain","text":"For landing height \\(h_f\\) : \\[ h_f = h + R \\tan\\theta - \\frac{g R^2}{2 v_0^2 \\cos^2\\theta}, \\] solve the quadratic for \\(R\\) . For \\(h > h_f\\) , \\(R\\) increases.","title":"Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#additional-factors","text":"Air Resistance : \\(F_d = -k v^2\\) reduces \\(R\\) , solved numerically. Wind : Adds \\(w t\\) to \\(x(t)\\) , shifting \\(R\\) .","title":"Additional Factors"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#adaptations","text":"Use numerical methods (e.g., Runge-Kutta) for drag; adjust \\(x(t) = (v_0 \\cos\\theta + w) t\\) for wind.","title":"Adaptations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#simulation-tool","text":"Below are Python scripts simulating projectile motion.","title":"Simulation Tool"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#code-1-plotting-the-trajectory-for-a-single-set-of-parameters","text":"import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 20.0 # Initial velocity (m/s) theta_deg = 45 # Angle in degrees g = 9.81 # Gravitational acceleration (m/s^2) h = 0.0 # Initial height (m) # Convert angle to radians theta = np.radians(theta_deg) # Time of flight (for h = 0, adjust if h != 0) t_flight = 2 * v0 * np.sin(theta) / g t = np.linspace(0, t_flight, 100) # Position equations x = v0 * np.cos(theta) * t y = h + v0 * np.sin(theta) * t - 0.5 * g * t**2 # Plot plt.figure(figsize=(8, 6)) plt.plot(x, y, label=f'\u03b8 = {theta_deg}\u00b0', color='blue') plt.title('Projectile Trajectory') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Height (m)') plt.grid(True) plt.legend() plt.axhline(0, color='black', linewidth=0.5) plt.show()","title":"Code 1: Plotting the Trajectory for a Single Set of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#code-2-range-vs-angle-for-different-initial-velocities","text":"import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 # Gravitational acceleration (m/s^2) angles_deg = np.linspace(0, 90, 91) # Angles from 0\u00b0 to 90\u00b0 angles_rad = np.radians(angles_deg) v0_values = [10, 20, 30] # Different initial velocities (m/s) # Plot plt.figure(figsize=(8, 6)) for v0 in v0_values: R = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles_deg, R, label=f'v\u2080 = {v0} m/s') plt.title('Range vs. Angle of Projection') plt.xlabel('Angle \u03b8 (degrees)') plt.ylabel('Range R (m)') plt.grid(True) plt.legend() plt.show()","title":"Code 2: Range vs. Angle for Different Initial Velocities"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#code-3-range-vs-angle-for-different-gravitational-accelerations","text":"import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 20.0 # Initial velocity (m/s) angles_deg = np.linspace(0, 90, 91) # Angles from 0\u00b0 to 90\u00b0 angles_rad = np.radians(angles_deg) g_values = {'Earth': 9.81, 'Moon': 1.62, 'Mars': 3.72} # Gravity (m/s^2) # Plot plt.figure(figsize=(8, 6)) for planet, g in g_values.items(): R = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles_deg, R, label=f'{planet} (g = {g} m/s\u00b2)') plt.title('Range vs. Angle for Different Gravities') plt.xlabel('Angle \u03b8 (degrees)') plt.ylabel('Range R (m)') plt.grid(True) plt.legend() plt.show()","title":"Code 3: Range vs. Angle for Different Gravitational Accelerations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#code-4-trajectory-with-non-zero-initial-height","text":"import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 15.0 # Initial velocity (m/s) theta_deg = 30 # Angle in degrees g = 9.81 # Gravitational acceleration (m/s^2) h_values = [0, 5, 10] # Initial heights (m) theta = np.radians(theta_deg) # Plot plt.figure(figsize=(8, 6)) for h in h_values: # Time of flight (solve quadratic: y = 0) a = -0.5 * g b = v0 * np.sin(theta) c = h t_flight = (-b + np.sqrt(b**2 - 4 * a * c)) / (2 * a) # Positive root t = np.linspace(0, t_flight, 100) x = v0 * np.cos(theta) * t y = h + v0 * np.sin(theta) * t - 0.5 * g * t**2 plt.plot(x, y, label=f'h = {h} m') plt.title('Trajectory with Varying Initial Height') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Height (m)') plt.grid(True) plt.legend() plt.axhline(0, color='black', linewidth=0.5) plt.show()","title":"Code 4: Trajectory with Non-Zero Initial Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#deliverables","text":"Equations : Derived \\(x(t)\\) , \\(y(t)\\) , and \\(R\\) . Graphs : Trajectory and \\(R\\) vs. \\(\\theta\\) plots. Limitations : Ideal model ignores drag; extend with numerical solvers.","title":"Deliverables"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"The range \\(R = \\frac{v_0^2 \\sin 2\\theta}{g}\\) peaks at 45\u00b0, scales with \\(v_0^2\\) , and adapts to real-world factors via modifications, demonstrated through simulations.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#colab","text":"Souce Code","title":"Colab"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2: Forced Damped Pendulum 1. Theoretical Foundation The forced damped pendulum is a nonlinear system governed by: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) $$ For small angles, \\(\\sin\\theta \\approx \\theta\\) , yielding a linear equation: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) $$ where \\(\\omega_0 = \\sqrt{g/L}\\) . Solutions include transient decay and a steady-state response: $$ \\theta_p(t) = D \\cos(\\omega t - \\phi), \\quad D = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (b \\omega)^2}} $$ Resonance occurs when \\(\\omega \\approx \\omega_0\\) , maximizing amplitude. 2. System Dynamics Damping \\((b)\\) : Higher \\(b\\) reduces oscillation amplitude and shifts resonance. Driving Amplitude \\((A)\\) : Larger \\(A\\) increases response, introducing nonlinear effects. Driving Frequency \\((\\omega)\\) : Controls synchronization and energy transfer. Chaos : Increasing \\(A\\) can induce period doubling and chaotic behavior. 3. Applications Energy Harvesting : Piezoelectric devices optimize energy capture by tuning \\(\\omega_0\\) . Bridges : Wind-induced oscillations (e.g., Tacoma Narrows) align with resonance behavior. Oscillating Circuits : Analogous to RLC circuits with \\(\\omega_0\\) and damping. 4. Implementation of the Forced Damped Pendulum Simulation This section outlines the computational framework to simulate the forced damped pendulum, governed by: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] We develop a model using Python, incorporating parameters\u2014damping coefficient \\((b)\\) , driving amplitude \\((A)\\) , driving frequency \\((\\omega)\\) , and initial conditions \\((\\theta_0, \\dot{\\theta}_0)\\) to explore the system\u2019s behavior. Separate visualizations highlight time evolution, phase portraits, and Poincar\u00e9 sections, revealing periodic, quasiperiodic, and chaotic regimes. 4.1 Computational Model Setup The nonlinear second-order ODE is converted to a system of first-order ODEs: \\[ \\frac{d\\theta}{dt} = v \\] \\[ \\frac{dv}{dt} = -b v - \\frac{g}{L} \\sin\\theta + A \\cos(\\omega t) \\] We use scipy.integrate.odeint for numerical integration, with \\(g/L = 1\\) (normalized natural frequency \\(\\omega_0 = 1\\) ) for simplicity. 4.2 Time Series: Effect of Damping and Driving Amplitude This script simulates \\(\\theta(t)\\) under varying \\(b\\) and \\(A\\) , illustrating damping\u2019s stabilizing effect and amplitude\u2019s role in driving oscillations. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def pendulum(state, t, b, A, omega): theta, v = state dtheta_dt = v dv_dt = -b * v - np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 50, 1000) # Time array omega = 2/3 # Driving frequency initial_conditions = [0.1, 0] # [theta0, v0] # Cases to compare params = [(0.1, 0.5, \"b=0.1, A=0.5\"), (0.5, 0.5, \"b=0.5, A=0.5\"), (0.1, 1.2, \"b=0.1, A=1.2\")] # Simulate and plot plt.figure(figsize=(10, 6)) for b, A, label in params: sol = odeint(pendulum, initial_conditions, t, args=(b, A, omega)) theta = sol[:, 0] plt.plot(t, theta, label=label) plt.xlabel(\"Time (s)\") plt.ylabel(r\"$\\theta$ (rad)\") plt.title(\"Time Series: Effect of Damping and Driving Amplitude\") plt.legend() plt.grid(True) plt.show() Output : A plot comparing \\(\\theta(t)\\) for low damping/low amplitude (periodic), high damping (damped periodic), and low damping/high amplitude (approaching chaos). 4.3 Phase Diagram: \\(\\theta\\) vs. \\(\\dot{\\theta}\\) This script generates a phase portrait, showing the relationship between \\(\\theta\\) and \\(v = \\dot{\\theta}\\) , revealing attractors and dynamic regimes. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # System definition (same as above) def pendulum(state, t, b, A, omega): theta, v = state dtheta_dt = v dv_dt = -b * v - np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 100, 2000) # Longer time for steady state b = 0.1 # Damping A = 1.15 # Driving amplitude (near chaotic threshold) omega = 2/3 # Driving frequency initial_conditions = [0.1, 0] # Solve sol = odeint(pendulum, initial_conditions, t, args=(b, A, omega)) theta = sol[:, 0] v = sol[:, 1] # Plot phase diagram plt.figure(figsize=(8, 6)) plt.plot(theta, v, lw=0.5) plt.xlabel(r\"$\\theta$ (rad)\") plt.ylabel(r\"$\\dot{\\theta}$ (rad/s)\") plt.title(\"Phase Diagram: $\\theta$ vs. $\\dot{\\theta}$ (b=0.1, A=1.15, $\\omega$=2/3)\") plt.grid(True) plt.show() Output : A phase portrait showing a complex trajectory, potentially a strange attractor, indicating chaotic behavior for \\(A = 1.15\\) . 4.4 Poincar\u00e9 Section: Transition to Chaos This script constructs a Poincar\u00e9 section by sampling \\(\\theta\\) and \\(\\dot{\\theta}\\) at intervals of the driving period \\((T = 2\\pi/\\omega)\\) , highlighting the transition from regular to chaotic motion. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # System definition (same as above) def pendulum(state, t, b, A, omega): theta, v = state dtheta_dt = v dv_dt = -b * v - np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dv_dt] # Parameters omega = 2/3 T = 2 * np.pi / omega # Driving period t = np.linspace(0, 500, 10000) # Long time for convergence b = 0.1 A = 1.15 # Chaotic regime initial_conditions = [0.1, 0] # Solve sol = odeint(pendulum, initial_conditions, t, args=(b, A, omega)) theta = sol[:, 0] v = sol[:, 1] # Poincar\u00e9 section: sample at t = n * T section_times = np.arange(0, 500, T) section_indices = [np.argmin(np.abs(t - st)) for st in section_times] theta_section = theta[section_indices] v_section = v[section_indices] # Plot plt.figure(figsize=(8, 6)) plt.scatter(theta_section, v_section, s=5, c='black') plt.xlabel(r\"$\\theta$ (rad)\") plt.ylabel(r\"$\\dot{\\theta}$ (rad/s)\") plt.title(\"Poincar\u00e9 Section (b=0.1, A=1.15, $\\omega$=2/3)\") plt.grid(True) plt.show() Output : A scatter plot showing a fractal-like structure, characteristic of chaos, with points filling a region rather than forming a closed curve (periodic) or finite set (quasiperiodic). 5. Colab Souce Code","title":"Problem 2: Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2-forced-damped-pendulum","text":"","title":"Problem 2: Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The forced damped pendulum is a nonlinear system governed by: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) $$ For small angles, \\(\\sin\\theta \\approx \\theta\\) , yielding a linear equation: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) $$ where \\(\\omega_0 = \\sqrt{g/L}\\) . Solutions include transient decay and a steady-state response: $$ \\theta_p(t) = D \\cos(\\omega t - \\phi), \\quad D = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (b \\omega)^2}} $$ Resonance occurs when \\(\\omega \\approx \\omega_0\\) , maximizing amplitude.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-system-dynamics","text":"Damping \\((b)\\) : Higher \\(b\\) reduces oscillation amplitude and shifts resonance. Driving Amplitude \\((A)\\) : Larger \\(A\\) increases response, introducing nonlinear effects. Driving Frequency \\((\\omega)\\) : Controls synchronization and energy transfer. Chaos : Increasing \\(A\\) can induce period doubling and chaotic behavior.","title":"2. System Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-applications","text":"Energy Harvesting : Piezoelectric devices optimize energy capture by tuning \\(\\omega_0\\) . Bridges : Wind-induced oscillations (e.g., Tacoma Narrows) align with resonance behavior. Oscillating Circuits : Analogous to RLC circuits with \\(\\omega_0\\) and damping.","title":"3. Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-of-the-forced-damped-pendulum-simulation","text":"This section outlines the computational framework to simulate the forced damped pendulum, governed by: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] We develop a model using Python, incorporating parameters\u2014damping coefficient \\((b)\\) , driving amplitude \\((A)\\) , driving frequency \\((\\omega)\\) , and initial conditions \\((\\theta_0, \\dot{\\theta}_0)\\) to explore the system\u2019s behavior. Separate visualizations highlight time evolution, phase portraits, and Poincar\u00e9 sections, revealing periodic, quasiperiodic, and chaotic regimes.","title":"4. Implementation of the Forced Damped Pendulum Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#41-computational-model-setup","text":"The nonlinear second-order ODE is converted to a system of first-order ODEs: \\[ \\frac{d\\theta}{dt} = v \\] \\[ \\frac{dv}{dt} = -b v - \\frac{g}{L} \\sin\\theta + A \\cos(\\omega t) \\] We use scipy.integrate.odeint for numerical integration, with \\(g/L = 1\\) (normalized natural frequency \\(\\omega_0 = 1\\) ) for simplicity.","title":"4.1 Computational Model Setup"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#42-time-series-effect-of-damping-and-driving-amplitude","text":"This script simulates \\(\\theta(t)\\) under varying \\(b\\) and \\(A\\) , illustrating damping\u2019s stabilizing effect and amplitude\u2019s role in driving oscillations. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def pendulum(state, t, b, A, omega): theta, v = state dtheta_dt = v dv_dt = -b * v - np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 50, 1000) # Time array omega = 2/3 # Driving frequency initial_conditions = [0.1, 0] # [theta0, v0] # Cases to compare params = [(0.1, 0.5, \"b=0.1, A=0.5\"), (0.5, 0.5, \"b=0.5, A=0.5\"), (0.1, 1.2, \"b=0.1, A=1.2\")] # Simulate and plot plt.figure(figsize=(10, 6)) for b, A, label in params: sol = odeint(pendulum, initial_conditions, t, args=(b, A, omega)) theta = sol[:, 0] plt.plot(t, theta, label=label) plt.xlabel(\"Time (s)\") plt.ylabel(r\"$\\theta$ (rad)\") plt.title(\"Time Series: Effect of Damping and Driving Amplitude\") plt.legend() plt.grid(True) plt.show() Output : A plot comparing \\(\\theta(t)\\) for low damping/low amplitude (periodic), high damping (damped periodic), and low damping/high amplitude (approaching chaos).","title":"4.2 Time Series: Effect of Damping and Driving Amplitude"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#43-phase-diagram-theta-vs-dottheta","text":"This script generates a phase portrait, showing the relationship between \\(\\theta\\) and \\(v = \\dot{\\theta}\\) , revealing attractors and dynamic regimes. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # System definition (same as above) def pendulum(state, t, b, A, omega): theta, v = state dtheta_dt = v dv_dt = -b * v - np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dv_dt] # Parameters t = np.linspace(0, 100, 2000) # Longer time for steady state b = 0.1 # Damping A = 1.15 # Driving amplitude (near chaotic threshold) omega = 2/3 # Driving frequency initial_conditions = [0.1, 0] # Solve sol = odeint(pendulum, initial_conditions, t, args=(b, A, omega)) theta = sol[:, 0] v = sol[:, 1] # Plot phase diagram plt.figure(figsize=(8, 6)) plt.plot(theta, v, lw=0.5) plt.xlabel(r\"$\\theta$ (rad)\") plt.ylabel(r\"$\\dot{\\theta}$ (rad/s)\") plt.title(\"Phase Diagram: $\\theta$ vs. $\\dot{\\theta}$ (b=0.1, A=1.15, $\\omega$=2/3)\") plt.grid(True) plt.show() Output : A phase portrait showing a complex trajectory, potentially a strange attractor, indicating chaotic behavior for \\(A = 1.15\\) .","title":"4.3 Phase Diagram: \\(\\theta\\) vs. \\(\\dot{\\theta}\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#44-poincare-section-transition-to-chaos","text":"This script constructs a Poincar\u00e9 section by sampling \\(\\theta\\) and \\(\\dot{\\theta}\\) at intervals of the driving period \\((T = 2\\pi/\\omega)\\) , highlighting the transition from regular to chaotic motion. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # System definition (same as above) def pendulum(state, t, b, A, omega): theta, v = state dtheta_dt = v dv_dt = -b * v - np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dv_dt] # Parameters omega = 2/3 T = 2 * np.pi / omega # Driving period t = np.linspace(0, 500, 10000) # Long time for convergence b = 0.1 A = 1.15 # Chaotic regime initial_conditions = [0.1, 0] # Solve sol = odeint(pendulum, initial_conditions, t, args=(b, A, omega)) theta = sol[:, 0] v = sol[:, 1] # Poincar\u00e9 section: sample at t = n * T section_times = np.arange(0, 500, T) section_indices = [np.argmin(np.abs(t - st)) for st in section_times] theta_section = theta[section_indices] v_section = v[section_indices] # Plot plt.figure(figsize=(8, 6)) plt.scatter(theta_section, v_section, s=5, c='black') plt.xlabel(r\"$\\theta$ (rad)\") plt.ylabel(r\"$\\dot{\\theta}$ (rad/s)\") plt.title(\"Poincar\u00e9 Section (b=0.1, A=1.15, $\\omega$=2/3)\") plt.grid(True) plt.show() Output : A scatter plot showing a fractal-like structure, characteristic of chaos, with points filling a region rather than forming a closed curve (periodic) or finite set (quasiperiodic).","title":"4.4 Poincar\u00e9 Section: Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-colab","text":"Souce Code","title":"5. Colab"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Hello","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"Hello","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}